# FAQ表示件数不一致問題 - 根本原因究明と修正案

## 1. 問題の概要

### 1.1 報告された問題
- **現象**: Standardプランで新規登録後、FAQ一覧を確認すると5件のみ表示
- **リロード後**: 17件表示
- **期待値**: 30件表示
- **データベース**: 30件のFAQが正しく登録されている

### 1.2 調査結果の要約
- ✅ データベースには30件のFAQが正しく登録されている
- ✅ `FAQService.get_faqs()`を直接呼び出すと、30件が正しく取得される
- ✅ バックグラウンド処理は完了している（268秒経過）
- ❌ フロントエンドでは5件や17件しか表示されない

## 2. 根本原因の分析

### 2.1 トランザクション分離レベルの問題

**問題の核心**:
`bulk_create_faqs`メソッドは、30件のFAQを順次作成する際、各FAQ作成時に`flush()`のみを実行し、最後に1回だけ`commit()`を実行しています。

**現在の実装**:
```python
async def bulk_create_faqs(
    self,
    facility_id: int,
    faq_requests: List[FAQRequest],
    user_id: int
) -> List[FAQResponse]:
    created_faqs = []
    
    for request in faq_requests:
        # 個別のcreate_faqを呼び出し
        faq_response = await self.create_faq(...)  # 内部でflush()のみ
        created_faqs.append(faq_response)
    
    # 最後に1回だけcommit()
    await self.db.commit()
```

**`create_faq`の実装**:
```python
async def create_faq(...):
    # FAQ作成
    faq = FAQ(...)
    self.db.add(faq)
    await self.db.flush()  # ← コミット前のflush
    
    # FAQTranslation作成
    for trans_request in request.translations:
        translation = FAQTranslation(...)
        self.db.add(translation)
        await self.db.flush()  # ← コミット前のflush
    
    # 埋め込みベクトル生成
    embedding = await generate_embedding(...)
    translation.embedding = embedding
    await self.db.flush()  # ← コミット前のflush
    
    # 注意: commit()は呼ばれていない！
    return FAQResponse(...)
```

### 2.2 問題の発生フロー

1. **バックグラウンド処理開始**（施設作成後、約0.28秒後）
   - `register_facility_async_faqs`が開始
   - 新しいデータベースセッション（`AsyncSessionLocal()`）を作成
   - トランザクション開始（暗黙的）

2. **FAQ作成の進行**（約25秒かかる）
   - 5件目: 約3.68秒後
   - 17件目: 約15.65秒後
   - 30件目: 約25.36秒後
   - **重要**: この間、すべてのFAQは`flush()`のみで、まだ`commit()`されていない

3. **フロントエンドがFAQ一覧を取得**（約3.68秒後、5件作成済み）
   - フロントエンドが`GET /api/v1/admin/faqs`を呼び出す
   - **別のデータベースセッション**でFAQ一覧を取得
   - **トランザクション分離レベルの問題**: 未コミットのデータは見えない
   - しかし、実際には5件が表示される → **これは別の問題を示唆**

4. **バックグラウンド処理が進行中**（約15.65秒後、17件作成済み）
   - フロントエンドがリロードしてFAQ一覧を取得
   - 17件が表示される → **これも未コミットのデータが見えている**

5. **バックグラウンド処理完了**（約25.36秒後、30件作成済み）
   - `await db.commit()`が実行される
   - すべてのFAQがコミットされる

### 2.3 根本原因の特定

**問題1: トランザクション分離レベルの不一致**

PostgreSQLのデフォルトのトランザクション分離レベルは`READ COMMITTED`です。これは、他のトランザクションがコミットしたデータのみが見えることを意味します。

しかし、実際の動作では：
- 5件が表示される → 未コミットのデータが見えている
- 17件が表示される → 未コミットのデータが見えている

これは、**同じデータベースセッション内で`flush()`されたデータが、同じセッション内のクエリで見える**ためです。

**問題2: バックグラウンド処理とAPIリクエストのセッション分離**

`register_facility_async_faqs`は新しいセッション（`AsyncSessionLocal()`）を作成しますが、APIリクエストも別のセッション（`get_db()`）を作成します。

**問題3: キャッシュのタイミング**

修正案1（30秒以内はキャッシュを保存しない）は機能していますが、問題は**バックグラウンド処理が完了する前にFAQ一覧を取得すると、その時点でのFAQ数がデータベースから取得される**ことです。

### 2.4 実際の問題

**真の根本原因**:
1. **バックグラウンド処理が完了する前にFAQ一覧を取得すると、その時点でのFAQ数が取得される**
   - 5件作成済みの時点で取得 → 5件
   - 17件作成済みの時点で取得 → 17件
   - 30件作成済みの時点で取得 → 30件

2. **キャッシュが保存されない（修正案1）ため、毎回データベースから取得される**
   - しかし、バックグラウンド処理が完了する前は、未コミットのデータが見えない可能性がある

3. **しかし、実際には未コミットのデータが見えている**
   - これは、**同じデータベース接続プール内で、`flush()`されたデータが他のセッションからも見える**可能性がある

## 3. 修正案

### 3.1 修正方針

**大原則に準拠した根本的解決**:
1. **バックグラウンド処理が完了するまで、FAQ一覧取得APIで最新のデータを返す**
2. **バックグラウンド処理の完了を検知する仕組みを追加**
3. **キャッシュの無効化を確実に実行**

### 3.2 修正案1: バックグラウンド処理完了フラグの追加

**概要**:
施設テーブルに`faq_initialization_completed`フラグを追加し、バックグラウンド処理が完了したら`True`に設定します。FAQ一覧取得APIでは、このフラグが`False`の場合は、バックグラウンド処理が完了するまで待機するか、進行中の状態を返します。

**実装**:
1. `facilities`テーブルに`faq_initialization_completed`カラムを追加（デフォルト: `False`）
2. `register_facility_async_faqs`で、FAQ作成完了後に`faq_initialization_completed = True`に設定
3. `get_faqs`で、`faq_initialization_completed = False`の場合は、バックグラウンド処理が完了するまで待機（最大30秒）

**メリット**:
- 根本的な解決
- バックグラウンド処理が完了するまで、確実に最新のデータを返す

**デメリット**:
- データベーススキーマの変更が必要
- 待機処理により、APIレスポンスが遅くなる可能性がある

### 3.3 修正案2: バックグラウンド処理中のFAQ数をチェック

**概要**:
FAQ一覧取得APIで、施設作成から30秒以内の場合、期待されるFAQ数と実際のFAQ数を比較し、一致しない場合は待機します。

**実装**:
1. `get_faqs`で、施設作成から30秒以内の場合、期待されるFAQ数を取得
2. 実際のFAQ数が期待値と一致しない場合、最大30秒まで待機（ポーリング）
3. 30秒経過後も一致しない場合は、現在のFAQ数を返す

**メリット**:
- データベーススキーマの変更が不要
- バックグラウンド処理が完了するまで、確実に最新のデータを返す

**デメリット**:
- 待機処理により、APIレスポンスが遅くなる可能性がある
- ポーリング処理が複雑になる

### 3.4 修正案3: バックグラウンド処理完了後のキャッシュ無効化を強化（現在の修正案2の拡張）

**概要**:
現在の修正案2（5秒待ってから再度キャッシュを無効化）を拡張し、より確実にキャッシュを無効化します。

**実装**:
1. バックグラウンド処理完了後、10秒待ってから再度キャッシュを無効化
2. さらに10秒待ってから、もう一度キャッシュを無効化（合計20秒後）
3. これにより、バックグラウンド処理完了直後に取得されたキャッシュも確実に無効化される

**メリット**:
- データベーススキーマの変更が不要
- 実装が簡単

**デメリット**:
- 根本的な解決にはならない（タイミング問題が残る）
- バックグラウンド処理が完了する前にFAQ一覧を取得すると、まだ問題が発生する可能性がある

### 3.5 修正案4: バックグラウンド処理を同期的に実行（推奨しない）

**概要**:
バックグラウンド処理を同期的に実行し、すべてのFAQ作成が完了してからレスポンスを返します。

**メリット**:
- 確実にすべてのFAQが作成される
- タイミング問題が発生しない

**デメリット**:
- **大原則に違反**: 「非同期処理によるパフォーマンス向上」の原則に反する
- タイムアウトエラーが再発する可能性がある
- ユーザー体験が悪化する

## 4. 推奨修正案

### 4.1 推奨: 修正案2（バックグラウンド処理中のFAQ数をチェック）

**理由**:
1. **大原則に準拠**: 根本的な解決を提供
2. **データベーススキーマの変更が不要**: 既存のテーブル構造を維持
3. **確実性**: バックグラウンド処理が完了するまで、最新のデータを返す

### 4.2 実装詳細

**修正1: `get_faqs`メソッドの修正**

```python
async def get_faqs(
    self,
    facility_id: int,
    category: Optional[str] = None,
    is_active: Optional[bool] = None
) -> List[FAQResponse]:
    # ... (既存のキャッシュチェック)
    
    # バックグラウンド処理が完了しているか確認
    from app.models.facility import Facility
    from app.core.plan_limits import get_initial_faq_count
    from datetime import datetime, timezone, timedelta
    import asyncio
    
    facility = await self.db.get(Facility, facility_id)
    if facility:
        time_since_creation = datetime.now(timezone.utc) - facility.created_at
        
        # 施設作成から30秒以内の場合、バックグラウンド処理が完了しているか確認
        if time_since_creation < timedelta(seconds=30):
            expected_count = get_initial_faq_count(facility.subscription_plan)
            
            # 実際のFAQ数を取得
            query = select(FAQ).where(FAQ.facility_id == facility_id)
            if category:
                query = query.where(FAQ.category == category)
            if is_active is not None:
                query = query.where(FAQ.is_active == is_active)
            result = await self.db.execute(query)
            actual_count = len(result.scalars().all())
            
            # 期待値と一致しない場合、最大30秒まで待機（ポーリング）
            if actual_count < expected_count:
                max_wait_time = 30  # 最大30秒
                poll_interval = 0.5  # 0.5秒ごとにポーリング
                elapsed_time = 0
                
                while actual_count < expected_count and elapsed_time < max_wait_time:
                    await asyncio.sleep(poll_interval)
                    elapsed_time += poll_interval
                    
                    # 再度FAQ数を取得
                    result = await self.db.execute(query)
                    actual_count = len(result.scalars().all())
                    
                    # キャッシュを無効化（最新のデータを取得するため）
                    await delete_cache_pattern(f"faq:list:*facility_id={facility_id}*")
                
                if actual_count < expected_count:
                    logger.warning(
                        f"FAQ count mismatch after waiting: "
                        f"facility_id={facility_id}, expected={expected_count}, actual={actual_count}"
                    )
    
    # ... (既存のFAQ取得処理)
```

**修正2: `register_facility_async_faqs`の修正**

現在の実装（5秒待ってから再度キャッシュを無効化）は維持しますが、より確実にするため、10秒待ってから再度無効化します。

```python
# バックグラウンド処理完了後、10秒待ってから再度キャッシュを無効化
import asyncio
await asyncio.sleep(10)

try:
    deleted_count = await delete_cache_pattern(f"faq:list:*facility_id={facility_id}*")
    logger.info(
        f"FAQ cache invalidated (delayed): {deleted_count} keys deleted "
        f"(facility_id={facility_id})"
    )
except Exception as e:
    logger.warning(
        f"Failed to invalidate FAQ cache (delayed): facility_id={facility_id}, "
        f"error={str(e)}",
        exc_info=True
    )
```

## 5. 実装手順

1. **修正1: `get_faqs`メソッドの修正**
   - バックグラウンド処理が完了するまで待機するロジックを追加
   - ポーリング間隔: 0.5秒
   - 最大待機時間: 30秒

2. **修正2: `register_facility_async_faqs`の修正**
   - キャッシュ無効化の待機時間を10秒に延長

3. **テスト**
   - Standardプランで新規登録
   - FAQ一覧が30件表示されることを確認
   - リロード後も30件表示されることを確認

## 6. 期待される効果

1. **バックグラウンド処理が完了するまで、FAQ一覧取得APIが待機する**
2. **確実に30件のFAQが表示される**
3. **リロード後も30件が表示される**
4. **タイミング問題が解決される**

## 7. 注意事項

1. **APIレスポンスの遅延**: バックグラウンド処理が完了するまで、最大30秒待機する可能性がある
2. **ポーリング処理**: 0.5秒ごとにデータベースクエリを実行するため、負荷が増加する可能性がある
3. **タイムアウト**: フロントエンドのタイムアウト設定（10秒）を考慮する必要がある

## 8. 代替案（タイムアウト問題を回避）

フロントエンドのタイムアウト（10秒）を考慮し、以下の代替案も検討できます：

1. **非同期ポーリング**: フロントエンドで定期的にFAQ一覧を取得し、期待値と一致するまでリトライ
2. **WebSocket**: バックグラウンド処理が完了したら、WebSocketで通知
3. **ステータスAPI**: バックグラウンド処理の進行状況を返すAPIを追加

ただし、これらの代替案は実装が複雑になるため、まずは修正案2を実装し、問題が解決するか確認することを推奨します。


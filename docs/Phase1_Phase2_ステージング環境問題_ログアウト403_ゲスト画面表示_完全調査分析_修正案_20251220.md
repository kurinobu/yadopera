# ステージング環境問題 完全調査分析・修正案

**作成日時**: 2025年12月20日 13時37分  
**目的**: ステージング環境でのログアウト403エラーとゲスト画面「やどぺら」表示継続の問題を調査分析し、大原則に準拠した修正案を提示  
**状態**: 📋 **調査分析完了 - 修正案提示準備完了**

---

## 1. 問題の概要

### 1.1 報告された問題

1. **管理者ダッシュボードでログアウトできない**
   - ログアウトボタンをクリックしてもログアウトできない
   - サーバーログ: `POST /api/v1/auth/logout 403 Forbidden`（2回目のリクエスト）

2. **ゲスト画面で「やどぺら」表示が継続**
   - 強制リロードしても「やどぺら」が表示される
   - 期待する「YadOPERA」表示にならない

### 1.2 サーバーログ分析

```
[OPTIONS] POST /api/v1/auth/logout HTTP/1.1" 200 OK
[POST] POST /api/v1/auth/logout HTTP/1.1" 200 OK  (1回目)
[POST] POST /api/v1/auth/logout HTTP/1.1" 403 Forbidden  (2回目)
```

**観察**:
- 1回目のPOSTリクエストは200 OK
- 2回目のPOSTリクエストが403 Forbidden
- フロントエンドが複数回ログアウトAPIを呼び出している可能性

---

## 2. ログアウト403エラーの原因分析

### 2.1 バックエンド実装の確認

**`backend/app/api/v1/auth.py` (52-71行目)**:
```python
@router.post("/logout", response_model=LogoutResponse)
async def logout(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    ログアウト
    
    JWTトークンはクライアント側で削除
    認証が必要だが、403エラーが発生した場合でもログアウト処理は成功として扱う
    """
    try:
        await AuthService.logout(db, current_user)
        return LogoutResponse(message="Logged out successfully")
    except HTTPException as e:
        # 403エラー（非アクティブユーザーなど）が発生した場合でも、ログアウト処理は成功として扱う
        if e.status_code == status.HTTP_403_FORBIDDEN:
            return LogoutResponse(message="Logged out successfully")
        raise
```

**`backend/app/api/deps.py` (78-82行目)**:
```python
if not user.is_active:
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="Inactive user",
    )
```

### 2.2 問題の根本原因

**原因1: ログアウト処理の二重実行**

フロントエンドの実装を確認すると：

1. **`frontend/src/composables/useAuth.ts` (29-38行目)**:
   ```typescript
   async function logout() {
     try {
       await authApi.logout()  // 1回目のAPI呼び出し（200 OK）
       authStore.logout()      // トークン削除
       await router.push('/admin/login')
     } catch (error) {
       // エラーが発生してもログアウト処理は実行
       authStore.logout()      // トークン削除
       await router.push('/admin/login')
     }
   }
   ```

2. **`frontend/src/api/axios.ts` (56-61行目)**:
   ```typescript
   // 403 Forbidden: 認証は成功したが、アクセス権限がない（非アクティブユーザーなど）
   // ログアウトAPIの403エラーの場合は無限ループを防ぐため、ログアウト処理を実行しない
   if (status === 403 && !url.includes('/auth/logout')) {
     // 認証エラー（非アクティブユーザーなど）の場合、ログアウト処理を実行
     authStore.logout()
   }
   ```

**問題の流れ**:
1. ユーザーがログアウトボタンをクリック
2. `useAuth.logout()`が実行され、`authApi.logout()`を呼び出し（1回目: 200 OK）
3. 1回目のリクエストでトークンがまだ有効なため、正常にログアウト処理が完了
4. しかし、何らかの理由で2回目のリクエストが発生
5. 2回目のリクエスト時、既にトークンが削除されているか、または非アクティブユーザーとして判定される
6. `get_current_user`が403 Forbiddenを返す
7. バックエンドの`logout`エンドポイントは403エラーをキャッチして200 OKを返そうとするが、`get_current_user`の依存性注入の段階で403が発生するため、エンドポイントに到達しない

**根本原因**: 
- `get_current_user`依存性注入の段階で403エラーが発生すると、エンドポイント関数に到達する前に例外が発生する
- そのため、`logout`エンドポイント内の`try-except`で403エラーをキャッチできない

### 2.3 フロントエンドの二重リクエストの可能性

**考えられる原因**:
1. ログアウトボタンが複数回クリックされている
2. イベントハンドラーが複数回登録されている
3. ログアウト処理中に別のコンポーネントからもログアウトが呼び出されている

---

## 3. ゲスト画面「やどぺら」表示継続の原因分析

### 3.1 フロントエンドコードの確認

**`frontend/src/views/guest/LanguageSelect.vue` (7行目)**:
```vue
<h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">
  YadOPERA
</h1>
```

**確認結果**: ソースコードは既に「YadOPERA」に修正されている

### 3.2 問題の根本原因

**原因1: Service Workerのキャッシュ**

**`frontend/vite.config.ts` (11-36行目)**:
```typescript
VitePWA({
  registerType: 'autoUpdate',
  workbox: {
    globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
    navigateFallback: '/index.html',
    navigateFallbackDenylist: [/^\/api\//],
    runtimeCaching: [...]
  }
})
```

**問題**:
- Service Workerが古いビルドファイル（「やどぺら」を含む）をキャッシュしている
- `registerType: 'autoUpdate'`が設定されているが、ブラウザが古いService Workerを保持している可能性
- 強制リロードしても、Service Workerが古いキャッシュを配信している

**原因2: ステージング環境のビルドが最新でない**

- ステージング環境に最新のビルドがデプロイされていない可能性
- Render.comのビルドキャッシュが古い可能性

**原因3: 404エラーによるJavaScriptファイル読み込み失敗**

画像の説明から：
- `Login-DpMtxbKy.js`: 404 Not Found
- `Button-Bm4k1ixL.js`: 404 Not Found
- `Input-BaBC9ckS.js`: 404 Not Found

**問題**:
- ビルド後のJavaScriptファイル名が変更されているが、Service Workerが古いファイル名を参照している
- または、ビルドが不完全で、一部のファイルが生成されていない

---

## 4. 修正案（大原則準拠）

### 4.1 ログアウト403エラーの修正案

#### 修正案1: ログアウトエンドポイントを認証不要にする（推奨）

**理由**: 
- ログアウトはクライアント側でトークンを削除するだけの処理
- サーバー側での認証は不要（JWTはステートレス）
- 403エラーが発生してもログアウト処理を成功させる必要がある

**実装**:
```python
@router.post("/logout", response_model=LogoutResponse)
async def logout(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security_optional),
    db: AsyncSession = Depends(get_db)
):
    """
    ログアウト
    
    JWTトークンはクライアント側で削除
    認証はオプション（トークンが無効でもログアウト処理は成功）
    """
    # トークンが提供されている場合は検証するが、エラーが発生してもログアウト処理は成功
    try:
        if credentials:
            token = credentials.credentials
            payload = decode_token(token)
            if payload:
                user_id = int(payload.get("sub"))
                result = await db.execute(select(User).where(User.id == user_id))
                user = result.scalar_one_or_none()
                if user:
                    await AuthService.logout(db, user)
    except Exception:
        # エラーが発生してもログアウト処理は成功として扱う
        pass
    
    return LogoutResponse(message="Logged out successfully")
```

**必要な追加実装**:
- `security_optional`依存性の作成（トークンが提供されていない場合も許可）

#### 修正案2: フロントエンドでログアウト処理を改善（補完的）

**理由**: 
- ログアウト処理の二重実行を防ぐ
- エラーハンドリングを改善

**実装**:
```typescript
// frontend/src/composables/useAuth.ts
async function logout() {
  // ログアウト処理中フラグを設定（二重実行を防ぐ）
  if (isLoggingOut.value) {
    return
  }
  isLoggingOut.value = true
  
  try {
    // トークンが存在する場合のみAPIを呼び出し
    if (authStore.token) {
      try {
        await authApi.logout()
      } catch (error) {
        // 403エラーなどが発生してもログアウト処理は続行
        console.warn('Logout API error (ignored):', error)
      }
    }
    
    // クライアント側でトークンを削除
    authStore.logout()
    await router.push('/admin/login')
  } finally {
    isLoggingOut.value = false
  }
}
```

### 4.2 ゲスト画面「やどぺら」表示継続の修正案

#### 修正案1: Service Workerのキャッシュクリア（即座の対応）

**手順**:
1. ブラウザの開発者ツールでService Workerをアンインストール
2. ブラウザキャッシュをクリア
3. 強制リロード

**ただし、これは根本解決ではない**

#### 修正案2: Service Workerのバージョン管理改善（根本解決）

**理由**: 
- Service Workerのバージョンが更新されないと、古いキャッシュが残る
- ビルドごとにService Workerのバージョンを更新する必要がある

**実装**:
```typescript
// frontend/vite.config.ts
VitePWA({
  registerType: 'autoUpdate',
  workbox: {
    globPatterns: ['**/*.{js,css,html,ico,png,svg}'],
    navigateFallback: '/index.html',
    navigateFallbackDenylist: [/^\/api\//],
    // Service Workerのバージョンをビルドごとに更新
    skipWaiting: true,
    clientsClaim: true,
    runtimeCaching: [...]
  }
})
```

#### 修正案3: ステージング環境の再ビルド・再デプロイ（必須）

**手順**:
1. Render.comでフロントエンドの再ビルドを実行
2. ビルドキャッシュをクリア
3. 最新のコミット（`e7f4842`）がデプロイされていることを確認

---

## 5. 修正案の優先順位

### 最優先（即座に対応）

1. **ログアウト403エラーの修正**:
   - 修正案1: ログアウトエンドポイントを認証不要にする（根本解決）
   - 修正案2: フロントエンドで二重実行を防ぐ（補完的）

2. **ステージング環境の再ビルド・再デプロイ**:
   - Render.comでフロントエンドの再ビルドを実行
   - ビルドキャッシュをクリア

### 次優先（根本解決）

3. **Service Workerのバージョン管理改善**:
   - `skipWaiting: true`と`clientsClaim: true`を追加
   - ビルドごとにService Workerが更新されるようにする

---

## 6. 修正案の詳細実装

### 6.1 ログアウトエンドポイントの修正（バックエンド）

**ファイル**: `backend/app/api/v1/auth.py`

**修正内容**:
1. 認証をオプションにする
2. トークンが無効でもログアウト処理を成功させる

**必要な追加ファイル**: `backend/app/api/deps.py`に`get_optional_user`関数を追加

### 6.2 フロントエンドのログアウト処理改善

**ファイル**: `frontend/src/composables/useAuth.ts`

**修正内容**:
1. ログアウト処理中のフラグを追加（二重実行を防ぐ）
2. エラーハンドリングを改善

### 6.3 Service Worker設定の改善

**ファイル**: `frontend/vite.config.ts`

**修正内容**:
1. `skipWaiting: true`を追加
2. `clientsClaim: true`を追加

---

## 7. 修正後の確認項目

1. ✅ ログアウトが正常に動作する（403エラーが発生しない）
2. ✅ ゲスト画面で「YadOPERA」が表示される
3. ✅ Service Workerが最新バージョンに更新される
4. ✅ 404エラーが発生しない（JavaScriptファイルが正常に読み込まれる）

---

## 8. 結論

### 問題の根本原因

1. **ログアウト403エラー**: 
   - `get_current_user`依存性注入の段階で403エラーが発生し、エンドポイント関数に到達しない
   - ログアウト処理の二重実行の可能性

2. **ゲスト画面「やどぺら」表示継続**:
   - Service Workerのキャッシュが古い
   - ステージング環境のビルドが最新でない可能性
   - 404エラーによるJavaScriptファイル読み込み失敗

### 推奨される修正順序

1. **即座**: ログアウトエンドポイントを認証不要にする（修正案1）
2. **即座**: ステージング環境の再ビルド・再デプロイ
3. **次**: フロントエンドのログアウト処理改善（修正案2）
4. **次**: Service Worker設定の改善（修正案3）

---

**Document Version**: v1.0  
**Author**: AI Assistant  
**Status**: 📋 **調査分析完了 - 修正案提示準備完了**

# Phase 1 認証エラー完全調査分析・修正案

**作成日**: 2025年12月1日  
**対象**: 認証エラー（401 Unauthorized）の完全調査  
**目的**: 17テストが失敗している認証エラーの根本原因を特定し、修正案を立案

---

## 1. 問題の概要

### 1.1 エラー内容

**エラーメッセージ**:
```
assert 401 != 401
+ where 401 = <Response [401 Unauthorized]>.status_code
+ and   401 = status.HTTP_401_UNAUTHORIZED
```

**発生箇所**: 17テストでエラーが発生

**失敗したテスト**:
1. `test_auth.py::TestLogin::test_login_invalid_email`
2. `test_auth.py::TestLogin::test_login_invalid_password`
3. `test_auth.py::TestLogout::test_logout_success`
4. `test_session_token.py::TestSessionTokenVerify::test_verify_token_success`
5. `test_session_token.py::TestSessionTokenVerify::test_verify_token_expired`
6. `test_session_token.py::TestSessionLink::test_link_session_success`
7. `test_session_token.py::TestSessionLink::test_link_session_invalid_token`
8. `test_session_token.py::TestSessionLink::test_link_session_expired_token`
9. `test_session_token.py::TestSessionLink::test_link_session_wrong_facility`
10. `test_integration.py::TestAuthFlow::test_login_and_access_protected_endpoint`
11. `test_integration.py::TestAdminFlow::test_dashboard_access`
12. `test_integration.py::TestAdminFlow::test_faq_list_access`
13. `test_integration.py::TestAdminFlow::test_faq_create_flow`
14. `test_integration.py::TestAdminFlow::test_faq_suggestions_access`
15. `test_integration.py::TestAdminFlow::test_overnight_queue_access`
16. `test_integration.py::TestAdminFlow::test_qr_code_generation_access`
17. `test_integration.py::TestErrorHandling::test_invalid_json`

---

## 2. 調査結果

### 2.1 トークン生成の確認

**トークン生成コード** (`app/services/auth_service.py:91-92`):
```python
access_token = create_access_token(
    data={"sub": user.id, "email": user.email}
)
```

**問題**: `user.id`は整数（例: `39`）ですが、JWT仕様では`sub`（subject）フィールドは文字列であるべきです。

### 2.2 トークンデコードの確認

**トークンデコードテスト結果**:
```python
❌ トークンデコード失敗: Subject must be a string.
```

**原因**: `jose`ライブラリは、JWTの`sub`フィールドを文字列として期待しています。これはJWT仕様（RFC 7519）に準拠しています。

### 2.3 アーキテクチャ設計書の確認

**アーキテクチャ設計書の記載** (`docs/Architecture/やどぺら_v0.3_アーキテクチャ設計書.md:4300`):
```python
payload = {
    "sub": str(user.id),  # ← 文字列に変換
    "email": user.email,
    "facility_id": user.facility_id,
    "role": user.role,
    "exp": datetime.utcnow() + timedelta(minutes=10080),
    "iat": datetime.utcnow(),
    "type": "access"
}
```

**問題**: 実装がアーキテクチャ設計書と一致していません。

### 2.4 トークン検証の確認

**トークン検証コード** (`app/api/deps.py:48`):
```python
user_id: Optional[int] = payload.get("sub")
```

**問題**: `sub`が文字列として返される場合、整数への変換が必要です。

---

## 3. 根本原因の特定

### 3.1 原因1: JWTの`sub`フィールドの型不一致

**問題の本質**:
- JWT仕様（RFC 7519）では、`sub`（subject）フィールドは文字列であるべきです
- `jose`ライブラリは、この仕様に準拠して`sub`を文字列として期待しています
- 現在の実装では、`user.id`（整数）を直接`sub`に設定しているため、トークンのデコード時にエラーが発生します

**エラーの発生フロー**:
```
1. ログインAPIが`create_access_token({"sub": user.id, ...})`を呼び出す
2. `user.id`は整数（例: 39）
3. JWTトークンが生成される（`sub`は整数としてエンコードされる）
4. 認証ミドルウェアが`decode_token(token)`を呼び出す
5. `jose`ライブラリが`sub`を文字列として期待するが、整数が返される
6. → `Subject must be a string.`エラーが発生
7. → `decode_token`が`None`を返す
8. → `get_current_user`が401エラーを返す
```

**証拠**:
- トークンデコードテストで`Subject must be a string.`エラーが確認される
- アーキテクチャ設計書では`str(user.id)`と文字列変換が推奨されている
- 実装がアーキテクチャ設計書と一致していない

### 3.2 原因2: トークン検証時の型変換不足

**問題の本質**:
- `app/api/deps.py`の`get_current_user`関数で、`payload.get("sub")`を直接整数として扱っている
- `sub`が文字列として返される場合、整数への変換が必要です

**証拠**:
- `app/api/deps.py:48`で`user_id: Optional[int] = payload.get("sub")`と定義されている
- 文字列が返される場合、型変換が必要

---

## 4. 大原則に基づく修正案の立案

### 4.1 大原則の確認

**実装や修正の基本原則**:
1. **根本解決 > 暫定解決**: 一時的な対処よりも根本的な解決を優先
2. **シンプル構造 > 複雑構造**: 複雑な実装よりもシンプルで理解しやすい構造を優先
3. **統一・同一化 > 特殊独自**: 特殊な実装よりも統一されたパターンを優先
4. **具体的 > 一般**: 抽象的な実装よりも具体的で明確な実装を優先
5. **拙速 < 安全確実**: MVPアプローチと安全性のバランスを取る。安全を確保しながら迅速に進める

**準拠基準**:
- 要約定義書・アーキテクチャ設計書を準拠
- 方向性: 根本解決 > 暫定解決、シンプル構造 > 複雑構造、統一・同一化 > 特殊独自、具体的 > 一般、拙速 < 安全確実

### 4.2 修正案の評価

#### 修正案1: JWTの`sub`フィールドを文字列に変換（根本解決・推奨）

**内容**:
- `app/services/auth_service.py`で、`user.id`を文字列に変換してから`sub`に設定
- `app/api/deps.py`で、`sub`を文字列から整数に変換してから使用
- アーキテクチャ設計書に準拠

**実装方法**:

**修正1: `app/services/auth_service.py`**:
```python
# 修正前
access_token = create_access_token(
    data={"sub": user.id, "email": user.email}
)

# 修正後
access_token = create_access_token(
    data={"sub": str(user.id), "email": user.email}
)
```

**修正2: `app/api/deps.py`**:
```python
# 修正前
user_id: Optional[int] = payload.get("sub")

# 修正後
sub_value = payload.get("sub")
if sub_value is None:
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

# 文字列から整数に変換
try:
    user_id = int(sub_value)
except (ValueError, TypeError):
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
```

**大原則評価**:
- ✅ **根本解決**: JWT仕様に準拠し、根本的な解決
- ✅ **シンプル構造**: シンプルな型変換のみ
- ✅ **統一・同一化**: アーキテクチャ設計書と一致
- ✅ **具体的**: 明確な実装
- ✅ **安全確実**: JWT仕様に準拠し、安全

**メリット**:
- JWT仕様（RFC 7519）に準拠
- アーキテクチャ設計書と一致
- 根本的な解決
- シンプルで理解しやすい

**デメリット**:
- なし（型変換のみで、パフォーマンスへの影響は最小限）

**影響範囲**:
- `app/services/auth_service.py`: 1箇所修正
- `app/api/deps.py`: 1箇所修正
- テストコード: 変更不要

**実装時間**: 約15分

---

## 5. 修正案の詳細

### 5.1 修正案1の実装詳細

#### ステップ1: `app/services/auth_service.py`の修正

**修正箇所**: `app/services/auth_service.py:91-92`

**修正内容**:
```python
# 修正前
access_token = create_access_token(
    data={"sub": user.id, "email": user.email}
)

# 修正後
access_token = create_access_token(
    data={"sub": str(user.id), "email": user.email}
)
```

**理由**:
- JWT仕様（RFC 7519）に準拠
- アーキテクチャ設計書と一致
- `jose`ライブラリの期待に合致

#### ステップ2: `app/api/deps.py`の修正

**修正箇所**: `app/api/deps.py:47-54`

**修正内容**:
```python
# 修正前
# ユーザーID取得
user_id: Optional[int] = payload.get("sub")
if user_id is None:
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

# 修正後
# ユーザーID取得
sub_value = payload.get("sub")
if sub_value is None:
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

# 文字列から整数に変換（JWT仕様に準拠）
try:
    user_id = int(sub_value)
except (ValueError, TypeError):
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
```

**理由**:
- `sub`が文字列として返されるため、整数に変換が必要
- 型変換エラーを適切にハンドリング
- セキュリティを確保（無効な値の拒否）

---

## 6. 影響範囲の評価

### 6.1 影響を受けるファイル

**修正が必要なファイル**:
1. `app/services/auth_service.py` - 1箇所修正
2. `app/api/deps.py` - 1箇所修正

**影響を受けないファイル**:
- テストコード: 変更不要（既存のテストが正しく動作する）
- フロントエンド: 影響なし（APIのインターフェースは変更なし）
- データベース: 影響なし（スキーマ変更なし）
- 外部サービス: 影響なし

### 6.2 後方互換性

**後方互換性**:
- ✅ **完全に後方互換**: 既存のトークンは無効になるが、新しいトークンは正しく動作する
- ✅ **APIインターフェース**: 変更なし
- ✅ **テストコード**: 変更不要

**注意事項**:
- 既存のトークン（整数の`sub`を含む）は無効になる
- ユーザーは再ログインが必要（通常の運用では問題なし）

---

## 7. テスト計画

### 7.1 修正後のテスト項目

**必須テスト**:
1. ✅ ログインAPIが正しくトークンを生成するか
2. ✅ 認証ミドルウェアが正しくトークンを検証するか
3. ✅ 保護されたエンドポイントにアクセスできるか
4. ✅ 無効なトークンが拒否されるか
5. ✅ すべての既存テストがパスするか

**テスト実行コマンド**:
```bash
cd /Users/kurinobu/projects/yadopera/backend
export TEST_DATABASE_URL="postgresql+asyncpg://..."
export REDIS_URL="redis://..."
export USE_POSTGRES_TEST="true"
export USE_OPENAI_MOCK="true"
export SECRET_KEY="test-secret-key-for-staging-tests-minimum-32-characters-long"
export CORS_ORIGINS="http://localhost:5173"

pytest tests/test_auth.py tests/test_integration.py tests/test_session_token.py -v
```

---

## 8. 結論

### 8.1 根本原因

**根本原因**: JWTの`sub`フィールドが整数として設定されているが、JWT仕様では文字列であるべき。`jose`ライブラリが文字列を期待しているため、トークンのデコード時にエラーが発生。

### 8.2 推奨修正案

**修正案1: JWTの`sub`フィールドを文字列に変換（根本解決・推奨）**

**理由**:
- JWT仕様（RFC 7519）に準拠
- アーキテクチャ設計書と一致
- 根本的な解決
- シンプルで理解しやすい
- 安全確実

**実装時間**: 約15分

**影響範囲**: 最小限（2ファイル、2箇所の修正）

### 8.3 次のステップ

1. **修正案1の実装**: `app/services/auth_service.py`と`app/api/deps.py`を修正
2. **テスト実行**: すべてのテストがパスすることを確認
3. **ドキュメント更新**: 修正内容を記録

---

**Document Version**: v1.0  
**Author**: Auto (AI Assistant)  
**Last Updated**: 2025-12-01  
**Status**: ✅ 調査完了、修正案確定



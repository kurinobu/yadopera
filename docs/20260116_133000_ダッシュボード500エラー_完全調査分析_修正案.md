# ダッシュボード500エラー - 完全調査分析・修正案

**作成日時**: 2026年1月16日 13:30:00  
**目的**: ダッシュボードAPIが500エラーを返す問題の完全調査分析と修正案  
**状態**: 原因調査中

---

## 1. 問題の説明

### 1.1 報告された問題

- **症状1**: 「未解決の質問」をタップするとエラーが発生
- **症状2**: 「ダッシュボードに戻る」をタップすると「ダッシュボードデータの取得に失敗しました」とエラー
- **症状3**: 再試行してもダッシュボードに戻れない
- **サーバーログ**: `GET /api/v1/admin/dashboard` → 500 Internal Server Error

### 1.2 重大性

- **ビジネス破綻レベルの危機**: PoCが始められない
- **スケジュール変更の可能性**: 重大危機

---

## 2. 原因の完全調査分析

### 2.1 サーバーログの分析

**ログ内容**:
```
[GET] /api/v1/admin/dashboard?_t=1768541737033
INFO: ... "GET /api/v1/admin/dashboard?_t=1768541737033 HTTP/1.1" 500 Internal Server Error
```

**問題点**:
- ダッシュボードAPIが500エラーを返している
- エラーの詳細がログに表示されていない

---

### 2.2 修正履歴の確認

**最近の修正**:
1. `UnresolvedEscalation`スキーマに`session_id`を追加（コミット: `0e95cee`）
2. `get_unresolved_escalations`で`session_id`を取得して返すように修正

**問題の可能性**:
1. `escalation.conversation`が`None`の場合、`escalation.conversation.session_id`でエラーが発生
2. `selectinload`で`conversation`をロードしているが、何らかの理由でロードに失敗している
3. `session_id`が空文字列の場合、スキーマのバリデーションでエラーが発生

---

### 2.3 コードの確認

#### `dashboard_service.py`の`get_unresolved_escalations`メソッド

```python
async def get_unresolved_escalations(self, facility_id: int, limit: int = 10) -> List[UnresolvedEscalation]:
    # 未解決エスカレーションを取得
    escalations_result = await self.db.execute(
        select(Escalation)
        .join(Conversation, Escalation.conversation_id == Conversation.id)
        .where(
            Conversation.facility_id == facility_id,
            Escalation.resolved_at.is_(None)
        )
        .order_by(Escalation.created_at.desc())
        .limit(limit)
        .options(selectinload(Escalation.conversation).selectinload(Conversation.messages))
    )
    escalations = escalations_result.scalars().all()
    
    unresolved_list: List[UnresolvedEscalation] = []
    for escalation in escalations:
        # ゲストメッセージを取得（最初のユーザーメッセージ）
        message = ""
        if escalation.conversation and escalation.conversation.messages:
            user_messages = [m for m in escalation.conversation.messages if m.role == MessageRole.USER.value]
            if user_messages:
                message = user_messages[0].content[:200]  # 200文字まで
        
        # session_idを取得
        session_id = ""
        if escalation.conversation:
            session_id = escalation.conversation.session_id  # ← 問題の可能性
        
        unresolved_list.append(UnresolvedEscalation(
            id=escalation.id,
            conversation_id=escalation.conversation_id,
            session_id=session_id,  # ← 空文字列の場合、スキーマのバリデーションでエラー？
            created_at=escalation.created_at,
            message=message
        ))
    
    return unresolved_list
```

**問題点**:
1. `escalation.conversation`が`None`の場合、`session_id`が空文字列になる
2. `UnresolvedEscalation`スキーマで`session_id: str = Field(..., description="セッションID")`としているが、空文字列が許可されているか不明
3. `selectinload`で`conversation`をロードしているが、`JOIN`で既に結合しているため、`conversation`が`None`になることは通常ない

---

### 2.4 根本原因の推定

#### 根本原因1: `session_id`が空文字列の場合のスキーマバリデーションエラー

**問題**:
- `UnresolvedEscalation`スキーマで`session_id: str = Field(..., description="セッションID")`としている
- `Field(...)`は必須フィールドを意味するが、空文字列は許可されている
- しかし、何らかの理由で`session_id`が取得できない場合、エラーが発生する可能性

---

#### 根本原因2: `selectinload`と`JOIN`の競合

**問題**:
- `select(Escalation).join(Conversation, ...)`で既に`JOIN`している
- さらに`.options(selectinload(Escalation.conversation))`で`selectinload`を使用している
- これにより、予期しない動作が発生する可能性

---

#### 根本原因3: `conversation`が`None`の場合のエラー

**問題**:
- `escalation.conversation`が`None`の場合、`escalation.conversation.session_id`でエラーが発生
- コードでは`if escalation.conversation:`でチェックしているが、何らかの理由で`None`になる可能性

---

## 3. 修正案

### 3.1 修正案1: `session_id`の取得を安全にする（推奨）

**方針**: `session_id`の取得を安全にし、`None`チェックを追加

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   unresolved_list: List[UnresolvedEscalation] = []
   for escalation in escalations:
       # ゲストメッセージを取得（最初のユーザーメッセージ）
       message = ""
       if escalation.conversation and escalation.conversation.messages:
           user_messages = [m for m in escalation.conversation.messages if m.role == MessageRole.USER.value]
           if user_messages:
               message = user_messages[0].content[:200]  # 200文字まで
       
       # session_idを取得（安全に）
       session_id = ""
       if escalation.conversation and escalation.conversation.session_id:
           session_id = escalation.conversation.session_id
       else:
           # conversationが存在しない、またはsession_idがNoneの場合は空文字列
           logger.warning(f"Conversation or session_id not found for escalation {escalation.id}")
           session_id = ""
       
       unresolved_list.append(UnresolvedEscalation(
           id=escalation.id,
           conversation_id=escalation.conversation_id,
           session_id=session_id,
           created_at=escalation.created_at,
           message=message
       ))
   ```

**メリット**:
- ✅ エラーが発生しない
- ✅ 安全に`session_id`を取得できる

**デメリット**:
- ⚠️ `session_id`が空文字列の場合、会話詳細ページに遷移できない（これは別の問題）

---

### 3.2 修正案2: `selectinload`を削除して`JOIN`のみを使用（推奨）

**方針**: `selectinload`と`JOIN`の競合を避けるため、`selectinload`を削除

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   # 未解決エスカレーションを取得
   escalations_result = await self.db.execute(
       select(Escalation)
       .join(Conversation, Escalation.conversation_id == Conversation.id)
       .where(
           Conversation.facility_id == facility_id,
           Escalation.resolved_at.is_(None)
       )
       .order_by(Escalation.created_at.desc())
       .limit(limit)
       .options(selectinload(Escalation.conversation).selectinload(Conversation.messages))  # ← 削除
   )
   ```

   または、`JOIN`で既に結合しているため、`conversation`は直接アクセス可能：

   ```python
   # 未解決エスカレーションを取得（JOINでconversationを結合）
   escalations_result = await self.db.execute(
       select(Escalation, Conversation)
       .join(Conversation, Escalation.conversation_id == Conversation.id)
       .where(
           Conversation.facility_id == facility_id,
           Escalation.resolved_at.is_(None)
       )
       .order_by(Escalation.created_at.desc())
       .limit(limit)
       .options(selectinload(Conversation.messages))  # messagesのみselectinload
   )
   escalations = escalations_result.all()
   
   unresolved_list: List[UnresolvedEscalation] = []
   for row in escalations:
       escalation = row[0]  # Escalation
       conversation = row[1]  # Conversation
       
       # ゲストメッセージを取得
       message = ""
       if conversation.messages:
           user_messages = [m for m in conversation.messages if m.role == MessageRole.USER.value]
           if user_messages:
               message = user_messages[0].content[:200]
       
       unresolved_list.append(UnresolvedEscalation(
           id=escalation.id,
           conversation_id=escalation.conversation_id,
           session_id=conversation.session_id or "",  # ← 安全に
           created_at=escalation.created_at,
           message=message
       ))
   ```

**メリット**:
- ✅ `JOIN`と`selectinload`の競合を避けられる
- ✅ より明確なコード

**デメリット**:
- ⚠️ コードの変更が大きい

---

### 3.3 修正案3: エラーハンドリングを追加（補完的）

**方針**: `get_unresolved_escalations`でエラーが発生した場合、空のリストを返す

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   async def get_unresolved_escalations(self, facility_id: int, limit: int = 10) -> List[UnresolvedEscalation]:
       try:
           # 未解決エスカレーションを取得
           # ...
       except Exception as e:
           logger.error(f"Error getting unresolved escalations: {e}", exc_info=True)
           return []  # エラー時は空のリストを返す
   ```

**メリット**:
- ✅ ダッシュボードAPIが500エラーを返さない
- ✅ エラーが発生してもダッシュボードは表示される

**デメリット**:
- ⚠️ 根本原因を解決していない

---

## 4. 推奨される修正手順

### 4.1 優先順位

1. **最優先**: 修正案1（`session_id`の取得を安全にする）+ 修正案3（エラーハンドリングを追加）
   - 即座に500エラーを解決
   - ダッシュボードが表示されるようになる

2. **次優先**: 修正案2（`selectinload`を削除して`JOIN`のみを使用）
   - 根本解決
   - コードの改善

---

### 4.2 実装手順

1. **修正案1と修正案3を実装**
   - `dashboard_service.py`を修正
   - `session_id`の取得を安全にする
   - エラーハンドリングを追加
   - コミット・プッシュ

2. **動作確認**
   - ダッシュボードが表示されることを確認
   - 未解決エスカレーションリストが表示されることを確認

3. **修正案2を実装（必要に応じて）**
   - `selectinload`を削除
   - `JOIN`のみを使用

---

## 5. 結論

### 5.1 根本原因

**根本原因**: 
1. `get_unresolved_escalations`で`session_id`を取得する際にエラーが発生している可能性
2. `selectinload`と`JOIN`の競合
3. エラーハンドリングが不足している

### 5.2 修正案

**最優先**: 修正案1（`session_id`の取得を安全にする）+ 修正案3（エラーハンドリングを追加）

**期待される結果**: 
- ダッシュボードAPIが500エラーを返さない
- ダッシュボードが表示される
- 未解決エスカレーションリストが表示される

---

**Document Version**: v1.0  
**Author**: Auto (AI Assistant)  
**Last Updated**: 2026年1月16日 13:30:00  
**Status**: 原因調査中、修正案準備完了


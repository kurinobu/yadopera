# 月次統計の期間ロジックとStripe統合の整合性問題 - 調査分析・修正ステップ計画

**作成日時**: 2026年1月17日  
**目的**: 月次統計の期間ロジックをカレンダー月ベースから契約開始日ベースの請求期間に変更し、Stripe統合との整合性を確保する  
**優先度**: 高（Stripe統合前に解決必須）

---

## 1. 問題の概要

### 1.1 現状の問題点

**現在の実装**:
- 月次統計は**カレンダー月**（毎月1日 00:00:00 〜 月末 23:59:59 JST）で集計している
- `plan_started_at`フィールドは存在するが、**未使用**の状態
- Stripeの請求期間は**契約開始日から1ヶ月間**であるため、整合性が取れない

**影響範囲**:
- `get_monthly_usage`メソッド（今月の質問数）
- `get_ai_automation`メソッド（今月のAI自動応答数）
- `get_escalations_summary`メソッド（今月のエスカレーション数）
- フロントエンドの表示ラベル（「今月の質問数」など）

### 1.2 修正の必要性

**Stripe統合を見据えた設計変更が必要**:
- Stripeの請求期間は契約開始日から1ヶ月間（例: 2026-01-15 10:00:00 〜 2026-02-15 09:59:59）
- ダッシュボードの統計期間とStripeの請求期間を一致させる必要がある
- プラン変更時も、新しいプランの開始日から請求期間を計算する必要がある

---

## 2. 現状の実装詳細

### 2.1 バックエンド実装

**ファイル**: `backend/app/services/dashboard_service.py`

**現在の実装（カレンダー月ベース）**:

```388:423:backend/app/services/dashboard_service.py
    async def get_monthly_usage(self, facility_id: int) -> Optional[MonthlyUsageResponse]:
        """
        今月の質問数/プラン上限を取得
        
        Args:
            facility_id: 施設ID
        
        Returns:
            MonthlyUsageResponse: 月次利用状況（エラー時はNone）
        """
        try:
            # 施設情報を取得
            facility_result = await self.db.execute(
                select(Facility).where(Facility.id == facility_id)
            )
            facility = facility_result.scalar_one_or_none()
            if not facility:
                logger.warning(f"Facility not found: {facility_id}")
                return None  # ValueErrorではなくNoneを返す
            
            # JSTタイムゾーン取得
            jst = pytz.timezone('Asia/Tokyo')
            
            # 今月の開始時刻（JST）
            now_jst = datetime.now(jst)
            month_start_jst = now_jst.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
            
            # 今月の終了時刻（JST）
            if month_start_jst.month == 12:
                month_end_jst = month_start_jst.replace(year=month_start_jst.year + 1, month=1) - timedelta(seconds=1)
            else:
                month_end_jst = month_start_jst.replace(month=month_start_jst.month + 1) - timedelta(seconds=1)
            
            # UTCに変換
            month_start_utc = month_start_jst.astimezone(pytz.UTC)
            month_end_utc = month_end_jst.astimezone(pytz.UTC)
```

**同様の実装が以下にも存在**:
- `get_ai_automation`（510-536行目）
- `get_escalations_summary`（612-638行目）

### 2.2 データベーススキーマ

**ファイル**: `backend/app/models/facility.py`

```37:38:backend/app/models/facility.py
    plan_started_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    plan_updated_at = Column(DateTime(timezone=True), nullable=True)
```

- `plan_started_at`: プラン開始日時（デフォルト: 現在時刻）
- `plan_updated_at`: プラン更新日時（nullable）

### 2.3 フロントエンド実装

**ファイル**: `frontend/src/views/admin/Dashboard.vue`

```32:37:frontend/src/views/admin/Dashboard.vue
          <h2 class="text-xl font-bold text-gray-900 dark:text-white">
            今月の利用状況
          </h2>
          <p class="mt-1 text-sm text-gray-500 dark:text-gray-400">
            月次統計とコスト情報
          </p>
```

**ファイル**: `frontend/src/components/admin/dashboard/MonthlyUsageCard.vue`

```4:6:frontend/src/components/admin/dashboard/MonthlyUsageCard.vue
      <h3 class="text-lg font-semibold text-gray-900 dark:text-white">
        今月の質問数
      </h3>
```

---

## 3. 修正方針

### 3.1 請求期間の計算ロジック

**契約開始日ベースの請求期間計算**:

1. **現在の請求期間を計算**:
   - `plan_started_at`を基準に、現在時刻が含まれる請求期間を計算
   - 請求期間は30日間（1ヶ月）
   - 例: `plan_started_at = 2026-01-15 10:00:00`の場合
     - 1回目の請求期間: 2026-01-15 10:00:00 〜 2026-02-15 09:59:59
     - 2回目の請求期間: 2026-02-15 10:00:00 〜 2026-03-15 09:59:59

2. **プラン変更時の処理**:
   - プラン変更時は`plan_started_at`を更新
   - `plan_updated_at`も更新
   - 新しいプランの開始日から請求期間を計算

3. **境界値の処理**:
   - 請求期間の開始時刻: `plan_started_at`の日時（時分秒を含む）
   - 請求期間の終了時刻: 開始時刻 + 30日 - 1秒

### 3.2 実装方針

**大原則に準拠**:
- **根本解決**: カレンダー月ベースから契約開始日ベースに変更（暫定解決ではない）
- **シンプル構造**: 既存のメソッド構造を維持し、期間計算ロジックのみ変更
- **統一・同一化**: すべての月次統計メソッドで同じ期間計算ロジックを使用
- **安全確実**: 既存のエラーハンドリングを維持、テストを実施

---

## 4. 修正ステップ計画

### ステップ1: 設計書の更新（30分）

**目的**: 設計書を更新し、カレンダー月ベースから契約開始日ベースの請求期間に変更

**実施内容**:
1. `docs/monthly_dashboard_arch.md`を更新
   - 月次集計期間の説明を変更
   - 請求期間の計算ロジックを追加
   - Stripe統合を見据えた設計に更新

**更新箇所**:
- セクション1.2「質問数カウント定義」の「月次集計期間」を更新
- 請求期間の計算ロジックを追加

**期待される結果**:
- 設計書が契約開始日ベースの請求期間を反映している

---

### ステップ2: 請求期間計算ユーティリティ関数の作成（30分）

**目的**: 請求期間を計算する共通関数を作成し、コードの重複を避ける

**実施内容**:
1. `backend/app/utils/billing_period.py`を新規作成
   - `calculate_billing_period`関数を実装
   - 契約開始日から現在時刻が含まれる請求期間を計算

**実装例**:
```python
from datetime import datetime, timedelta
from typing import Tuple
import pytz

def calculate_billing_period(
    plan_started_at: datetime,
    now: datetime = None
) -> Tuple[datetime, datetime]:
    """
    契約開始日から現在時刻が含まれる請求期間を計算
    
    Args:
        plan_started_at: プラン開始日時（timezone-aware）
        now: 現在時刻（timezone-aware、デフォルト: 現在時刻JST）
    
    Returns:
        Tuple[datetime, datetime]: (請求期間開始時刻, 請求期間終了時刻)（timezone-aware）
    """
    if now is None:
        jst = pytz.timezone('Asia/Tokyo')
        now = datetime.now(jst)
    
    # plan_started_atがnaiveの場合はJSTとして扱う
    if plan_started_at.tzinfo is None:
        jst = pytz.timezone('Asia/Tokyo')
        plan_started_at = jst.localize(plan_started_at)
    
    # 現在時刻がプラン開始日より前の場合はエラー
    if now < plan_started_at:
        raise ValueError(f"Current time ({now}) is before plan start time ({plan_started_at})")
    
    # プラン開始日からの経過日数を計算
    elapsed = now - plan_started_at
    elapsed_days = elapsed.days
    
    # 何回目の請求期間かを計算（0回目、1回目、2回目...）
    billing_cycle = elapsed_days // 30
    
    # 現在の請求期間の開始時刻を計算
    billing_start = plan_started_at + timedelta(days=billing_cycle * 30)
    
    # 現在の請求期間の終了時刻を計算（開始時刻 + 30日 - 1秒）
    billing_end = billing_start + timedelta(days=30) - timedelta(seconds=1)
    
    return billing_start, billing_end
```

**テスト**:
- 境界値テスト（請求期間の開始日・終了日）
- 複数の請求期間にまたがるデータのテスト
- プラン変更時のテスト

**期待される結果**:
- 請求期間を計算する共通関数が作成され、テストがパスする

---

### ステップ3: Backend API修正（2-3時間）

**目的**: 月次統計メソッドを契約開始日ベースの請求期間で集計するように修正

**実施内容**:

#### 3.1 `get_monthly_usage`メソッドの修正

**ファイル**: `backend/app/services/dashboard_service.py`

**修正内容**:
1. カレンダー月ベースの期間計算を削除
2. `calculate_billing_period`を使用して請求期間を計算
3. 施設情報から`plan_started_at`を取得
4. 請求期間で質問数を集計

**修正例**:
```python
async def get_monthly_usage(self, facility_id: int) -> Optional[MonthlyUsageResponse]:
    """
    今月の質問数/プラン上限を取得（請求期間ベース）
    
    Args:
        facility_id: 施設ID
    
    Returns:
        MonthlyUsageResponse: 月次利用状況（エラー時はNone）
    """
    try:
        # 施設情報を取得
        facility_result = await self.db.execute(
            select(Facility).where(Facility.id == facility_id)
        )
        facility = facility_result.scalar_one_or_none()
        if not facility:
            logger.warning(f"Facility not found: {facility_id}")
            return None
        
        # JSTタイムゾーン取得
        jst = pytz.timezone('Asia/Tokyo')
        now_jst = datetime.now(jst)
        
        # plan_started_atを取得（timezone-awareに変換）
        plan_started_at = facility.plan_started_at
        if plan_started_at.tzinfo is None:
            # naive datetimeの場合はUTCとして扱い、JSTに変換
            plan_started_at = pytz.UTC.localize(plan_started_at).astimezone(jst)
        else:
            # timezone-awareの場合はJSTに変換
            plan_started_at = plan_started_at.astimezone(jst)
        
        # 請求期間を計算
        from app.utils.billing_period import calculate_billing_period
        billing_start_jst, billing_end_jst = calculate_billing_period(plan_started_at, now_jst)
        
        # UTCに変換
        billing_start_utc = billing_start_jst.astimezone(pytz.UTC)
        billing_end_utc = billing_end_jst.astimezone(pytz.UTC)
        
        # 請求期間の質問数を集計
        questions_result = await self.db.execute(
            select(func.count(Message.id))
            .join(Conversation, Message.conversation_id == Conversation.id)
            .where(
                Conversation.facility_id == facility_id,
                Message.role == MessageRole.USER.value,
                Message.created_at >= billing_start_utc,
                Message.created_at <= billing_end_utc
            )
        )
        current_billing_period_questions = questions_result.scalar() or 0
        
        # 以下、既存のロジック（プラン情報取得、使用率計算など）は変更なし
        # ...
```

#### 3.2 `get_ai_automation`メソッドの修正

**同様の修正を実施**:
- カレンダー月ベースの期間計算を削除
- `calculate_billing_period`を使用して請求期間を計算
- 請求期間でAI自動応答数を集計

#### 3.3 `get_escalations_summary`メソッドの修正

**同様の修正を実施**:
- カレンダー月ベースの期間計算を削除
- `calculate_billing_period`を使用して請求期間を計算
- 請求期間でエスカレーション数を集計

#### 3.4 `get_unresolved_escalations`メソッドの確認

**確認事項**:
- このメソッドは期間フィルタを使用していない（未解決のエスカレーションを取得するだけ）
- 修正不要だが、コメントを追加して「請求期間とは無関係」であることを明記

**バックアップ**:
- 修正前に`backend/app/services/dashboard_service.py`のバックアップを作成

**期待される結果**:
- すべての月次統計メソッドが契約開始日ベースの請求期間で集計される
- 既存のエラーハンドリングが維持される
- リンターエラーがない

---

### ステップ4: フロントエンド表示ラベルの調整（30分）

**目的**: 表示ラベルを「今月」から「今の請求期間」に変更（オプション）

**実施内容**:

#### 4.1 Dashboard.vueの修正

**ファイル**: `frontend/src/views/admin/Dashboard.vue`

**修正内容**:
- 「今月の利用状況」→「今の請求期間の利用状況」に変更（または「利用状況」のみ）
- 説明文を「月次統計とコスト情報」→「請求期間の統計とコスト情報」に変更

#### 4.2 MonthlyUsageCard.vueの修正

**ファイル**: `frontend/src/components/admin/dashboard/MonthlyUsageCard.vue`

**修正内容**:
- 「今月の質問数」→「請求期間の質問数」に変更（または「質問数」のみ）

**注意事項**:
- ユーザーにとって分かりやすい表現を選択
- 「今月」の方が分かりやすい場合は、そのまま維持しても良い（内部ロジックのみ変更）

**期待される結果**:
- 表示ラベルが適切に更新される（または維持される）

---

### ステップ5: テスト実装（1-2時間）

**目的**: 請求期間ベースの集計ロジックのテストを実装

**実施内容**:

#### 5.1 ユニットテストの作成

**ファイル**: `backend/tests/test_billing_period.py`（新規作成）

**テストケース**:
1. **請求期間の計算テスト**:
   - プラン開始日から1日目（1回目の請求期間内）
   - プラン開始日から30日目（1回目の請求期間の最終日）
   - プラン開始日から31日目（2回目の請求期間の開始日）
   - プラン開始日から60日目（2回目の請求期間の最終日）

2. **境界値テスト**:
   - 請求期間の開始時刻（00:00:00）
   - 請求期間の終了時刻（23:59:59）
   - プラン開始日が月末の場合

3. **エラーハンドリングテスト**:
   - 現在時刻がプラン開始日より前の場合

#### 5.2 統合テストの作成

**ファイル**: `backend/tests/test_dashboard_service_billing_period.py`（新規作成）

**テストケース**:
1. **get_monthly_usageのテスト**:
   - 請求期間内の質問数が正しく集計される
   - 請求期間外の質問数が集計されない
   - 複数の請求期間にまたがるデータのテスト

2. **get_ai_automationのテスト**:
   - 請求期間内のAI自動応答数が正しく集計される

3. **get_escalations_summaryのテスト**:
   - 請求期間内のエスカレーション数が正しく集計される

**期待される結果**:
- すべてのテストがパスする
- テストカバレッジが十分である

---

### ステップ6: ブラウザテスト（30分）

**目的**: 請求期間ベースの集計が正しく表示されることを確認

**実施内容**:
1. ダッシュボード画面にアクセス
2. 月次統計カードが正しく表示されることを確認
3. 請求期間内のデータが正しく集計されることを確認
4. 請求期間外のデータが集計されないことを確認

**テスト環境**:
- ローカルDocker環境
- ステージング環境（デプロイ後）

**期待される結果**:
- ダッシュボードが正常に表示される
- 請求期間ベースの集計が正しく動作する

---

## 5. 他の機能やUIへの影響調査

### 5.1 影響がない機能

**週次統計**:
- 過去7日間の集計のため、影響なし

**リアルタイム情報**:
- リアルタイムの情報表示のため、影響なし

**未解決エスカレーション**:
- 期間フィルタを使用していないため、影響なし（表示ラベルのみ確認）

### 5.2 影響がある可能性がある機能

**プラン変更機能**（将来実装予定）:
- プラン変更時は`plan_started_at`を更新する必要がある
- `plan_updated_at`も更新する必要がある
- プラン変更APIの実装時に注意が必要

**利用マニュアル**:
- 第3章「ダッシュボードの見方」で月次統計について説明している
- 請求期間ベースの説明に更新する必要がある（既に更新済みの可能性あり）

### 5.3 競合・干渉の可能性

**なし**: 
- 月次統計の期間ロジックのみを変更するため、他の機能への影響は最小限
- 既存のエラーハンドリングを維持するため、安全性は確保される

---

## 6. 実装時の注意事項

### 6.1 データ移行

**既存データの扱い**:
- 既存の`plan_started_at`はマイグレーション012で設定済み（デフォルト: 現在時刻）
- 既存データでも問題なく動作する

**プラン変更時の処理**:
- プラン変更時は`plan_started_at`を更新する必要がある
- プラン変更APIの実装時に注意が必要

### 6.2 タイムゾーン処理

**重要**:
- すべての統計は**日本時間（JST）**基準を維持
- `plan_started_at`がtimezone-awareでない場合は、JSTとして扱う
- データベースはUTC保存、取得時にJST変換

### 6.3 エラーハンドリング

**既存のエラーハンドリングを維持**:
- `get_monthly_usage`, `get_ai_automation`, `get_escalations_summary`は`Optional`を返す
- エラー時は`None`を返し、ダッシュボード全体が失敗しないようにする

### 6.4 パフォーマンス

**影響**:
- 請求期間の計算は軽量なため、パフォーマンスへの影響は最小限
- 既存のキャッシュ機能（5分TTL）を維持

---

## 7. 成功基準

### 7.1 機能要件

- ✅ 月次統計が契約開始日ベースの請求期間で集計される
- ✅ Stripe統合時に請求期間が一致する
- ✅ プラン変更時に新しいプランの開始日から請求期間を計算する
- ✅ 既存のエラーハンドリングが維持される

### 7.2 非機能要件

- ✅ すべてのテストがパスする
- ✅ リンターエラーがない
- ✅ ブラウザテストが成功する
- ✅ パフォーマンスへの影響が最小限である

---

## 8. 所要時間見積もり

| ステップ | 所要時間 | 累計時間 |
|---------|---------|---------|
| ステップ1: 設計書の更新 | 30分 | 30分 |
| ステップ2: 請求期間計算ユーティリティ関数の作成 | 30分 | 1時間 |
| ステップ3: Backend API修正 | 2-3時間 | 3-4時間 |
| ステップ4: フロントエンド表示ラベルの調整 | 30分 | 3.5-4.5時間 |
| ステップ5: テスト実装 | 1-2時間 | 4.5-6.5時間 |
| ステップ6: ブラウザテスト | 30分 | 5-7時間 |

**合計所要時間**: 約5-7時間（1日）

---

## 9. リスク管理

### 9.1 想定されるリスク

| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|---------|------|
| 既存データの`plan_started_at`が正しく設定されていない | 中 | 低 | マイグレーション012で設定済み、デフォルト値で動作する |
| プラン変更時の`plan_started_at`更新漏れ | 高 | 中 | プラン変更APIの実装時に注意、テストで確認 |
| タイムゾーン処理の不整合 | 高 | 低 | 既存のタイムゾーン処理パターンに従う |
| パフォーマンスへの影響 | 低 | 低 | 請求期間計算は軽量、既存のキャッシュを維持 |

### 9.2 ロールバック手順

**修正が問題を引き起こした場合**:
1. バックアップファイルから`dashboard_service.py`を復元
2. `billing_period.py`を削除
3. テストを実行して動作確認
4. 必要に応じてデータベースの変更をロールバック

---

## 10. まとめ

### 10.1 修正の目的

月次統計の期間ロジックをカレンダー月ベースから契約開始日ベースの請求期間に変更し、Stripe統合との整合性を確保する。

### 10.2 修正内容

1. **設計書の更新**: カレンダー月ベースから契約開始日ベースの請求期間に変更
2. **請求期間計算ユーティリティ関数の作成**: 共通関数を作成し、コードの重複を避ける
3. **Backend API修正**: 月次統計メソッドを請求期間ベースで集計するように修正
4. **フロントエンド表示ラベルの調整**: 必要に応じて表示ラベルを更新
5. **テスト実装**: 請求期間ベースの集計ロジックのテストを実装
6. **ブラウザテスト**: 請求期間ベースの集計が正しく表示されることを確認

### 10.3 期待される効果

- Stripe統合時に請求期間が一致する
- プラン変更時も正しく請求期間を計算できる
- 既存の機能への影響が最小限である

---

**Document Version**: v1.1  
**Author**: Auto (AI Assistant)  
**Created**: 2026年1月17日  
**Updated**: 2026年1月17日  
**Status**: ✅ **修正完了・ステージング環境テスト完了**

---

## 11. 完了サマリー

### 11.1 実施内容

1. ✅ **設計書の更新**: `docs/monthly_dashboard_arch.md`を請求期間ベースに更新
2. ✅ **請求期間計算ユーティリティ関数の作成**: `backend/app/utils/billing_period.py`を新規作成
3. ✅ **Backend API修正**: `backend/app/services/dashboard_service.py`を請求期間ベースに変更
4. ✅ **フロントエンド表示ラベルの調整**: 「今月」→「請求期間」に変更
5. ✅ **テスト実装**: ユニットテスト・統合テストを実装
6. ✅ **ブラウザテスト**: ローカル環境・ステージング環境で実施
7. ✅ **CI/CD環境整備**: テスト必須化、カバレッジ測定追加
8. ✅ **ステージング環境デプロイ**: デプロイ完了・動作確認完了

### 11.2 完了日時

- **実装完了**: 2026年1月17日
- **ステージング環境デプロイ**: 2026年1月17日
- **ステージング環境テスト完了**: 2026年1月17日

### 11.3 関連文書

- `docs/20260117_ステップ6_ブラウザテスト完了報告.md`
- `docs/20260117_CI_CD環境整備完了報告.md`
- `docs/20260117_ステージング環境テスト完了報告.md`


# ダッシュボード500エラー - 根本原因確定・修正案

**作成日時**: 2026年1月16日 13:40:00  
**目的**: ダッシュボードAPIが500エラーを返す問題の根本原因確定と修正案  
**状態**: 根本原因確定中

---

## 1. 問題の説明

### 1.1 報告された問題

- **症状1**: 「未解決の質問」をタップするとエラーが発生
- **症状2**: 「ダッシュボードに戻る」をタップすると「ダッシュボードデータの取得に失敗しました」とエラー
- **症状3**: 再試行してもダッシュボードに戻れない
- **サーバーログ**: `GET /api/v1/admin/dashboard` → 500 Internal Server Error

### 1.2 重大性

- **ビジネス破綻レベルの危機**: PoCが始められない
- **スケジュール変更の可能性**: 重大危機

### 1.3 重要な指摘

- **今回のエラーは初めて発生したエラー**
- **その前に修正した内容に原因がある可能性が高い**
- **最近の修正**: コミット`0e95cee`で`UnresolvedEscalation`スキーマに`session_id`を追加

---

## 2. 根本原因の完全調査分析

### 2.1 最近の修正内容の確認

**コミット**: `0e95cee` - "fix: UnresolvedEscalationスキーマにsession_idを追加"

**変更内容**:
1. `backend/app/schemas/dashboard.py`: `UnresolvedEscalation`に`session_id: str`を追加
2. `backend/app/services/dashboard_service.py`: `get_unresolved_escalations`で`session_id`を取得して返すように修正
3. `frontend/src/types/dashboard.ts`: `UnresolvedEscalation`インターフェースに`session_id`を追加
4. `frontend/src/components/admin/dashboard/UnresolvedListCard.vue`: `session_id`を使用するように修正

**問題の可能性**:
- `session_id`が`None`の場合、Pydanticのバリデーションエラーが発生する可能性
- `session_id`が空文字列の場合、スキーマのバリデーションでエラーが発生する可能性

---

### 2.2 コードの確認

#### `dashboard_service.py`の`get_unresolved_escalations`メソッド

```python
async def get_unresolved_escalations(self, facility_id: int, limit: int = 10) -> List[UnresolvedEscalation]:
    # 未解決エスカレーションを取得
    escalations_result = await self.db.execute(
        select(Escalation)
        .join(Conversation, Escalation.conversation_id == Conversation.id)
        .where(
            Conversation.facility_id == facility_id,
            Escalation.resolved_at.is_(None)
        )
        .order_by(Escalation.created_at.desc())
        .limit(limit)
        .options(selectinload(Escalation.conversation).selectinload(Conversation.messages))
    )
    escalations = escalations_result.scalars().all()
    
    unresolved_list: List[UnresolvedEscalation] = []
    for escalation in escalations:
        # ゲストメッセージを取得（最初のユーザーメッセージ）
        message = ""
        if escalation.conversation and escalation.conversation.messages:
            user_messages = [m for m in escalation.conversation.messages if m.role == MessageRole.USER.value]
            if user_messages:
                message = user_messages[0].content[:200]  # 200文字まで
        
        # session_idを取得
        session_id = ""
        if escalation.conversation:
            session_id = escalation.conversation.session_id  # ← 問題の可能性
        
        unresolved_list.append(UnresolvedEscalation(
            id=escalation.id,
            conversation_id=escalation.conversation_id,
            session_id=session_id,  # ← Noneになる可能性
            created_at=escalation.created_at,
            message=message
        ))
    
    return unresolved_list
```

**問題点**:
1. `escalation.conversation.session_id`が`None`の場合、`session_id`が`None`になる
2. `UnresolvedEscalation`スキーマで`session_id: str = Field(..., description="セッションID")`としているため、`None`は許可されない
3. `Field(...)`は必須フィールドを意味するが、`None`は許可されない

---

### 2.3 Conversationモデルの確認

**確認が必要な点**:
- `Conversation`モデルの`session_id`フィールドが`nullable=True`か`nullable=False`か
- `session_id`が`None`になるケースがあるか

---

### 2.4 根本原因の推定

#### 根本原因1: `session_id`が`None`の場合のPydanticバリデーションエラー（最有力）

**問題**:
- `escalation.conversation.session_id`が`None`の場合、`session_id`が`None`になる
- `UnresolvedEscalation`スキーマで`session_id: str = Field(..., description="セッションID")`としているため、`None`は許可されない
- Pydanticのバリデーションエラーが発生し、500エラーになる

**証拠**:
- ローカル環境では正常動作（`session_id`が`None`になるケースがない）
- ステージング環境で500エラーが発生（`session_id`が`None`になるケースがある）

---

#### 根本原因2: `selectinload`と`JOIN`の競合

**問題**:
- `select(Escalation).join(Conversation, ...)`で既に`JOIN`している
- さらに`.options(selectinload(Escalation.conversation))`で`selectinload`を使用している
- これにより、予期しない動作が発生する可能性

**証拠**:
- `JOIN`で既に結合しているため、`selectinload`は不要
- `selectinload`と`JOIN`の競合により、`conversation`が正しくロードされない可能性

---

## 3. 修正案

### 3.1 修正案1: `session_id`の取得を安全にする（最優先・必須）

**方針**: `session_id`が`None`の場合、空文字列にする

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   # session_idを取得（安全に）
   session_id = ""
   if escalation.conversation and escalation.conversation.session_id:
       session_id = escalation.conversation.session_id
   else:
       # conversationが存在しない、またはsession_idがNoneの場合は空文字列
       logger.warning(
           f"Conversation or session_id not found for escalation {escalation.id} "
           f"(conversation_id={escalation.conversation_id})"
       )
       session_id = ""
   ```

**メリット**:
- ✅ `None`が`str`型に変換されない問題を解決
- ✅ Pydanticのバリデーションエラーを防ぐ
- ✅ エラーログで問題を追跡可能

**デメリット**:
- ⚠️ `session_id`が空文字列の場合、会話詳細ページに遷移できない（これは別の問題）

---

### 3.2 修正案2: エラーハンドリングを追加（最優先・必須）

**方針**: `get_unresolved_escalations`でエラーが発生した場合、空のリストを返す

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   async def get_unresolved_escalations(self, facility_id: int, limit: int = 10) -> List[UnresolvedEscalation]:
       """
       未解決エスカレーションを取得（最新10件）
       
       Args:
           facility_id: 施設ID
           limit: 取得件数（デフォルト: 10）
       
       Returns:
           List[UnresolvedEscalation]: 未解決エスカレーションリスト
       """
       try:
           # 未解決エスカレーションを取得
           escalations_result = await self.db.execute(
               select(Escalation)
               .join(Conversation, Escalation.conversation_id == Conversation.id)
               .where(
                   Conversation.facility_id == facility_id,
                   Escalation.resolved_at.is_(None)
               )
               .order_by(Escalation.created_at.desc())
               .limit(limit)
               .options(selectinload(Escalation.conversation).selectinload(Conversation.messages))
           )
           escalations = escalations_result.scalars().all()
           
           unresolved_list: List[UnresolvedEscalation] = []
           for escalation in escalations:
               # ゲストメッセージを取得（最初のユーザーメッセージ）
               message = ""
               if escalation.conversation and escalation.conversation.messages:
                   user_messages = [m for m in escalation.conversation.messages if m.role == MessageRole.USER.value]
                   if user_messages:
                       message = user_messages[0].content[:200]  # 200文字まで
               
               # session_idを取得（安全に）
               session_id = ""
               if escalation.conversation and escalation.conversation.session_id:
                   session_id = escalation.conversation.session_id
               else:
                   logger.warning(
                       f"Conversation or session_id not found for escalation {escalation.id} "
                       f"(conversation_id={escalation.conversation_id})"
                   )
                   session_id = ""
               
               unresolved_list.append(UnresolvedEscalation(
                   id=escalation.id,
                   conversation_id=escalation.conversation_id,
                   session_id=session_id,
                   created_at=escalation.created_at,
                   message=message
               ))
           
           return unresolved_list
       
       except Exception as e:
           logger.error(
               f"Error getting unresolved escalations for facility {facility_id}: {e}",
               exc_info=True
           )
           return []  # エラー時は空のリストを返す
   ```

**メリット**:
- ✅ ダッシュボードAPIが500エラーを返さない
- ✅ エラーが発生してもダッシュボードは表示される
- ✅ エラーログで問題を追跡可能

**デメリット**:
- ⚠️ 根本原因を解決していない（修正案1と組み合わせる必要がある）

---

### 3.3 修正案3: `selectinload`を削除して`JOIN`のみを使用（次優先）

**方針**: `selectinload`と`JOIN`の競合を避けるため、`selectinload`を削除

**実装内容**:

1. **`dashboard_service.py`を修正**:
   ```python
   # 未解決エスカレーションを取得（JOINでconversationを結合）
   escalations_result = await self.db.execute(
       select(Escalation, Conversation)
       .join(Conversation, Escalation.conversation_id == Conversation.id)
       .where(
           Conversation.facility_id == facility_id,
           Escalation.resolved_at.is_(None)
       )
       .order_by(Escalation.created_at.desc())
       .limit(limit)
       .options(selectinload(Conversation.messages))  # messagesのみselectinload
   )
   escalations = escalations_result.all()
   
   unresolved_list: List[UnresolvedEscalation] = []
   for row in escalations:
       escalation = row[0]  # Escalation
       conversation = row[1]  # Conversation
       
       # ゲストメッセージを取得
       message = ""
       if conversation.messages:
           user_messages = [m for m in conversation.messages if m.role == MessageRole.USER.value]
           if user_messages:
               message = user_messages[0].content[:200]
       
       # session_idを取得（安全に）
       session_id = conversation.session_id or ""  # ← 安全に
       
       unresolved_list.append(UnresolvedEscalation(
           id=escalation.id,
           conversation_id=escalation.conversation_id,
           session_id=session_id,
           created_at=escalation.created_at,
           message=message
       ))
   ```

**メリット**:
- ✅ `JOIN`と`selectinload`の競合を避けられる
- ✅ より明確なコード

**デメリット**:
- ⚠️ コードの変更が大きい
- ⚠️ 修正案1と修正案2で解決できる可能性が高い

---

## 4. 推奨される修正手順

### 4.1 優先順位

1. **最優先・必須**: 修正案1（`session_id`の取得を安全にする）+ 修正案2（エラーハンドリングを追加）
   - 即座に500エラーを解決
   - ダッシュボードが表示されるようになる
   - システム全体を破綻させない

2. **次優先**: 修正案3（`selectinload`を削除して`JOIN`のみを使用）
   - 根本解決
   - コードの改善
   - 修正案1と修正案2で解決できない場合のみ実装

---

### 4.2 実装手順

1. **修正案1と修正案2を実装**
   - `dashboard_service.py`を修正
   - `session_id`の取得を安全にする
   - エラーハンドリングを追加
   - ローカル環境で動作確認
   - Docker環境で動作確認
   - コミット・プッシュ

2. **動作確認**
   - ダッシュボードが表示されることを確認
   - 未解決エスカレーションリストが表示されることを確認
   - エラーログを確認

3. **修正案3を実装（必要に応じて）**
   - `selectinload`を削除
   - `JOIN`のみを使用

---

## 5. 結論

### 5.1 根本原因

**根本原因**: 
1. **`session_id`が`None`の場合のPydanticバリデーションエラー**（最有力）
   - `escalation.conversation.session_id`が`None`の場合、`session_id`が`None`になる
   - `UnresolvedEscalation`スキーマで`session_id: str = Field(..., description="セッションID")`としているため、`None`は許可されない
   - Pydanticのバリデーションエラーが発生し、500エラーになる

2. **エラーハンドリングが不足している**
   - `get_unresolved_escalations`でエラーが発生した場合、`asyncio.gather`全体が失敗し、500エラーになる

3. **`selectinload`と`JOIN`の競合**（可能性は低い）
   - `JOIN`で既に結合しているのに、さらに`selectinload`を使用しているため、予期しない動作が発生する可能性

### 5.2 修正案

**最優先・必須**: 修正案1（`session_id`の取得を安全にする）+ 修正案2（エラーハンドリングを追加）

**期待される結果**: 
- ダッシュボードAPIが500エラーを返さない
- ダッシュボードが表示される
- 未解決エスカレーションリストが表示される
- システム全体を破綻させない

---

**Document Version**: v1.0  
**Author**: Auto (AI Assistant)  
**Last Updated**: 2026年1月16日 13:40:00  
**Status**: 根本原因確定、修正案準備完了


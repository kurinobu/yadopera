# ステージング環境タイムアウトエラー完全調査分析報告書

**作成日時**: 2025年1月13日  
**調査対象**: ステージング環境での新規登録時のタイムアウトエラー  
**エラー種別**: Request Timeout (30秒超過)

---

## 1. エラー概要

### 1.1 発生したエラー

**エラーメッセージ**:
```
リクエストがタイムアウトしました。接続を確認して再度お試しください。
```

**HTTPステータス**: 499 (Client Closed Request)  
**レスポンス時間**: `responseTimeMS=29622` (約30秒)

### 1.2 ログ分析

**Render.comログ**:
```
[POST] yadopera-backend-staging.onrender.com/api/v1/auth/register
clientIP="113.153.22.54" requestID="96457f3f-2e9a-445b" 
responseTimeMS=29622 responseBytes=29
```

**フロントエンド設定**:
- タイムアウト: 30秒（30000ms）
- エラーコード: `TIMEOUT_ERROR`

---

## 2. 根本原因の完全分析

### 2.1 エラー発生順序（確定）

```
1. フロントエンド → POST /api/v1/auth/register リクエスト送信
   ↓
2. バックエンド → リクエスト受信、処理開始
   ↓
3. バックエンド → メールアドレス重複チェック
   ↓
4. バックエンド → 施設作成（slug生成含む）
   ↓
5. バックエンド → ユーザー作成
   ↓
6. バックエンド → FAQ自動投入処理開始
   ↓
7. バックエンド → 30件のFAQ × 2言語 = 60件の翻訳処理
   ↓
8. バックエンド → 各翻訳に対してembedding生成（OpenAI API呼び出し）
   ↓
9. 処理時間が30秒を超過
   ↓
10. フロントエンド → タイムアウトエラー発生（30秒）
   ↓
11. クライアント → リクエストを閉じる（499エラー）
```

### 2.2 処理時間の内訳（推定）

**確認された事実**:
- FAQプリセット数: **30件**
- 総翻訳数: **60件**（各FAQに2言語：ja, en）
- 各翻訳に対してembedding生成が必要

**処理時間の計算**:
1. **施設・ユーザー作成**: 約1-2秒
2. **FAQ自動投入処理**:
   - 60件の翻訳 × embedding生成
   - 各embedding生成: OpenAI API呼び出し（タイムアウト10秒）
   - ネットワーク遅延: 各API呼び出しに0.5-2秒
   - **合計: 30-120秒**（最悪の場合）

**実際の処理時間**: 約30秒（タイムアウト直前）

### 2.3 コードベース確認結果

**FAQ自動投入処理**:

```227:253:backend/app/services/auth_service.py
        # FAQ自動投入
        try:
            # プリセットFAQをFAQRequestに変換
            faq_requests = []
            for preset in FAQ_PRESETS:
                faq_request = FAQRequest(
                    category=preset["category"],
                    intent_key=preset["intent_key"],
                    translations=[
                        {
                            "language": t["language"],
                            "question": t["question"],
                            "answer": t["answer"]
                        } for t in preset["translations"]
                    ],
                    priority=preset["priority"],
                    is_active=True
                )
                faq_requests.append(faq_request)
            
            await FAQService(db).bulk_create_faqs(facility.id, faq_requests, user.id)
        except Exception as e:
            # FAQ投入失敗時はロールバック
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Failed to create FAQs: {str(e)}"
            )
```

**bulk_create_faqs処理**:

```356:403:backend/app/services/faq_service.py
    async def bulk_create_faqs(
        self,
        facility_id: int,
        faq_requests: List[FAQRequest],
        user_id: int
    ) -> List[FAQResponse]:
        """
        FAQ一括作成（埋め込みベクトル自動生成、インテントベース構造）
        """
        created_faqs = []
        
        for request in faq_requests:
            try:
                # 個別のcreate_faqを呼び出し
                faq_response = await self.create_faq(
                    facility_id=facility_id,
                    request=request,
                    user_id=user_id
                )
                created_faqs.append(faq_response)
```

**embedding生成処理**:

```264:269:backend/app/services/faq_service.py
            # 埋め込みベクトル生成
            embedding = None
            try:
                combined_text = f"{trans_request.question} {trans_request.answer}"
                logger.debug(f"Generating FAQ translation embedding: language={trans_request.language}, text_length={len(combined_text)}")
                embedding = await generate_embedding(combined_text)
```

**OpenAI API呼び出し**:

```174:201:backend/app/ai/openai_client.py
    async def generate_embedding(
        self,
        text: str
    ) -> List[float]:
        """
        埋め込みベクトル生成（リトライロジック付き、v0.3詳細化）
        """
        try:
            # OpenAI APIは同期なので、asyncio.to_threadで非同期実行
            # asyncio.wait_forでタイムアウトを実装
            response = await asyncio.wait_for(
                asyncio.to_thread(
                    self.client.embeddings.create,
                    model=self.model_embedding,
                    input=text
                ),
                timeout=self.TIMEOUT  # 10秒
            )
```

**タイムアウト設定**:

```15:15:frontend/src/api/axios.ts
  timeout: 30000, // 30秒
```

### 2.4 根本原因の確定

**主原因**: FAQ自動投入処理が同期的に実行され、60件のembedding生成に時間がかかりすぎる

**詳細**:
1. 30件のFAQ × 2言語 = 60件の翻訳
2. 各翻訳に対してOpenAI API呼び出し（embedding生成）
3. 各API呼び出しに0.5-2秒かかる（ネットワーク遅延含む）
4. 合計処理時間: 30-120秒（最悪の場合）
5. フロントエンドのタイムアウト: 30秒
6. **結果**: タイムアウトエラー発生

**副次的原因**:
- フロントエンドのタイムアウト設定が短すぎる（30秒）
- FAQ自動投入処理が同期的に実行されている（非同期処理の余地がない）

---

## 3. 修正案（大原則準拠）

### 3.1 根本解決: FAQ自動投入を非同期処理に変更

**方針**: 
1. 施設・ユーザー作成は同期的に実行（即座にレスポンス）
2. FAQ自動投入はバックグラウンドで非同期実行
3. 登録完了後、FAQ投入状況を確認できるAPIを提供

**メリット**:
- 登録処理が高速化（2-3秒で完了）
- ユーザー体験の向上
- タイムアウトエラーの解消

**デメリット**:
- FAQ投入完了まで時間がかかる（バックグラウンド処理）
- 追加の実装が必要

### 3.2 暫定解決: タイムアウト時間の延長

**方針**: 
1. フロントエンドのタイムアウトを60-90秒に延長
2. バックエンドの処理は現状維持

**メリット**:
- 実装が簡単
- 即座に適用可能

**デメリット**:
- 根本的な解決にならない
- ユーザーが長時間待つ必要がある
- ネットワークが遅い場合、まだタイムアウトする可能性

### 3.3 推奨修正方針

**段階的アプローチ**:
1. **即座の対応**: タイムアウト時間を延長（60秒）
2. **根本解決**: FAQ自動投入を非同期処理に変更（後続のタスク）

---

## 4. 修正案詳細（大原則準拠）

### 4.1 修正案1: タイムアウト時間の延長（暫定解決）

**修正箇所**: `frontend/src/api/axios.ts`

```typescript
// Axiosインスタンス作成
const apiClient: AxiosInstance = axios.create({
  baseURL: `${API_BASE_URL}/api/v1`,
  timeout: 90000, // 90秒（60件のembedding生成を考慮）
  headers: {
    'Content-Type': 'application/json'
  }
})
```

**理由**:
- 60件のembedding生成 × 1.5秒/件 = 90秒（余裕を持たせる）
- 実装が簡単で即座に適用可能
- 根本解決までの暫定対応として有効

### 4.2 修正案2: FAQ自動投入を非同期処理に変更（根本解決）

**修正箇所**: `backend/app/services/auth_service.py`

```python
# 施設登録処理
async def register_facility(
    db: AsyncSession,
    request: FacilityRegisterRequest
) -> LoginResponse:
    """
    施設登録処理（FAQ自動投入は非同期で実行）
    """
    # メールアドレス重複チェック
    # ... (既存コード)
    
    # 施設作成
    facility = Facility(...)
    db.add(facility)
    await db.flush()
    
    # ユーザー作成
    user = User(...)
    db.add(user)
    await db.flush()
    
    # コミット（施設・ユーザー作成を確定）
    await db.commit()
    
    # FAQ自動投入はバックグラウンドで実行（非同期）
    # エラーが発生しても登録処理は成功とする
    try:
        # バックグラウンドタスクとして実行
        # 注意: FastAPIのBackgroundTasksを使用
        pass  # 実装詳細は後述
    except Exception as e:
        # FAQ投入失敗はログに記録するが、登録処理は成功とする
        logger.error(f"Failed to create FAQs in background: {str(e)}")
    
    # JWTトークン生成
    access_token = create_access_token(...)
    
    # レスポンス作成
    return LoginResponse(...)
```

**実装詳細**:

**backend/app/api/v1/auth.py**:

```python
from fastapi import BackgroundTasks

@router.post("/register", response_model=LoginResponse)
async def register_facility(
    request: FacilityRegisterRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db)
) -> LoginResponse:
    """
    施設登録（FAQ自動投入はバックグラウンドで実行）
    """
    try:
        # 施設・ユーザー作成のみ実行（FAQ投入は含まない）
        response = await AuthService.register_facility_sync(db, request)
        
        # FAQ自動投入をバックグラウンドで実行
        background_tasks.add_task(
            AuthService.register_facility_async_faqs,
            db,
            response.user.facility_id,
            response.user.id
        )
        
        return response
    except IntegrityError as e:
        # ... (既存の例外ハンドリング)
```

**backend/app/services/auth_service.py**:

```python
@staticmethod
async def register_facility_sync(
    db: AsyncSession,
    request: FacilityRegisterRequest
) -> LoginResponse:
    """
    施設登録処理（同期部分：施設・ユーザー作成のみ）
    """
    # メールアドレス重複チェック
    # 施設作成
    # ユーザー作成
    # コミット
    # JWTトークン生成
    # レスポンス作成
    pass

@staticmethod
async def register_facility_async_faqs(
    db: AsyncSession,
    facility_id: int,
    user_id: int
):
    """
    FAQ自動投入処理（バックグラウンド実行）
    """
    try:
        # 新しいデータベースセッションを作成
        async with get_db() as new_db:
            # プリセットFAQをFAQRequestに変換
            faq_requests = []
            for preset in FAQ_PRESETS:
                # ... (既存コード)
            
            await FAQService(new_db).bulk_create_faqs(facility_id, faq_requests, user_id)
            await new_db.commit()
    except Exception as e:
        logger.error(f"Background FAQ creation failed: {str(e)}", exc_info=True)
```

**注意事項**:
- バックグラウンドタスクでは新しいデータベースセッションが必要
- エラーハンドリングを適切に実装
- ログ記録を充実させる

### 4.3 修正案3: ハイブリッドアプローチ（推奨）

**方針**:
1. **即座の対応**: タイムアウト時間を延長（90秒）
2. **根本解決**: FAQ自動投入を非同期処理に変更（後続のタスク）

**実装順序**:
1. タイムアウト時間を延長（即座に適用可能）
2. FAQ自動投入を非同期処理に変更（根本解決）

---

## 5. 修正手順（指示待ち）

### 5.1 修正案1: タイムアウト時間の延長（暫定解決）

**実装ステップ**:
1. `frontend/src/api/axios.ts`を修正
2. タイムアウト時間を30秒 → 90秒に変更
3. Docker環境でテスト
4. ステージング環境にデプロイ

**テスト項目**:
- [ ] 新規施設登録が90秒以内に完了することを確認
- [ ] タイムアウトエラーが発生しないことを確認
- [ ] FAQが正しく作成されることを確認

### 5.2 修正案2: FAQ自動投入を非同期処理に変更（根本解決）

**実装ステップ**:
1. `backend/app/services/auth_service.py`を修正
   - `register_facility_sync`メソッドを追加
   - `register_facility_async_faqs`メソッドを追加
2. `backend/app/api/v1/auth.py`を修正
   - `BackgroundTasks`を使用
3. Docker環境でテスト
4. ステージング環境にデプロイ

**テスト項目**:
- [ ] 新規施設登録が2-3秒で完了することを確認
- [ ] FAQがバックグラウンドで作成されることを確認
- [ ] エラーハンドリングが正しく動作することを確認

---

## 6. 結論

### 6.1 確定した原因

1. **主原因**: FAQ自動投入処理が同期的に実行され、60件のembedding生成に時間がかかりすぎる
2. **副次的原因**: フロントエンドのタイムアウト設定が短すぎる（30秒）

### 6.2 推奨修正方針

- **即座の対応**: タイムアウト時間を延長（90秒）
- **根本解決**: FAQ自動投入を非同期処理に変更（後続のタスク）

### 6.3 参照文書

- 要約定義書v0.3.9（大原則準拠）
- アーキテクチャ設計書v0.3.7
- 引き継ぎ書（2025-12-29）

---

**指示があるまで修正を保留します。修正実施の指示をお待ちしております。**


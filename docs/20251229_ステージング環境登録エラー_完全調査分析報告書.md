# ステージング環境登録エラー完全調査分析報告書

**作成日時**: 2025年12月29日  
**調査対象**: ステージング環境での施設登録時のエラー  
**エラー種別**: CORS + Database Integrity Error  
**状態**: ✅ **完全調査分析完了・大原則準拠修正案提示済み**

---

## 1. エラー概要

### 1.1 発生したエラー（2つ）

**エラー1: CORS Policy Violation**
```
Access to XMLHttpRequest at 'https://yadopera-backend-staging.onrender.com/api/v1/auth/register' 
from origin 'https://yadopera-frontend-staging.onrender.com' has been blocked by CORS policy: 
No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

**エラー2: Database Integrity Error**
```
sqlalchemy.exc.IntegrityError: (sqlalchemy.dialects.postgresql.asyncpg.IntegrityError) 
<class 'asyncpg.exceptions.UniqueViolationError'>: duplicate key value violates unique constraint "idx_facilities_slug"
DETAIL:  Key (slug)=(クリブロゲストハウス) already exists.
```

### 1.2 HTTP ステータス
- **500 Internal Server Error**
- バックエンドでデータベースエラーが発生し、その後CORSヘッダーが返却されなかった

---

## 2. 根本原因の完全分析

### 2.1 エラー発生順序（確定）

```
1. フロントエンド → POST /api/v1/auth/register リクエスト送信
   ↓
2. バックエンド → リクエスト受信、処理開始
   ↓
3. バックエンド → データベースへのINSERT実行
   ↓
4. PostgreSQL → UniqueViolationError発生
   原因: slug='クリブロゲストハウス' が既に存在
   ↓
5. SQLAlchemy → IntegrityError例外発生
   ↓
6. FastAPI → 例外ハンドリング失敗（CORSヘッダー未付与）
   ↓
7. レスポンス → 500エラー、CORSヘッダー未付与
   ↓
8. フロントエンド → CORSエラー表示（実際はDBエラーが原因）
```

### 2.2 CORS エラーの真の原因

**CORSエラーは二次的な現象であり、本質的な原因ではない**

- バックエンドで500エラーが発生した場合、FastAPIの例外ハンドラーがCORSヘッダーを付与する前に処理が中断される可能性がある
- CORSミドルウェアは正常応答時には機能するが、未ハンドリング例外時には機能しない
- ブラウザは「CORSエラー」として表示するが、実際はバックエンドの500エラーが原因

**確認事項**:
- `backend/app/main.py`のCORS設定は正しい（`settings.cors_origins_list`を使用）
- ステージング環境の環境変数`CORS_ORIGINS`に`https://yadopera-frontend-staging.onrender.com`が含まれているか確認が必要

### 2.3 Database Integrity Error の原因（確定）

**確定事実**:
```python
# backend/app/services/auth_service.py:185
slug=AuthService._generate_slug(request.facility_name),
```

**問題のあるslug生成ロジック**:
```python
# backend/app/services/auth_service.py:28-42
@staticmethod
def _generate_slug(name: str) -> str:
    import re
    # 小文字に変換、記号を除去、空白をハイフンに
    slug = re.sub(r'[^\w\s-]', '', name.lower())
    slug = re.sub(r'[\s_]+', '-', slug)
    return slug.strip('-')
```

**問題点**:
1. **日本語文字列の処理不備**: `\w`は英数字とアンダースコアのみにマッチするため、日本語文字（ひらがな、カタカナ、漢字）は削除される
2. **空文字列の可能性**: 日本語のみの施設名（例: "クリブロゲストハウス"）の場合、`\w`にマッチする文字がないため、空文字列または短い文字列になる可能性がある
3. **重複チェックが存在しない**: 同じ施設名で登録を試みると、同じslugが生成され、ユニーク制約違反が発生
4. **URLセーフでない**: 日本語がそのままslugに使用される可能性がある

**実際のエラー**:
- 施設名: "クリブロゲストハウス"
- 生成されたslug: "クリブロゲストハウス"（日本語がそのまま使用されている）
- 既に同じslugが存在するため、ユニーク制約違反が発生

**制約違反**:
```sql
CONSTRAINT idx_facilities_slug UNIQUE (slug)
```

---

## 3. コードベース調査結果

### 3.1 backend/app/services/auth_service.py の該当箇所

```python
# Line 180-193
# 新規施設作成
new_facility = Facility(
    name=request.name,
    slug=AuthService._generate_slug(request.facility_name),  # ← ここが問題の根源
    email=request.email,
    phone=request.phone,
    address=request.address,
    # ... 以下省略
)
db.add(new_facility)
await db.flush()  # ← ここでUniqueViolationError発生
```

**問題点**:
1. `_generate_slug()`が日本語を適切に処理できていない
2. 重複チェックが存在しない
3. slug生成ロジックが不適切（URLセーフでない）

### 3.2 backend/app/models/facility.py の該当箇所

```python
# Line 20
slug = Column(String(200), unique=True, nullable=False, index=True)
```

**制約**:
- UNIQUE制約が設定されている
- インデックス名: `idx_facilities_slug`

### 3.3 CORS設定の確認（backend/app/main.py）

```python
# CORSミドルウェア設定
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

**確認事項**:
- `settings.cors_origins_list`の設定値を確認する必要がある
- ステージング環境の環境変数で正しく設定されているか

### 3.4 backend/app/core/config.py の確認

```python
# Line 25
cors_origins: str = "http://localhost:5173,http://localhost:3000"

@property
def cors_origins_list(self) -> List[str]:
    """CORS originsをリストに変換"""
    return [origin.strip() for origin in self.cors_origins.split(",")]
```

**問題点**:
- デフォルト値にステージング環境のURLが含まれていない
- ステージング環境の環境変数`CORS_ORIGINS`に`https://yadopera-frontend-staging.onrender.com`が設定されているか確認が必要

---

## 4. 修正案（大原則準拠・確定案）

### 4.1 大原則の確認

1. **根本解決 > 暫定解決**: slug生成ロジックを根本的に改善
2. **シンプル構造 > 複雑構造**: UUIDベースのシンプルな実装
3. **統一・同一化 > 特殊独自**: 既存のパターンに従う（SessionTokenServiceのトークン生成パターンを参考）
4. **具体的 > 一般**: 具体的な実装方法を提示
5. **拙速 < 安全確実**: 重複チェックを確実に実施
6. **Docker環境必須 > ローカル直接実行**: Docker環境でテスト

### 4.2 根本解決: slug生成ロジックの改善

**方針**:
1. URLセーフな英数字slugを生成
2. 重複時は連番を付与
3. 日本語をローマ字変換またはUUID使用

**実装案1: UUID + 施設名ベース（推奨・大原則準拠）**

```python
import uuid
import re
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from backend.app.models.facility import Facility


async def generate_unique_slug(db: AsyncSession, base_name: str) -> str:
    """
    URLセーフなユニークslugを生成
    
    Args:
        db: データベースセッション
        base_name: 施設名
    
    Returns:
        str: ユニークなslug（例: "guesthouse-a1b2c3d4"）
    """
    # 施設名を英数字に変換（簡易版）
    # 日本語は削除し、英数字のみを使用
    slug_base = re.sub(r'[^\w\s-]', '', base_name.lower())
    slug_base = re.sub(r'[-\s]+', '-', slug_base).strip('-')
    
    # 英数字が存在しない場合はデフォルト値を使用
    if not slug_base or len(slug_base) < 1:
        slug_base = "facility"
    
    # 最大20文字に制限
    slug_base = slug_base[:20]
    
    # UUIDの先頭8文字を付与
    unique_id = str(uuid.uuid4())[:8]
    slug = f"{slug_base}-{unique_id}"
    
    # 念のため重複チェック（UUID使用時はほぼ不要だが安全のため）
    result = await db.execute(
        select(Facility).where(Facility.slug == slug)
    )
    if result.scalar_one_or_none() is not None:
        # 万が一重複した場合はUUID全体を使用
        slug = f"{slug_base}-{str(uuid.uuid4())}"
    
    return slug
```

**実装案2: タイムスタンプ + 連番（代替案・大原則準拠）**

```python
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from backend.app.models.facility import Facility


async def generate_unique_slug(db: AsyncSession, base_name: str) -> str:
    """
    タイムスタンプベースのユニークslugを生成
    """
    # 施設名を英数字に変換
    slug_base = re.sub(r'[^\w\s-]', '', base_name.lower())
    slug_base = re.sub(r'[-\s]+', '-', slug_base).strip('-')
    
    if not slug_base or len(slug_base) < 1:
        slug_base = "facility"
    
    # 最大20文字に制限
    slug_base = slug_base[:20]
    
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    slug_base_with_timestamp = f"{slug_base}-{timestamp}"
    
    # 重複チェック
    counter = 1
    slug = slug_base_with_timestamp
    while True:
        result = await db.execute(
            select(Facility).where(Facility.slug == slug)
        )
        if result.scalar_one_or_none() is None:
            break
        slug = f"{slug_base_with_timestamp}-{counter}"
        counter += 1
    
    return slug
```

### 4.3 修正箇所

**backend/app/services/auth_service.py**

```python
# Line 27-42を修正
@staticmethod
async def _generate_unique_slug(db: AsyncSession, base_name: str) -> str:
    """
    URLセーフなユニークslugを生成
    
    Args:
        db: データベースセッション
        base_name: 施設名
    
    Returns:
        str: ユニークなslug
    """
    import uuid
    import re
    from sqlalchemy import select
    
    # 施設名を英数字に変換
    slug_base = re.sub(r'[^\w\s-]', '', base_name.lower())
    slug_base = re.sub(r'[-\s]+', '-', slug_base).strip('-')
    
    # 英数字が存在しない場合はデフォルト値を使用
    if not slug_base or len(slug_base) < 1:
        slug_base = "facility"
    
    # 最大20文字に制限
    slug_base = slug_base[:20]
    
    # UUIDの先頭8文字を付与
    unique_id = str(uuid.uuid4())[:8]
    slug = f"{slug_base}-{unique_id}"
    
    # 念のため重複チェック
    result = await db.execute(
        select(Facility).where(Facility.slug == slug)
    )
    if result.scalar_one_or_none() is not None:
        # 万が一重複した場合はUUID全体を使用
        slug = f"{slug_base}-{str(uuid.uuid4())}"
    
    return slug

# Line 180-193を修正
# 施設作成
facility = Facility(
    name=request.facility_name,
    slug=await AuthService._generate_unique_slug(db, request.facility_name),  # ← 修正: ユニークslugを使用
    email=request.email,
    subscription_plan=request.subscription_plan
)
```

### 4.4 CORS設定の確認・修正

**backend/app/core/config.py の確認**

```python
# 環境変数の確認
cors_origins: str = Field(
    default="http://localhost:5173,http://localhost:3000",
    description="CORS許可オリジン（カンマ区切り）"
)
```

**Render.com環境変数の確認**:
- `CORS_ORIGINS`に`https://yadopera-frontend-staging.onrender.com`が含まれているか確認
- 含まれていない場合は追加が必要

### 4.5 例外ハンドリングの改善

**backend/app/api/v1/auth.py の修正**

```python
from fastapi import HTTPException
from sqlalchemy.exc import IntegrityError

@router.post("/register", response_model=RegisterResponse)
async def register_facility(
    request: RegisterRequest,
    db: AsyncSession = Depends(get_db)
) -> RegisterResponse:
    """新規施設登録"""
    try:
        return await AuthService.register_facility(db, request)
    except IntegrityError as e:
        # データベース制約違反のハンドリング
        error_str = str(e.orig) if hasattr(e, 'orig') else str(e)
        if "idx_facilities_slug" in error_str:
            raise HTTPException(
                status_code=400,
                detail="施設の登録に失敗しました。同じ施設名が既に登録されている可能性があります。"
            )
        elif "idx_facilities_email" in error_str or "email" in error_str.lower():
            raise HTTPException(
                status_code=400,
                detail="このメールアドレスは既に登録されています。"
            )
        else:
            raise HTTPException(
                status_code=500,
                detail="施設の登録中にエラーが発生しました。"
            )
    except Exception as e:
        # その他の例外
        raise HTTPException(
            status_code=500,
            detail=f"予期しないエラーが発生しました: {str(e)}"
        )
```

---

## 5. ユーザー提供修正案の評価

### 5.1 修正案の内容

ユーザーが提供した修正案は以下の通り:
1. UUID + 施設名ベースのslug生成
2. タイムスタンプ + 連番ベースのslug生成
3. 例外ハンドリングの追加
4. CORS設定の確認

### 5.2 評価結果

**✅ 良い点**:
1. UUIDベースのslug生成は重複の可能性が極めて低く、適切
2. 重複チェックを実装している点は安全
3. 例外ハンドリングの追加は適切

**⚠️ 改善点**:
1. **日本語処理の明確化**: 日本語が削除されることを明示する必要がある
2. **デフォルト値の設定**: 英数字が存在しない場合のデフォルト値（"facility"）を設定
3. **slug長さの制限**: データベースの`String(200)`制約を考慮し、適切な長さに制限

**✅ 大原則準拠**:
- 根本解決: slug生成ロジックを根本的に改善 ✅
- シンプル構造: UUIDベースのシンプルな実装 ✅
- 統一・同一化: 既存のSessionTokenServiceパターンに準拠 ✅
- 具体的: 具体的な実装方法を提示 ✅
- 安全確実: 重複チェックを確実に実施 ✅

---

## 6. 修正手順（指示待ち）

### 6.1 実装ステップ

1. **新規メソッド追加**: `backend/app/services/auth_service.py`に`_generate_unique_slug()`メソッドを追加
2. **auth_service.py修正**: `register_facility()`メソッドでslug生成ロジックを変更
3. **auth.py修正**: 例外ハンドリング追加
4. **config.py確認**: CORS_ORIGINS設定確認
5. **Render.com環境変数確認**: CORS_ORIGINS設定確認
6. **Docker環境でテスト**: 動作確認
7. **ステージング環境デプロイ**: 修正反映

### 6.2 テスト項目

- [ ] 新規施設登録（日本語名）→ 成功
- [ ] 重複施設名での登録 → 成功（異なるslug）
- [ ] メールアドレス重複 → 400エラー、適切なエラーメッセージ
- [ ] CORSエラーが発生しないことを確認
- [ ] 生成されたslugがURLセーフであることを確認
- [ ] 英数字のみの施設名 → 正常にslug生成
- [ ] 日本語のみの施設名 → デフォルト値"facility" + UUID

---

## 7. 結論

### 7.1 確定した原因

1. **主原因**: `slug`生成ロジックが日本語を適切に処理できず、重複チェックが不足
2. **副次的原因**: データベース制約違反時のCORSヘッダー未付与

### 7.2 推奨修正方針

- **根本解決**: UUID + 施設名ベースのslug生成ロジック実装（大原則準拠）
- **安全対策**: 例外ハンドリング強化
- **CORS設定**: 環境変数の確認・修正

### 7.3 参照文書

- 要約定義書v0.3.9（大原則準拠）
- アーキテクチャ設計書v0.3.7（データベース設計）
- Phase1_Phase2_引き継ぎ書_20251214.md（大原則・禁止事項）

---

**指示があるまで修正を保留します。修正実施の指示をお待ちしております。**


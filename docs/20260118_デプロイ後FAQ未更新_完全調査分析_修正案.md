# デプロイ後FAQ未更新問題 - 完全調査分析・修正案

**作成日**: 2026年1月18日  
**問題**: デプロイ完了後、ヘルプチャットFAQの内容が更新されていない  
**コミット**: `b6d0eee` - "統合ヘルプシステムFAQ全30項目の修正完了"  
**デプロイ日時**: January 18, 2026 at 6:03 PM

---

## 1. 問題の概要

### 1.1 症状
- デプロイ完了後、サイトデータをクリアし、強制リロードを実施
- しかし、ヘルプチャットFAQの内容が更新されていない
- 修正したFAQデータ（チェックイン時間→チェックアウト時間、Phase削除、関連URL修正など）が反映されていない

### 1.2 影響範囲
- 統合ヘルプシステムのFAQ表示
- AIチャットのFAQ参照
- ユーザー体験への影響

---

## 2. 根本原因分析

### 2.1 原因1: デプロイプロセスにFAQデータ更新処理が含まれていない

**現状**:
- `render.yaml`の`buildCommand`には`alembic upgrade head`のみ
- FAQデータ更新スクリプト（`update_operator_faqs.py`）の実行がない

**確認結果**:
```yaml
# render.yaml (現在)
buildCommand: pip install -r requirements.txt && alembic upgrade head
```

**問題点**:
- マイグレーションは実行されるが、FAQデータの更新は行われない
- 既存のFAQデータが古いまま残る

### 2.2 原因2: insert_operator_faqs.pyは既存データをスキップする

**現状**:
```python
# backend/scripts/insert_operator_faqs.py (665-668行目)
if existing_faq:
    logger.info(f"FAQ already exists: {faq_data['intent_key']}, skipping...")
    skipped_count += 1
    continue
```

**問題点**:
- 既存データがある場合、更新されずにスキップされる
- 修正したFAQデータが反映されない

### 2.3 原因3: Redisキャッシュに古いデータが残っている可能性

**現状**:
- `operator_faq_service.py`はRedisキャッシュを使用（TTL: 5分）
- データベースが更新されても、キャッシュがクリアされない限り古いデータが返される

**問題点**:
- デプロイ時にキャッシュがクリアされない
- ユーザーが古いキャッシュデータを見る可能性がある

### 2.4 原因4: アプリケーション起動時にFAQデータ更新処理がない

**現状**:
- `backend/app/main.py`には起動時の処理（lifespanイベント）がない
- FAQデータの整合性チェック・更新処理がない

**問題点**:
- デプロイ後、自動的にFAQデータが更新されない
- 手動でスクリプトを実行する必要がある

---

## 3. 修正案

### 3.1 修正案1: アプリケーション起動時にFAQデータを自動更新（推奨）

**大原則への準拠**:
- ✅ **根本的解決 > 一時的解決**: デプロイ時に自動的にFAQデータを更新
- ✅ **シンプルな構造 > 複雑な構造**: 起動時の1回の処理で完結
- ✅ **統一/標準化 > 特殊/独自**: 他の初期データ処理と同様のパターン
- ✅ **安全/確実 > 性急**: エラーハンドリングを適切に実装

**実装内容**:
1. `backend/app/main.py`にlifespanイベントを追加
2. 起動時にFAQデータ更新スクリプトを実行
3. エラーが発生してもアプリケーションは起動する（フォールバック）

**メリット**:
- デプロイ時に自動的にFAQデータが更新される
- 手動操作が不要
- データの整合性が保証される

**デメリット**:
- 起動時間が若干増加する可能性（ただし、FAQデータは31件のみで影響は軽微）

**実装コード例**:
```python
# backend/app/main.py
from contextlib import asynccontextmanager
from app.database import get_db
from app.services.operator_faq_service import OperatorFaqService
import logging

logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    アプリケーションライフサイクル管理
    起動時と終了時の処理を定義
    """
    # 起動時処理
    logger.info("Starting up...")
    
    # FAQデータ更新処理
    try:
        logger.info("Updating operator FAQ data...")
        from scripts.update_operator_faqs import update_operator_faqs
        await update_operator_faqs()
        logger.info("Operator FAQ data update completed")
    except Exception as e:
        logger.error(f"Failed to update operator FAQ data: {e}", exc_info=True)
        # エラーが発生してもアプリケーションは起動する
    
    yield
    
    # 終了時処理
    logger.info("Shutting down...")

app = FastAPI(
    title="YadOPERA API",
    description="小規模宿泊施設向けAI多言語自動案内システム",
    version="0.3.0",
    lifespan=lifespan
)
```

**注意点**:
- `update_operator_faqs.py`を非同期関数として呼び出せるように修正が必要
- データベース接続の確立を待つ必要がある

---

### 3.2 修正案2: render.yamlのbuildCommandにFAQデータ更新スクリプトを追加

**大原則への準拠**:
- ✅ **統一/標準化 > 特殊/独自**: マイグレーションと同様のパターン
- ⚠️ **シンプルな構造 > 複雑な構造**: buildCommandが長くなる

**実装内容**:
```yaml
# render.yaml
buildCommand: pip install -r requirements.txt && alembic upgrade head && python scripts/update_operator_faqs.py
```

**メリット**:
- デプロイ時に自動的にFAQデータが更新される
- 実装が簡単

**デメリット**:
- buildCommandが長くなる
- ビルド時間が増加する
- エラーハンドリングが難しい

---

### 3.3 修正案3: マイグレーションファイルにFAQデータ更新を含める

**大原則への準拠**:
- ✅ **統一/標準化 > 特殊/独自**: マイグレーションの標準的なパターン
- ⚠️ **シンプルな構造 > 複雑な構造**: マイグレーションファイルが複雑になる

**実装内容**:
- 新しいマイグレーションファイルを作成
- `upgrade()`関数内でFAQデータ更新処理を実行

**メリット**:
- マイグレーションと一緒に実行される
- データの整合性が保証される

**デメリット**:
- マイグレーションファイルが複雑になる
- FAQデータの変更のたびにマイグレーションが必要

---

### 3.4 修正案4: Redisキャッシュのクリア処理を追加

**大原則への準拠**:
- ✅ **安全/確実 > 性急**: キャッシュを確実にクリア

**実装内容**:
1. FAQデータ更新後に、関連するキャッシュキーを削除
2. または、キャッシュキーにバージョン番号を含める

**実装コード例**:
```python
# backend/app/services/operator_faq_service.py
async def clear_faq_cache(self):
    """FAQ関連のキャッシュをクリア"""
    try:
        # パターンマッチでキャッシュキーを削除
        keys = await redis_client.keys("operator_faqs:*")
        if keys:
            await redis_client.delete(*keys)
            logger.info(f"Cleared {len(keys)} FAQ cache keys")
    except Exception as e:
        logger.warning(f"Cache clear error: {e}")
```

---

## 4. 推奨修正案

### 4.1 最優先: 修正案1（アプリケーション起動時にFAQデータを自動更新）

**理由**:
1. **根本的解決**: デプロイ時に自動的にFAQデータが更新される
2. **シンプルな構造**: 起動時の1回の処理で完結
3. **安全/確実**: エラーハンドリングを適切に実装
4. **統一/標準化**: 他の初期データ処理と同様のパターン

### 4.2 補完: 修正案4（Redisキャッシュのクリア処理）

**理由**:
1. FAQデータ更新後にキャッシュをクリアすることで、即座に新しいデータが反映される
2. ユーザーが古いキャッシュデータを見ることを防ぐ

---

## 5. 実装手順

### 5.1 ステップ1: update_operator_faqs.pyを非同期関数として呼び出せるように修正

**変更内容**:
- `main()`関数を削除し、`update_operator_faqs()`を直接呼び出せるようにする
- または、`update_operator_faqs()`を非同期関数として公開する

### 5.2 ステップ2: backend/app/main.pyにlifespanイベントを追加

**変更内容**:
- `@asynccontextmanager`デコレータを使用
- 起動時に`update_operator_faqs()`を実行
- エラーハンドリングを実装

### 5.3 ステップ3: Redisキャッシュクリア処理を追加

**変更内容**:
- `operator_faq_service.py`に`clear_faq_cache()`メソッドを追加
- FAQデータ更新後にキャッシュをクリア

### 5.4 ステップ4: テスト

**確認項目**:
1. アプリケーション起動時にFAQデータが更新される
2. Redisキャッシュがクリアされる
3. APIエンドポイントで新しいFAQデータが返される
4. エラーが発生してもアプリケーションが起動する

---

## 6. 注意事項

### 6.1 パフォーマンスへの影響
- FAQデータ更新処理は31件のみで、処理時間は数秒程度
- 起動時間への影響は軽微

### 6.2 エラーハンドリング
- FAQデータ更新に失敗しても、アプリケーションは起動する
- エラーログを適切に記録する

### 6.3 データベース接続
- 起動時にデータベース接続が確立されていることを確認する
- 接続が確立されていない場合は、リトライ処理を実装する

---

## 7. 代替案（緊急時の手動対応）

### 7.1 手動でFAQデータ更新スクリプトを実行

**手順**:
1. ステージング環境のデータベース接続情報を取得
2. ローカル環境で環境変数を設定
3. `python backend/scripts/update_operator_faqs.py`を実行

**注意点**:
- 一時的な対応であり、根本的な解決ではない
- 次回のデプロイ時に再度手動実行が必要

---

## 8. まとめ

### 8.1 問題の根本原因
1. デプロイプロセスにFAQデータ更新処理が含まれていない
2. 既存データがある場合、更新されずにスキップされる
3. Redisキャッシュに古いデータが残っている可能性

### 8.2 推奨修正案
1. **最優先**: アプリケーション起動時にFAQデータを自動更新（修正案1）
2. **補完**: Redisキャッシュのクリア処理を追加（修正案4）

### 8.3 実装優先度
1. **高**: 修正案1の実装（根本的解決）
2. **中**: 修正案4の実装（補完）
3. **低**: 修正案2、3（代替案）

---

**Document Version**: v1.0  
**Author**: Auto (AI Assistant)  
**Last Updated**: 2026年1月18日  
**Status**: 調査分析完了、修正案提示完了


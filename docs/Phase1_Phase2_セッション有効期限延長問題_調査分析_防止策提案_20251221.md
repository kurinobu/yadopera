# セッション有効期限延長問題 調査分析・防止策提案

**作成日時**: 2025年12月21日  
**調査目的**: ゲストが24時間以内に再アクセスした場合、セッション有効期限が延長されてチェックアウト後もアクセス可能になる問題の有無を確認し、防止策を提案

---

## 調査結果サマリー

⚠️ **問題確認**: 現状の実装では、**24時間以内に再アクセスすると、セッション有効期限が実質的に延長される可能性があります**

---

## 1. 現状の実装分析

### 1.1 セッション有効期限の判定方法

#### 設計書の記載（v0.2, v0.3）

設計書には以下の`is_session_valid()`関数が記載されています：

```python
async def is_session_valid(session_id: str, db: AsyncSession) -> bool:
    # 3. 24時間以内のアクティビティ確認
    now = datetime.utcnow()
    if conversation.last_activity_at < now - timedelta(hours=24):
        # セッション無効化
        conversation.is_active = False
        await db.commit()
        return False
    return True
```

**判定ロジック**: `last_activity_at > now - timedelta(hours=24)`

#### 実際のコードベース

**問題点**: `is_session_valid()`関数は設計書に記載されていますが、**実際のコードベースには実装されていません**。

### 1.2 `last_activity_at`の更新タイミング

**エビデンス1**: チャットメッセージ送信時（`chat_service.py`）
```172:172:backend/app/services/chat_service.py
        conversation.last_activity_at = datetime.utcnow()
```

**エビデンス2**: 既存会話取得時（`chat_service.py`）
```250:250:backend/app/services/chat_service.py
            conversation.last_activity_at = datetime.utcnow()
```

**問題点**: ゲストが24時間以内に再アクセスすると、`last_activity_at`が更新され、実質的にセッション有効期限が延長されます。

### 1.3 Cookieの有効期限

**エビデンス3**: セッションID取得時（`useSession.ts`）
```31:44:frontend/src/composables/useSession.ts
  function getOrCreateSessionId(): string {
    let sessionId = cookies.get(SESSION_ID_COOKIE_NAME)

    if (!sessionId) {
      sessionId = generateUUID()
      cookies.set(SESSION_ID_COOKIE_NAME, sessionId, {
        expires: new Date(Date.now() + SESSION_ID_EXPIRES_DAYS * 24 * 60 * 60 * 1000),
        sameSite: 'lax',
        secure: import.meta.env.PROD
      })
      chatStore.setSessionId(sessionId)
    } else {
      chatStore.setSessionId(sessionId)
    }

    return sessionId
  }
```

**確認結果**: 既存のセッションIDがある場合、Cookieは再設定されません（延長されません）。

**エビデンス4**: セッション統合時（`useSession.ts`）
```72:76:frontend/src/composables/useSession.ts
        cookies.set(SESSION_ID_COOKIE_NAME, response.primary_session_id, {
          expires: new Date(Date.now() + SESSION_ID_EXPIRES_DAYS * 24 * 60 * 60 * 1000),
          sameSite: 'lax',
          secure: import.meta.env.PROD
        })
```

**確認結果**: セッション統合時のみCookieが再設定されます。

---

## 2. 問題の詳細分析

### 2.1 問題のシナリオ

1. **ゲストがQRコードを読み取り、セッション開始**
   - `started_at`: 2025-12-21 10:00:00
   - `last_activity_at`: 2025-12-21 10:00:00
   - Cookie有効期限: 2025-12-22 10:00:00（24時間後）

2. **23時間後に再アクセス（チェックアウト前）**
   - `last_activity_at`: 2025-12-22 09:00:00（更新）
   - Cookie有効期限: 2025-12-22 10:00:00（変更なし）

3. **設計書の`is_session_valid()`が実装されていた場合**
   - 判定: `last_activity_at (2025-12-22 09:00:00) > now (2025-12-22 09:00:00) - timedelta(hours=24)`
   - 結果: `2025-12-22 09:00:00 > 2025-12-21 09:00:00` → **有効**
   - **問題**: セッションが延長される

4. **チェックアウト後もアクセス可能**
   - チェックアウト時刻: 2025-12-22 11:00:00
   - セッション有効期限: 2025-12-23 09:00:00（`last_activity_at + 24時間`）
   - **問題**: チェックアウト後も22時間アクセス可能

### 2.2 現在の実装での問題

**現状**: `is_session_valid()`が実装されていないため、セッション有効期限の判定が行われていません。

**影響**:
- Cookieの有効期限は延長されない（既存セッションIDがある場合）
- ただし、バックエンドで`is_session_valid()`が実装されると、上記の問題が発生する可能性がある

---

## 3. 防止策の提案

### 3.1 防止策1: `started_at`ベースの固定有効期限（推奨）

**概要**: セッション開始時刻（`started_at`）から24時間後の固定有効期限を設定

**実装方法**:

1. **セッション有効期限の計算を変更**
   ```python
   # 現在（問題あり）
   if conversation.last_activity_at < now - timedelta(hours=24):
       return False
   
   # 修正後（推奨）
   session_expires_at = conversation.started_at + timedelta(hours=24)
   if now > session_expires_at:
       return False
   ```

2. **`is_session_valid()`関数の実装**
   ```python
   async def is_session_valid(
       session_id: str, 
       db: AsyncSession
   ) -> bool:
       """
       セッションが有効かチェック
       - 存在確認
       - started_atから24時間以内（固定有効期限）
       """
       result = await db.execute(
           select(Conversation).where(
               Conversation.session_id == session_id,
               Conversation.is_active == True
           )
       )
       conversation = result.scalar_one_or_none()
       
       if conversation is None:
           return False
       
       # started_atから24時間以内かチェック（固定有効期限）
       now = datetime.utcnow()
       session_expires_at = conversation.started_at + timedelta(hours=24)
       if now > session_expires_at:
           # セッション無効化
           conversation.is_active = False
           await db.commit()
           return False
       
       return True
   ```

**メリット**:
- ✅ セッション開始時刻から24時間の固定有効期限
- ✅ 再アクセスによる延長を防止
- ✅ 実装がシンプル

**デメリット**:
- ⚠️ チェックアウト時刻を考慮していない（別途対応が必要）

---

### 3.2 防止策2: `started_at`と`last_activity_at`の両方を考慮

**概要**: `started_at`から24時間以内、かつ`last_activity_at`から24時間以内の両方を満たす必要がある

**実装方法**:
```python
async def is_session_valid(
    session_id: str, 
    db: AsyncSession
) -> bool:
    """
    セッションが有効かチェック
    - 存在確認
    - started_atから24時間以内（固定有効期限）
    - last_activity_atから24時間以内（無動作判定）
    """
    result = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id,
            Conversation.is_active == True
        )
    )
    conversation = result.scalar_one_or_none()
    
    if conversation is None:
        return False
    
    now = datetime.utcnow()
    
    # 1. started_atから24時間以内（固定有効期限）
    session_expires_at = conversation.started_at + timedelta(hours=24)
    if now > session_expires_at:
        conversation.is_active = False
        await db.commit()
        return False
    
    # 2. last_activity_atから24時間以内（無動作判定）
    if conversation.last_activity_at < now - timedelta(hours=24):
        conversation.is_active = False
        await db.commit()
        return False
    
    return True
```

**メリット**:
- ✅ 固定有効期限と無動作判定の両方を実現
- ✅ 再アクセスによる延長を防止
- ✅ 無動作24時間で自動終了も実現

**デメリット**:
- ⚠️ チェックアウト時刻を考慮していない（別途対応が必要）

---

### 3.3 防止策3: チェックアウト時刻を考慮した有効期限（将来実装）

**概要**: 施設のチェックアウト時刻を考慮し、チェックアウト後はセッションを無効化

**実装方法**:
```python
async def is_session_valid(
    session_id: str, 
    facility_id: int,
    db: AsyncSession
) -> bool:
    """
    セッションが有効かチェック
    - 存在確認
    - started_atから24時間以内（固定有効期限）
    - チェックアウト時刻を過ぎていない
    """
    result = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id,
            Conversation.facility_id == facility_id,
            Conversation.is_active == True
        )
    )
    conversation = result.scalar_one_or_none()
    
    if conversation is None:
        return False
    
    now = datetime.utcnow()
    
    # 1. started_atから24時間以内（固定有効期限）
    session_expires_at = conversation.started_at + timedelta(hours=24)
    if now > session_expires_at:
        conversation.is_active = False
        await db.commit()
        return False
    
    # 2. チェックアウト時刻を過ぎていない（将来実装）
    facility = await db.get(Facility, facility_id)
    if facility and facility.check_out_time:
        # チェックアウト時刻の計算（施設のタイムゾーンを考慮）
        # 実装詳細は省略
        pass
    
    return True
```

**メリット**:
- ✅ チェックアウト後のアクセスを防止
- ✅ ビジネスロジックに適合

**デメリット**:
- ⚠️ 実装が複雑
- ⚠️ タイムゾーン処理が必要
- ⚠️ チェックイン/チェックアウト時刻の管理が必要

---

## 4. 推奨実装方針

### 4.1 短期対応（即座に実装可能）

**防止策1を実装**: `started_at`ベースの固定有効期限

**理由**:
1. 実装がシンプル
2. 再アクセスによる延長を確実に防止
3. 既存の設計思想（24時間有効期限）を維持

### 4.2 中期対応（Phase 2以降）

**防止策3を検討**: チェックアウト時刻を考慮した有効期限

**理由**:
1. ビジネスロジックに適合
2. チェックアウト後の不正アクセスを防止
3. 施設ごとの設定に対応可能

---

## 5. 実装チェックリスト

### 5.1 防止策1の実装

- [ ] `backend/app/utils/session.py`に`is_session_valid()`関数を実装
- [ ] `started_at`ベースの固定有効期限判定を実装
- [ ] セッション有効性チェックをチャットAPIに統合
- [ ] テストケースを作成・実行
- [ ] 設計書を更新

### 5.2 防止策3の実装（将来）

- [ ] 施設のチェックアウト時刻管理機能を実装
- [ ] タイムゾーン処理を実装
- [ ] チェックアウト時刻を考慮したセッション有効期限判定を実装
- [ ] テストケースを作成・実行
- [ ] 設計書を更新

---

## 6. 結論

### 6.1 問題の確認

✅ **問題確認**: 現状の実装では、24時間以内に再アクセスすると、`last_activity_at`が更新され、実質的にセッション有効期限が延長される可能性があります。

### 6.2 推奨対応

**即座に実装**: 防止策1（`started_at`ベースの固定有効期限）

**将来検討**: 防止策3（チェックアウト時刻を考慮した有効期限）

---

**調査完了日時**: 2025年12月21日



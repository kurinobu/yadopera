# やどぺら v0.3 アーキテクチャ設計書

**作成日**: 2025年11月21日  
**バージョン**: v0.3 (v0.2からのバージョンアップ)  
**対象**: やどぺら - 小規模宿泊施設向け外国人ゲスト対応自動化SaaS  
**ベース**: v0.2アーキテクチャ設計書 + v0.3要約定義書

---

## 変更履歴 v0.2 → v0.3

1. **市場規模・地域拡大戦略**: 段階的拡大計画明確化（Phase 2: 福岡・沖縄、Phase 3: 北海道・金沢）、潜在市場500-700施設
2. **PoC施設数最適化**: 5-7施設 → 3施設に絞り込み、品質重視
3. **FAQ自動学習機能MVP化**: 未解決質問からのFAQ追加機能をMVPに前倒し（ワンクリック追加、回答テンプレート自動生成）
4. **ゲストフィードバック機能**: 👍👎ボタン、低評価回答の自動ハイライト
5. **セッション統合トークン**: 4桁コードでデバイス間会話履歴を統合
6. **夜間対応設計**: 翌朝対応予約、自動返信、8:00一括通知
7. **信頼度スコア改善**: 質問具体性、過去解決率、フィードバック連動
8. **安全カテゴリ強制エスカレーション**: 医療・避難情報は閾値無視で即エスカレーション
9. **収益モデル多様化**: 従量課金プラン（¥1,980+¥30/質問）、セットアップ代行サービス（¥30,000〜）
10. **競合モニタリング体制**: 四半期レビュー制度化
11. **宿泊事業者向けFAQ＋AIサポート**: Phase 2で管理画面内AIヘルプチャット実装、PoC時は静的FAQ提供
12. **データ保持ポリシー詳細化**: GDPR準拠の3ヶ月自動削除バッチ処理

---

## 変更履歴 v0.1 → v0.2

1. **RAG（検索拡張生成）統合**: pgvectorによるFAQ検索、AI従量コスト¥0.033/質問
2. **エスカレーションモード切り替え**: スタッフシフト連動（通常0.7 / 早期0.85）
3. **認証・セッション詳細化**: パスワードリセット機能、Cookie保存、24時間有効期限
4. **UI/UX具体化**: ダークモード、PWA、スマホ最適化（375px-428px）
5. **エスカレーションスケジュール管理**: 時間帯・曜日・言語別の自動切り替え
6. **FAQ初期テンプレート**: 20-30件提供

---

## 目次

1. [システム概要](#1-システム概要)
2. [システムアーキテクチャ](#2-システムアーキテクチャ)
3. [FastAPI API構造図](#3-fastapi-api構造図)
4. [Vue.js ページ遷移図](#4-vuejs-ページ遷移図)
5. [UX/UIフロー図](#5-uxuiフロー図)
6. [ディレクトリ構造](#6-ディレクトリ構造)
7. [データベース設計（PoC版）](#7-データベース設計poc版)
8. [API設計](#8-api設計)
9. [APIレスポンス実装例（JSONスキーマ）](#9-apiレスポンス実装例jsonスキーマ)
10. [認証・セキュリティ](#10-認証セキュリティ)
11. [AI対話エンジン設計（RAG統合型）](#11-ai対話エンジン設計rag統合型)
12. [エスカレーション管理](#12-エスカレーション管理)
13. [エラーハンドリング](#13-エラーハンドリング)
14. [デプロイメント](#14-デプロイメント)
15. [パフォーマンス要件](#15-パフォーマンス要件)
16. [開発規約](#16-開発規約)

---

## 1. システム概要

### 1.1 システムの目的

小規模宿泊施設の外国人ゲスト対応を自動化し、フロント業務を70%自動化（MVP目標、Phase 2で85%+）する。

### 1.2 市場規模（参考）

**段階的地域拡大計画**

| フェーズ | 地域 | 推定施設数 | 累計潜在市場 |
|----------|------|-----------|-------------|
| Phase 1 | 京都・大阪・東京 | 100-150施設 | 100-150施設 |
| Phase 2 | +福岡・沖縄 | +80-120施設 | 180-270施設 |
| Phase 3 | +北海道・金沢・広島 | +100-150施設 | 280-420施設 |
| 長期 | 全国展開 | +200-300施設 | **500-700施設** |

- **月間質問数**: 100件/施設（想定）
- **やどびとネットワーク**: 実数200施設（初期営業チャネル）
- **施設タイプ**: ゲストハウス・ホステル（15-60床）
- **外国人ゲスト比率**: 30%以上
- **PoC施設数**: 3施設（品質重視、一人開発の現実的対応）

### 1.3 システム構成

```
┌─────────────────┐
│   ゲスト側UI    │ (Vue.js 3 + Tailwind CSS + PWA)
│  QRコード読取後  │ (ダークモード対応、スマホ最適化)
└────────┬────────┘
         │ HTTPS
         ↓
┌─────────────────┐
│   管理者側UI    │ (Vue.js 3 + Tailwind CSS)
│  施設管理画面   │
└────────┬────────┘
         │ HTTPS
         ↓
┌─────────────────────────────┐
│      FastAPI Backend        │
│  ┌─────────┬─────────────┐  │
│  │ REST API│  AI Engine  │  │
│  │ /api/v1/│  (RAG統合)  │  │
│  └─────────┴─────────────┘  │
└──────────┬──────────────────┘
           │
           ↓
┌─────────────────┐     ┌──────────────┐     ┌──────────────┐
│  PostgreSQL 15  │     │ OpenAI API   │     │    Redis     │
│  (pgvector拡張)  │     │ GPT-4o-mini  │     │  (セッション) │
│   (Render.com)  │     │ Embeddings   │     │   (キャッシュ)│
└─────────────────┘     └──────────────┘     └──────────────┘
```

### 1.4 技術スタック

| レイヤー | 技術 | バージョン |
|---------|------|-----------|
| Frontend | Vue.js | 3.4+ |
| TypeScript | TypeScript | 5.3+ |
| CSS Framework | Tailwind CSS | 3.4+ |
| HTTP Client | Axios | 1.6+ |
| PWA | Vite PWA Plugin | 0.19+ |
| Backend | FastAPI | 0.109+ |
| ORM | SQLAlchemy | 2.0+ (async対応) |
| Migration | Alembic | 1.13+ |
| Database | PostgreSQL | 15+ (pgvector拡張) |
| Cache/Session | Redis | 7.2+ |
| AI | OpenAI API | GPT-4o-mini, text-embedding-3-small |
| Vector Search | pgvector | 0.2+ |
| Hosting | Render.com | Pro Plan |
| Language | Python | 3.11+ |

### 1.5 v0.3の主要機能

**v0.2からの継続機能**
- **RAG統合型AI応答**: pgvectorによるFAQ検索でコスト48%削減（¥0.033/質問）
- **エスカレーションモード切り替え**: スタッフシフト連動（通常0.7 / 早期0.85）
- **セッション管理**: Cookie保存、24時間有効期限、複数デバイス対応
- **パスワードリセット**: メールベースのリセット機能
- **UI/UX改善**: ダークモード、PWA対応、スマホ最適化（375px-428px）
- **エスカレーションスケジュール**: 時間帯・曜日・言語別の自動切り替え

**v0.3新規機能**
- **FAQ自動学習機能**: 未解決質問からワンクリックでFAQ追加、回答テンプレート自動生成
- **ゲストフィードバック**: 👍👎ボタン、低評価回答の自動ハイライト
- **セッション統合トークン**: 4桁コードでデバイス間会話履歴を統合
- **夜間対応設計**: 翌朝対応予約、自動返信、8:00一括通知
- **信頼度スコア改善**: 質問具体性、過去解決率、フィードバック連動
- **安全カテゴリ強制エスカレーション**: 医療・避難情報は閾値無視で即エスカレーション
- **宿泊事業者向けFAQ＋AIサポート**: Phase 2で管理画面内AIヘルプチャット実装

---

## 2. システムアーキテクチャ

### 2.1 レイヤー構成

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│  ┌──────────────┐  ┌──────────────┐    │
│  │  Guest UI    │  │  Admin UI    │    │
│  │  (Vue.js 3)  │  │  (Vue.js 3)  │    │
│  │  PWA対応     │  │  TypeScript  │    │
│  │  ダークモード │  │              │    │
│  └──────────────┘  └──────────────┘    │
└─────────────────────────────────────────┘
                    ↓ HTTPS/REST
┌─────────────────────────────────────────┐
│          Application Layer              │
│  ┌────────────────────────────────┐    │
│  │      FastAPI Application       │    │
│  │  ┌──────────┐  ┌────────────┐ │    │
│  │  │ Routers  │  │ Middleware │ │    │
│  │  │ /api/v1/ │  │ (CORS/JWT) │ │    │
│  │  └──────────┘  └────────────┘ │    │
│  └────────────────────────────────┘    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│           Business Layer                │
│  ┌──────────┐  ┌──────────────────┐    │
│  │ Services │  │  AI Chat Engine   │    │
│  │          │  │  (RAG統合型)      │    │
│  │          │  │  - Embeddings     │    │
│  │          │  │  - Vector Search  │    │
│  │          │  │  - GPT-4o-mini    │    │
│  └──────────┘  └──────────────────┘    │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│          Data Access Layer              │
│  ┌────────────┐  ┌─────────────────┐   │
│  │ Repository │  │  SQLAlchemy ORM  │   │
│  │            │  │  (async対応)     │   │
│  └────────────┘  └─────────────────┘   │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│         Database / External APIs        │
│  ┌──────────────┐  ┌────────────────┐  │
│  │ PostgreSQL   │  │  OpenAI API    │  │
│  │ (pgvector)   │  │  GPT-4o-mini   │  │
│  │              │  │  Embeddings    │  │
│  └──────────────┘  └────────────────┘  │
│  ┌──────────────┐                        │
│  │    Redis     │                        │
│  │ (セッション/  │                        │
│  │  キャッシュ)  │                        │
│  └──────────────┘                        │
└─────────────────────────────────────────┘
```

### 2.2 データフロー（RAG統合型）

#### ゲスト質問 → AI応答フロー（v0.3）

```
┌──────┐
│ Guest│
└───┬──┘
    │ 1. QRコード読取
    │    /f/{facility_id}?location={location}&token={session_token}
    │    ★v0.3: セッション統合トークン対応
    ↓
┌───────────────┐
│ Vue.js (Guest)│
│ PWA対応       │
└───┬───────────┘
    │ 2. POST /api/v1/chat
    │    SessionID: Cookie保存
    │    SessionToken: 4桁コード（統合用）
    ↓
┌───────────────────┐
│ FastAPI Router    │
│ /api/v1/chat      │
└───┬───────────────┘
    │ 3. ChatService.process_message()
    ↓
┌───────────────────────────────────┐
│ RAG統合型 AI Chat Engine (v0.3)    │
│                                   │
│ ┌──────────────────────────────┐ │
│ │ Step 0: 安全カテゴリ判定★新規│ │
│ │ - 医療関連キーワード検出      │ │
│ │ - 安全・避難関連キーワード    │ │
│ │ → 即エスカレーション（閾値無視）│ │
│ └──────────┬───────────────────┘ │
│            ↓ (通常質問のみ)        │
│ ┌──────────────────────────────┐ │
│ │ Step 1: 埋め込みベクトル生成  │ │
│ │ OpenAI Embeddings API        │ │
│ │ (text-embedding-3-small)    │ │
│ └──────────┬───────────────────┘ │
│            ↓                      │
│ ┌──────────────────────────────┐ │
│ │ Step 2: pgvector検索         │ │
│ │ コサイン類似度、Top 3取得     │ │
│ │ IVFFlatインデックス使用      │ │
│ └──────────┬───────────────────┘ │
│            ↓                      │
│ ┌──────────────────────────────┐ │
│ │ Step 3: コンテキスト構築      │ │
│ │ - 関連FAQ Top 3: 300トークン  │ │
│ │ - 施設基本情報: 150トークン   │ │
│ │ - システムプロンプト: 100     │ │
│ │ - ゲスト質問: 50トークン      │ │
│ │ 合計: 約600トークン           │ │
│ └──────────┬───────────────────┘ │
│            ↓                      │
│ ┌──────────────────────────────┐ │
│ │ Step 4: GPT-4o-mini応答生成  │ │
│ │ 最大200トークン出力           │ │
│ └──────────┬───────────────────┘ │
│            ↓                      │
│ ┌──────────────────────────────┐ │
│ │ Step 5: 信頼度スコア計算★改善│ │
│ │ - FAQ類似度ボーナス(+0.3)    │ │
│ │ - 回答長ペナルティ(-0.2)     │ │
│ │ - 不確実性ワード検出(-0.15)  │ │
│ │ - 質問具体性スコア(+0.1)★新規│ │
│ │ - 過去解決率(+0.15)★新規     │ │
│ │ - 施設カスタムFAQ(+0.2)★新規│ │
│ └──────────┬───────────────────┘ │
│            ↓                      │
│ ┌──────────────────────────────┐ │
│ │ Step 6: エスカレーション判定  │ │
│ │ - 通常モード: < 0.7          │ │
│ │ - 早期モード: < 0.85         │ │
│ │ - 安全カテゴリ: 即エスカレ★新規│ │
│ │ - 緊急キーワード検出          │ │
│ │ - スケジュール連動判定        │ │
│ └──────────┬───────────────────┘ │
└────────────┼───────────────────────┘
             │
             ↓
    ┌────────────────┐
    │ PostgreSQL     │
    │ - messages保存 │
    │ - 信頼度記録   │
    └────────────────┘
             │
             ↓
    ┌────────────────┐
    │ Redis          │
    │ - セッション   │
    │ - キャッシュ   │
    └────────────────┘
             │
             ↓
┌───────────────┐
│ Vue.js (Guest)│
│ Display answer│
│ ダークモード  │
│ ★v0.3: フィードバック👍👎表示│
└───────┬───────┘
        │
        ↓ (ゲストがフィードバック送信)
┌──────────────────────────────┐
│ POST /api/v1/chat/feedback   │
│ - message_id                 │
│ - feedback_type: positive/negative│
└──────────┬───────────────────┘
           ↓
┌──────────────────────────────┐
│ guest_feedback テーブル保存   │
│ ★v0.3: 低評価回答の自動ハイライト│
└──────────────────────────────┘
```

#### 夜間対応フロー（v0.3新規）

```
エスカレーション発生（22:00-8:00）
    ↓
┌──────────────────────────────┐
│ 自動返信メッセージ送信        │
│ - 英語/日本語対応             │
│ - 翌朝9:00まで対応予約        │
│ - 緊急時119/110案内           │
└──────────┬───────────────────┘
           ↓
┌──────────────────────────────┐
│ overnight_queue テーブル保存   │
│ - scheduled_notify_at: 8:00   │
│ - escalation_id 紐付け       │
└──────────┬───────────────────┘
           ↓
┌──────────────────────────────┐
│ 翌朝8:00 バッチ処理            │
│ - スタッフへ一括通知           │
│ - メール/Slack通知            │
└──────────────────────────────┘
```

### 2.3 コスト効率（RAG統合による改善）

**v0.1（従来方式）**
- 1質問あたり: 約¥0.064
- プロンプト: 約1,200トークン（全FAQ含む）

**v0.2（RAG統合型）**
- 1質問あたり: **¥0.033**（48%削減）
  - Input: 600トークン × $0.15/1M = $0.00009
  - Output: 200トークン × $0.60/1M = $0.00012
  - 合計: $0.00021 × ¥155 = ¥0.033
- 月100件/施設: ¥3.3/月
- 従来比48%削減

---

## 3. FastAPI API構造図

### 3.1 APIルーター構造

```
FastAPI Application (app/main.py)
│
├── /api/v1/ (APIRouter)
│   │
│   ├── /auth (認証系)
│   │   ├── POST /login
│   │   ├── POST /logout
│   │   ├── POST /password-reset
│   │   └── POST /password-reset/confirm
│   │
│   ├── /facility (施設情報 - 公開)
│   │   └── GET /{slug}
│   │
│   ├── /chat (ゲスト会話系)
│   │   ├── POST / (メッセージ送信)
│   │   └── GET /history/{session_id}
│   │
│   └── /admin (管理系 - JWT必須)
│       ├── /dashboard
│       │   └── GET / (ダッシュボードデータ)
│       │
│       ├── /faqs
│       │   ├── GET / (FAQ一覧)
│       │   ├── POST / (FAQ作成)
│       │   ├── PUT /{faq_id} (FAQ更新)
│       │   └── DELETE /{faq_id} (FAQ削除)
│       │
│       ├── /escalations
│       │   ├── GET / (エスカレーション一覧)
│       │   └── PUT /{escalation_id} (解決処理)
│       │
│       ├── /qr-code
│       │   └── POST / (QRコード生成)
│       │
│       └── /escalation-schedule
│           ├── GET / (スケジュール一覧)
│           ├── POST / (スケジュール作成)
│           └── PUT /{schedule_id} (スケジュール更新)
```

### 3.2 APIエンドポイント詳細構造

#### 認証系 (`/api/v1/auth`)

```
POST /api/v1/auth/login
├── Request Body
│   ├── email: string
│   └── password: string
├── Response (200 OK)
│   ├── access_token: string (JWT, 7日間有効)
│   ├── refresh_token: string (JWT, 30日間有効)
│   ├── token_type: "bearer"
│   └── user: { id, email, full_name }
└── Error Responses
    ├── 401: Invalid credentials
    └── 429: Rate limit exceeded

POST /api/v1/auth/logout
├── Headers
│   └── Authorization: Bearer {access_token}
└── Response (200 OK)
    └── message: "Logged out successfully"

POST /api/v1/auth/password-reset
├── Request Body
│   └── email: string
├── Response (200 OK)
│   └── message: "Password reset email sent"
└── Process
    ├── リセットトークン生成（有効期限1時間）
    ├── メール送信
    └── password_resetsテーブルに保存

POST /api/v1/auth/password-reset/confirm
├── Request Body
│   ├── token: string
│   └── new_password: string
├── Response (200 OK)
│   └── message: "Password reset successfully"
└── Error Responses
    ├── 400: Invalid or expired token
    └── 422: Password validation error
```

#### ゲスト系 (`/api/v1/facility`, `/api/v1/chat`)

```
GET /api/v1/facility/{slug}
├── Path Parameters
│   └── slug: string (施設のURL用識別子)
├── Query Parameters
│   └── location: string (optional, "entrance" | "room" | "kitchen" | "lounge")
├── Response (200 OK)
│   ├── facility: {
│   │   ├── id, name, email, phone
│   │   ├── check_in_time, check_out_time
│   │   └── wifi_ssid (パスワードは非公開)
│   │   }
│   └── top_questions: string[] (よくある質問TOP3)
└── Error Responses
    └── 404: Facility not found

POST /api/v1/chat
├── Headers
│   └── Cookie: tabipera_session={session_id} (optional, 初回は不要)
├── Request Body
│   ├── facility_id: string (UUID)
│   ├── message: string
│   ├── language: string (default: "en")
│   └── location: string (optional)
├── Response (200 OK)
│   ├── message_id: string (UUID)
│   ├── session_id: string (UUID, Cookieに保存)
│   ├── response: string (AI回答)
│   ├── ai_confidence: float (0.0-1.0)
│   ├── source: "rag_generated" | "escalation_needed"
│   ├── matched_faq_ids: integer[] (使用したFAQ ID)
│   ├── response_time_ms: integer
│   └── escalation: {
│       ├── needed: boolean
│       ├── mode: "normal" | "early"
│       └── reason: string (optional)
│       }
└── Process (RAG統合型)
    ├── 1. セッション取得/作成
    ├── 2. 埋め込みベクトル生成
    ├── 3. pgvectorでFAQ検索（Top 3）
    ├── 4. GPT-4o-miniで回答生成
    ├── 5. 信頼度スコア計算
    ├── 6. エスカレーション判定
    └── 7. レスポンス返却

GET /api/v1/chat/history/{session_id}
├── Path Parameters
│   └── session_id: string (UUID)
├── Response (200 OK)
│   └── messages: [
│       ├── { role: "user" | "assistant", content: string, created_at: timestamp }
│       └── ...
│       ]
└── Error Responses
    └── 404: Session not found
```

#### 管理系 (`/api/v1/admin/*`)

```
GET /api/v1/admin/dashboard
├── Headers
│   └── Authorization: Bearer {access_token}
├── Query Parameters
│   └── period: string (optional, "week" | "month", default: "week")
├── Response (200 OK)
│   ├── period: { start: timestamp, end: timestamp }
│   ├── total_questions: integer
│   ├── auto_response_rate: float (0.0-1.0)
│   ├── average_response_time_ms: integer
│   ├── category_breakdown: {
│   │   ├── basic: integer
│   │   ├── facilities: integer
│   │   ├── location: integer
│   │   └── trouble: integer
│   │   }
│   ├── top_questions: [{ question: string, count: integer }]
│   ├── recent_conversations: [
│   │   ├── { session_id, guest_language, last_message, ai_confidence, created_at }
│   │   └── ...
│   │   ]
│   └── unresolved_count: integer
└── Error Responses
    └── 401: Unauthorized

GET /api/v1/admin/faqs
├── Headers
│   └── Authorization: Bearer {access_token}
├── Query Parameters
│   └── category: string (optional, "basic" | "facilities" | "location" | "trouble")
├── Response (200 OK)
│   └── faqs: [
│       ├── {
│       │   ├── id, facility_id, category
│       │   ├── question, answer
│       │   ├── priority, is_active
│       │   └── created_at, updated_at
│       │   }
│       └── ...
│       ]

POST /api/v1/admin/faqs
├── Headers
│   └── Authorization: Bearer {access_token}
├── Request Body
│   ├── question: string (200文字以内推奨)
│   ├── answer: string (200文字以内推奨)
│   ├── category: "basic" | "facilities" | "location" | "trouble"
│   └── priority: integer (1-5, default: 1)
├── Response (201 Created)
│   └── faq: { id, question, answer, category, priority, ... }
└── Process
    ├── FAQ保存
    ├── 埋め込みベクトル自動生成（OpenAI Embeddings）
    └── pgvectorに保存

PUT /api/v1/admin/faqs/{faq_id}
├── Headers
│   └── Authorization: Bearer {access_token}
├── Path Parameters
│   └── faq_id: integer
├── Request Body
│   └── (question, answer, category, priority, is_active の任意の組み合わせ)
└── Response (200 OK)
    └── faq: { ... }

DELETE /api/v1/admin/faqs/{faq_id}
├── Headers
│   └── Authorization: Bearer {access_token}
├── Path Parameters
│   └── faq_id: integer
└── Response (204 No Content)

GET /api/v1/admin/escalations
├── Headers
│   └── Authorization: Bearer {access_token}
├── Query Parameters
│   ├── resolved: boolean (optional, default: false)
│   └── limit: integer (optional, default: 20)
├── Response (200 OK)
│   └── escalations: [
│       ├── {
│       │   ├── id, conversation_id
│       │   ├── trigger_type: "low_confidence" | "keyword" | "multiple_turns" | "staff_mode"
│       │   ├── ai_confidence, escalation_mode
│       │   ├── question, language
│       │   ├── notified_at, resolved_at
│       │   └── resolution_notes
│       │   }
│       └── ...
│       ]

PUT /api/v1/admin/escalations/{escalation_id}
├── Headers
│   └── Authorization: Bearer {access_token}
├── Path Parameters
│   └── escalation_id: integer
├── Request Body
│   ├── resolved: boolean
│   └── resolution_notes: string (optional)
└── Response (200 OK)
    └── escalation: { ... }

POST /api/v1/admin/qr-code
├── Headers
│   └── Authorization: Bearer {access_token}
├── Request Body
│   ├── location: "entrance" | "room" | "kitchen" | "lounge" | "custom"
│   └── custom_location_name: string (optional, location="custom"の場合)
├── Response (201 Created)
│   ├── qr_code_id: integer
│   ├── url: string (https://yadopera.com/f/{facility_id}?location={location})
│   ├── download_url: string (PDF/PNG/SVG)
│   └── file_path: string (S3保存先)
└── Process
    ├── QRコード生成
    ├── S3にアップロード
    └── qr_codesテーブルに保存

GET /api/v1/admin/escalation-schedule
├── Headers
│   └── Authorization: Bearer {access_token}
├── Response (200 OK)
│   └── schedules: [
│       ├── {
│       │   ├── id, facility_id
│       │   ├── day_of_week: string[] | ["all"]
│       │   ├── time_start: time, time_end: time
│       │   ├── mode: "normal" | "early"
│       │   ├── threshold: float (0.7 or 0.85)
│       │   ├── languages: string[]
│       │   ├── notify_channels: string[]
│       │   └── is_active: boolean
│       │   }
│       └── ...
│       ]

POST /api/v1/admin/escalation-schedule
├── Headers
│   └── Authorization: Bearer {access_token}
├── Request Body
│   ├── day_of_week: string[] | ["all"]
│   ├── time_start: string (HH:MM)
│   ├── time_end: string (HH:MM)
│   ├── mode: "normal" | "early"
│   ├── threshold: float (0.7 or 0.85)
│   ├── languages: string[]
│   └── notify_channels: string[] (["email"] | ["email", "slack"])
└── Response (201 Created)
    └── schedule: { id, ... }

PUT /api/v1/admin/escalation-schedule/{schedule_id}
├── Headers
│   └── Authorization: Bearer {access_token}
├── Path Parameters
│   └── schedule_id: integer
├── Request Body
│   └── (任意のフィールドの組み合わせ)
└── Response (200 OK)
    └── schedule: { ... }
```

### 3.3 ミドルウェア・依存性注入

```
FastAPI Middleware Stack
│
├── CORS Middleware
│   ├── allow_origins: ["https://yadopera.com", "https://admin.yadopera.com"]
│   ├── allow_credentials: true
│   └── allow_methods: ["GET", "POST", "PUT", "DELETE"]
│
├── Rate Limiting Middleware (slowapi)
│   ├── /api/v1/chat: 60 requests/minute
│   ├── /api/v1/auth/login: 5 requests/minute
│   └── /api/v1/auth/password-reset: 3 requests/hour
│
└── JWT Authentication (python-jose)
    ├── Access Token: 7日間有効
    ├── Refresh Token: 30日間有効
    └── Algorithm: HS256

Dependency Injection
│
├── get_db() → Database Session
│   └── SQLAlchemy async session
│
├── get_current_user() → User Object
│   └── JWT検証 → User取得
│
└── get_current_facility() → Facility Object
    └── User → Facility取得
```

### 3.4 エラーレスポンス構造

```
標準エラーフォーマット
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable error message",
    "details": {
      "field": "Additional context"
    }
  }
}

エラーコード一覧
├── 400: INVALID_REQUEST
├── 401: UNAUTHORIZED
├── 403: FORBIDDEN
├── 404: NOT_FOUND
├── 422: VALIDATION_ERROR
├── 429: RATE_LIMIT_EXCEEDED
├── 500: INTERNAL_ERROR
└── 503: SERVICE_UNAVAILABLE (OpenAI API障害時)
```

---

## 4. Vue.js ページ遷移図

### 4.1 ゲスト側ページ遷移（SPA）

```
┌─────────────────────────────────────────┐
│  Route: /f/:facility_slug               │
│  Component: GuestLayout.vue             │
│  (PWA対応、ダークモード切替可能)          │
└───────────────┬─────────────────────────┘
                │
                ├─→ /f/:facility_slug/language
                │   Component: LanguageSelect.vue
                │   ├─ 言語選択（英語のみ、MVP）
                │   └─ ダークモード切替ボタン
                │
                ├─→ /f/:facility_slug/welcome
                │   Component: Welcome.vue
                │   ├─ 施設名表示
                │   ├─ よくある質問TOP3
                │   ├─ フリー入力欄
                │   ├─ 緊急連絡先
                │   └─ ダークモード切替
                │
                └─→ /f/:facility_slug/chat
                    Component: Chat.vue
                    ├─ チャット履歴表示
                    ├─ メッセージ入力欄（固定フッター）
                    ├─ エスカレーションボタン
                    ├─ ダークモード切替
                    └─ PWAインストールプロンプト
```

#### ゲスト側ルーティング詳細

```javascript
// router/guest.js
const routes = [
  {
    path: '/f/:facility_slug',
    component: GuestLayout,
    children: [
      {
        path: '',
        redirect: (to) => `/f/${to.params.facility_slug}/language`
      },
      {
        path: 'language',
        name: 'GuestLanguageSelect',
        component: () => import('@/views/guest/LanguageSelect.vue'),
        meta: { title: 'Select Language' }
      },
      {
        path: 'welcome',
        name: 'GuestWelcome',
        component: () => import('@/views/guest/Welcome.vue'),
        meta: { title: 'Welcome' },
        beforeEnter: (to, from, next) => {
          // セッション確認（Cookie）
          const sessionId = Cookies.get('tabipera_session');
          if (!sessionId) {
            // セッション作成
            createSession(to.params.facility_slug, to.query.location);
          }
          next();
        }
      },
      {
        path: 'chat',
        name: 'GuestChat',
        component: () => import('@/views/guest/Chat.vue'),
        meta: { title: 'Chat', requiresSession: true },
        beforeEnter: (to, from, next) => {
          // セッション有効性チェック（24時間）
          const sessionId = Cookies.get('tabipera_session');
          if (!sessionId || !isSessionValid(sessionId)) {
            next({ name: 'GuestWelcome' });
          } else {
            next();
          }
        }
      }
    ]
  }
];
```

### 4.2 管理側ページ遷移（SPA）

```
┌─────────────────────────────────────────┐
│  Route: /admin                           │
│  Component: AdminLayout.vue             │
│  (サイドバー、ヘッダー、ダークモード)      │
└───────────────┬─────────────────────────┘
                │
                ├─→ /admin/login
                │   Component: Login.vue
                │   ├─ メール/パスワード入力
                │   └─ 「パスワードを忘れた場合」リンク
                │
                ├─→ /admin/password-reset
                │   Component: PasswordResetRequest.vue
                │   └─ メールアドレス入力
                │
                ├─→ /admin/password-reset/confirm
                │   Component: PasswordResetConfirm.vue
                │   ├─ トークン検証
                │   └─ 新パスワード入力
                │
                ├─→ /admin/dashboard (認証必須)
                │   Component: Dashboard.vue
                │   ├─ 週次サマリー
                │   ├─ リアルタイムチャット履歴（ポーリング）
                │   ├─ 未解決質問リスト
                │   └─ カテゴリ別円グラフ
                │
                ├─→ /admin/faqs (認証必須)
                │   Component: FaqManagement.vue
                │   ├─ FAQ一覧（カテゴリ別）
                │   ├─ FAQ追加モーダル
                │   ├─ FAQ編集モーダル
                │   └─ 埋め込みベクトル自動生成（保存時）
                │
                ├─→ /admin/facility (認証必須)
                │   Component: FacilitySettings.vue
                │   ├─ 基本情報編集
                │   ├─ WiFi設定（暗号化保存）
                │   ├─ チェックイン/アウト時間
                │   └─ 館内ルール・周辺情報
                │
                ├─→ /admin/escalations (認証必須)
                │   Component: EscalationManagement.vue
                │   ├─ 未解決エスカレーション一覧
                │   ├─ 解決処理
                │   └─ 解決メモ入力
                │
                ├─→ /admin/escalation-schedule (認証必須)
                │   Component: EscalationSchedule.vue
                │   ├─ スケジュール一覧
                │   ├─ 新規スケジュール作成
                │   ├─ スケジュール編集
                │   └─ 時間帯・曜日・言語・モード設定
                │
                ├─→ /admin/qr-code (認証必須)
                │   Component: QRCodeGenerator.vue
                │   ├─ QRコード一覧
                │   ├─ 新規QRコード生成
                │   ├─ 設置場所選択
                │   └─ PDF/PNG/SVGダウンロード
                │
                └─→ /admin/conversations (認証必須)
                    Component: ConversationHistory.vue
                    ├─ 会話履歴一覧
                    ├─ 会話詳細表示
                    └─ フィルタリング（日付、言語、カテゴリ）
```

#### 管理側ルーティング詳細

```javascript
// router/admin.js
const routes = [
  {
    path: '/admin',
    component: AdminLayout,
    meta: { requiresAuth: false },
    children: [
      {
        path: 'login',
        name: 'AdminLogin',
        component: () => import('@/views/admin/Login.vue'),
        meta: { title: 'Login', guestOnly: true }
      },
      {
        path: 'password-reset',
        name: 'PasswordResetRequest',
        component: () => import('@/views/admin/PasswordResetRequest.vue'),
        meta: { title: 'Password Reset', guestOnly: true }
      },
      {
        path: 'password-reset/confirm',
        name: 'PasswordResetConfirm',
        component: () => import('@/views/admin/PasswordResetConfirm.vue'),
        meta: { title: 'Set New Password', guestOnly: true }
      },
      {
        path: 'dashboard',
        name: 'AdminDashboard',
        component: () => import('@/views/admin/Dashboard.vue'),
        meta: { title: 'Dashboard', requiresAuth: true }
      },
      {
        path: 'faqs',
        name: 'AdminFaqs',
        component: () => import('@/views/admin/FaqManagement.vue'),
        meta: { title: 'FAQ Management', requiresAuth: true }
      },
      {
        path: 'facility',
        name: 'AdminFacility',
        component: () => import('@/views/admin/FacilitySettings.vue'),
        meta: { title: 'Facility Settings', requiresAuth: true }
      },
      {
        path: 'escalations',
        name: 'AdminEscalations',
        component: () => import('@/views/admin/EscalationManagement.vue'),
        meta: { title: 'Escalations', requiresAuth: true }
      },
      {
        path: 'escalation-schedule',
        name: 'AdminEscalationSchedule',
        component: () => import('@/views/admin/EscalationSchedule.vue'),
        meta: { title: 'Escalation Schedule', requiresAuth: true }
      },
      {
        path: 'qr-code',
        name: 'AdminQRCode',
        component: () => import('@/views/admin/QRCodeGenerator.vue'),
        meta: { title: 'QR Code Generator', requiresAuth: true }
      },
      {
        path: 'conversations',
        name: 'AdminConversations',
        component: () => import('@/views/admin/ConversationHistory.vue'),
        meta: { title: 'Conversation History', requiresAuth: true }
      }
    ]
  }
];

// ナビゲーションガード
router.beforeEach((to, from, next) => {
  const isAuthenticated = store.getters['auth/isAuthenticated'];
  const requiresAuth = to.matched.some(record => record.meta.requiresAuth);
  const guestOnly = to.matched.some(record => record.meta.guestOnly);

  if (requiresAuth && !isAuthenticated) {
    next({ name: 'AdminLogin' });
  } else if (guestOnly && isAuthenticated) {
    next({ name: 'AdminDashboard' });
  } else {
    next();
  }
});
```

### 4.3 ページ遷移フロー図

#### ゲスト側フロー

```
QRコード読み取り
    ↓
/f/:facility_slug?location=entrance
    ↓
LanguageSelect.vue
    ├─ 言語選択（英語）
    └─ ダークモード切替
    ↓
Welcome.vue
    ├─ セッション作成（Cookie保存）
    ├─ よくある質問TOP3表示
    ├─ フリー入力欄
    └─ 「Ask anything」クリック
    ↓
Chat.vue
    ├─ セッションID確認（Cookie）
    ├─ チャット履歴表示
    ├─ メッセージ送信（POST /api/v1/chat）
    ├─ AI回答表示（RAG統合型）
    ├─ 信頼度スコア表示（オプション）
    ├─ エスカレーションボタン（信頼度 < 閾値）
    └─ 24時間セッション有効期限管理
```

#### 管理側フロー

```
/admin/login
    ├─ メール/パスワード入力
    ├─ 「パスワードを忘れた場合」クリック
    │   └─ /admin/password-reset
    │       └─ メール送信
    │           └─ メール内リンククリック
    │               └─ /admin/password-reset/confirm?token=xxx
    │                   └─ 新パスワード設定
    └─ ログイン成功
        ↓
/admin/dashboard
    ├─ JWT保存（localStorage）
    ├─ 週次サマリー表示（ポーリング）
    ├─ リアルタイムチャット履歴
    └─ サイドバーメニュー
        ├─ FAQ管理 → /admin/faqs
        ├─ 施設設定 → /admin/facility
        ├─ エスカレーション → /admin/escalations
        ├─ エスカレーションスケジュール → /admin/escalation-schedule
        ├─ QRコード → /admin/qr-code
        └─ 会話履歴 → /admin/conversations
```

### 4.4 コンポーネント階層構造

```
ゲスト側
├── GuestLayout.vue
│   ├── DarkModeToggle.vue
│   ├── PWAInstallPrompt.vue
│   └── <router-view />
│
├── LanguageSelect.vue
│   └── LanguageCard.vue
│
├── Welcome.vue
│   ├── FacilityHeader.vue
│   ├── TopQuestions.vue
│   ├── MessageInput.vue
│   └── EmergencyContact.vue
│
└── Chat.vue
    ├── ChatMessageList.vue
    │   └── ChatMessage.vue (user/assistant)
    ├── MessageInput.vue (固定フッター)
    ├── EscalationButton.vue
    └── ConfidenceIndicator.vue (オプション)

管理側
├── AdminLayout.vue
│   ├── Sidebar.vue
│   │   └── NavItem.vue
│   ├── Header.vue
│   │   ├── UserMenu.vue
│   │   └── DarkModeToggle.vue
│   └── <router-view />
│
├── Login.vue
│   └── LoginForm.vue
│
├── PasswordResetRequest.vue
│   └── ResetForm.vue
│
├── PasswordResetConfirm.vue
│   └── NewPasswordForm.vue
│
├── Dashboard.vue
│   ├── WeeklySummary.vue
│   │   └── CategoryChart.vue
│   ├── RecentConversations.vue
│   └── UnresolvedList.vue
│
├── FaqManagement.vue
│   ├── FaqList.vue
│   │   └── FaqItem.vue
│   ├── FaqModal.vue (追加/編集)
│   └── CategoryFilter.vue
│
├── FacilitySettings.vue
│   ├── BasicInfoForm.vue
│   ├── WiFiSettingsForm.vue
│   └── RulesInfoForm.vue
│
├── EscalationManagement.vue
│   ├── EscalationList.vue
│   │   └── EscalationItem.vue
│   └── ResolutionModal.vue
│
├── EscalationSchedule.vue
│   ├── ScheduleList.vue
│   │   └── ScheduleItem.vue
│   └── ScheduleModal.vue (追加/編集)
│
├── QRCodeGenerator.vue
│   ├── QRCodeList.vue
│   │   └── QRCodeItem.vue
│   └── QRCodeModal.vue
│
└── ConversationHistory.vue
    ├── ConversationList.vue
    │   └── ConversationItem.vue
    ├── ConversationDetail.vue
    └── FilterPanel.vue
```

### 4.5 状態管理（Pinia）

```javascript
// stores/auth.js
export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    accessToken: null,
    refreshToken: null,
    isAuthenticated: false
  }),
  actions: {
    async login(email, password) { ... },
    async logout() { ... },
    async refreshAccessToken() { ... },
    async requestPasswordReset(email) { ... },
    async confirmPasswordReset(token, newPassword) { ... }
  }
});

// stores/chat.js (ゲスト側)
export const useChatStore = defineStore('chat', {
  state: () => ({
    sessionId: null,
    messages: [],
    facility: null,
    isDarkMode: false
  }),
  actions: {
    async createSession(facilitySlug, location) { ... },
    async sendMessage(message) { ... },
    async loadHistory() { ... },
    toggleDarkMode() { ... }
  }
});

// stores/dashboard.js (管理側)
export const useDashboardStore = defineStore('dashboard', {
  state: () => ({
    weeklyStats: null,
    recentConversations: [],
    unresolvedCount: 0,
    isPolling: false
  }),
  actions: {
    async fetchWeeklyStats() { ... },
    async startPolling() { ... },
    stopPolling() { ... }
  }
});
```

### 4.6 PWA対応

```javascript
// vite.config.js
import { VitePWA } from 'vite-plugin-pwa';

export default {
  plugins: [
    VitePWA({
      registerType: 'autoUpdate',
      workbox: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg}']
      },
      manifest: {
        name: 'やどぺら',
        short_name: 'やどぺら',
        description: '小規模宿泊施設向け外国人ゲスト対応自動化',
        theme_color: '#ffffff',
        icons: [
          {
            src: 'pwa-192x192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'pwa-512x512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      }
    })
  ]
};
```

---

## 5. UX/UIフロー図

### 5.1 ゲスト側フロー（v0.3）

```
┌─────────────────────────────────────┐
│  QRコード掲示                        │
│  (entrance/room/kitchen/lounge)     │
│  📱 Scan for assistance             │
└────────┬────────────────────────────┘
         │ スマホで読取
         │ /f/{facility_slug}?location=entrance
         ↓
┌─────────────────────────────────────────┐
│   言語選択画面 (LanguageSelect.vue)      │
│  ┌───────────────────────────────────┐  │
│  │  🌙 [ダークモード切替]            │  │
│  │                                   │  │
│  │  Select your language:           │  │
│  │  ┌─────────────────────────────┐ │  │
│  │  │  🇬🇧 English (MVP)           │ │  │
│  │  │  🇹🇼 繁体中文 (Phase 2)     │ │  │
│  │  │  🇫🇷 Français (Phase 3)     │ │  │
│  │  └─────────────────────────────┘ │  │
│  │                                   │  │
│  │  [PWAインストールプロンプト]      │  │
│  └───────────────────────────────────┘  │
└────────┬────────────────────────────────┘
         │ タップ
         ↓
┌─────────────────────────────────────────┐
│  ウェルカム画面 (Welcome.vue)            │
│  ┌───────────────────────────────────┐  │
│  │  🌙 [ダークモード切替]            │  │
│  │                                   │  │
│  │  👋 Welcome to [宿名]!           │  │
│  │                                   │  │
│  │  📋 よくある質問 TOP3             │  │
│  │  • What is the WiFi password?    │  │
│  │  • What time is check-in?        │  │
│  │  • Where is the nearest station? │  │
│  │                                   │  │
│  │  ┌─────────────────────────────┐ │  │
│  │  │ 💬 Ask anything!            │ │  │
│  │  │ [Type your question...]     │ │  │
│  │  └─────────────────────────────┘ │  │
│  │                                   │  │
│  │  🆘 Emergency: [電話番号]        │  │
│  │                                   │  │
│  │  [セッション作成: Cookie保存]     │  │
│  │  [セッション統合トークン: AB12]★v0.3│  │
│  │  (画面上部に常時表示)              │  │
│  └───────────────────────────────────┘  │
└────────┬────────────────────────────────┘
         │ 質問入力 or TOP3クリック
         ↓
┌─────────────────────────────────────────┐
│  チャットインターフェース (Chat.vue)      │
│  ┌───────────────────────────────────┐  │
│  │  🌙 [ダークモード切替]            │  │
│  │  🔗 Session: AB12 ★v0.3新規      │  │
│  │                                   │  │
│  │  Guest: Where is the laundry     │  │
│  │         room?                    │  │
│  │                                   │  │
│  │  Bot:  The laundry room is       │  │
│  │        located on the 2nd floor, │  │
│  │        next to the kitchen.      │  │
│  │        It's available 24/7.     │  │
│  │        [信頼度: 0.92]            │  │
│  │        [3秒以内応答]              │  │
│  │        👍 👎 ★v0.3新規          │  │
│  │        (役に立ちましたか？)        │  │
│  │                                   │  │
│  │  ┌─────────────────────────────┐ │  │
│  │  │ Type your message...        │ │  │
│  │  │ [Send]                      │ │  │
│  │  └─────────────────────────────┘ │  │
│  │  (固定フッター)                   │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [別デバイスでQRスキャン時]★v0.3新規    │
│  ┌───────────────────────────────────┐  │
│  │  🔗 Link to previous session?     │  │
│  │  Enter token: [AB12]              │  │
│  │  [Link] [New Session]             │  │
│  │  → 会話履歴統合                    │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [AI回答不可の場合]                      │
│  ┌───────────────────────────────────┐  │
│  │  Bot:  Sorry, I couldn't answer  │  │
│  │        your question accurately. │  │
│  │        [信頼度: 0.65]            │  │
│  │        👍 👎 ★v0.3新規          │  │
│  │                                   │  │
│  │  📞 Contact staff?                │  │
│  │  [Yes] [No]                       │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [緊急キーワード検出時]                  │
│  ┌───────────────────────────────────┐  │
│  │  ⚠️  Emergency detected          │  │
│  │  Staff has been notified.        │  │
│  │  Please wait for assistance.     │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [安全カテゴリ検出時]★v0.3新規          │
│  ┌───────────────────────────────────┐  │
│  │  ⚠️  Medical/Safety detected     │  │
│  │  Staff has been notified immediately.│ │
│  │  For emergencies, call 119/110.  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 5.2 管理画面フロー（v0.2）

```
┌─────────────────────────────────────┐
│  ログイン画面 (Login.vue)            │
│  ┌───────────────────────────────┐  │
│  │  Email: [________________]    │  │
│  │  Password: [______________]    │  │
│  │                               │  │
│  │  [Login]                      │  │
│  │                               │  │
│  │  [パスワードを忘れた場合]      │  │
│  └───────────────────────────────┘  │
└────────┬────────────────────────────┘
         │ 「パスワードを忘れた場合」クリック
         ↓
┌─────────────────────────────────────┐
│  パスワードリセット要求              │
│  (PasswordResetRequest.vue)          │
│  ┌───────────────────────────────┐  │
│  │  Email: [________________]    │  │
│  │                               │  │
│  │  [Send Reset Link]            │  │
│  │                               │  │
│  │  → メール送信                 │  │
│  └───────────────────────────────┘  │
└────────┬────────────────────────────┘
         │ メール内リンククリック
         │ /admin/password-reset/confirm?token=xxx
         ↓
┌─────────────────────────────────────┐
│  パスワードリセット確定              │
│  (PasswordResetConfirm.vue)          │
│  ┌───────────────────────────────┐  │
│  │  New Password: [___________]   │  │
│  │  Confirm: [_______________]    │  │
│  │                               │  │
│  │  [Set New Password]           │  │
│  └───────────────────────────────┘  │
└────────┬────────────────────────────┘
         │ ログイン成功
         ↓
┌─────────────────────────────────────────┐
│  ダッシュボード (Dashboard.vue)           │
│  ┌───────────────────────────────────┐  │
│  │  🌙 [ダークモード切替]            │  │
│  │                                   │  │
│  │  📊 週次サマリー                  │  │
│  │  総質問数: 127件                  │  │
│  │  自動応答率: 88%                  │  │
│  │  [円グラフ] カテゴリ別内訳        │  │
│  │  • Basic: 35件                    │  │
│  │  • Facilities: 48件               │  │
│  │  • Location: 25件                 │  │
│  │  • Trouble: 7件                   │  │
│  │                                   │  │
│  │  💬 リアルタイムチャット          │  │
│  │  [最新10件の会話を表示]           │  │
│  │  • Guest(EN): WiFi?              │  │
│  │    Bot: Password is...           │  │
│  │    [信頼度: 0.95]                │  │
│  │                                   │  │
│  │  ⚠️ 未解決質問 (3件)             │  │
│  │  • Late checkout possible?       │  │
│  │    [FAQ追加] [解決]              │  │
│  └───────────────────────────────────┘  │
│                                         │
│  [サイドバーメニュー]                   │
│  • 📊 ダッシュボード                   │
│  • ❓ FAQ管理                          │
│  • 🏠 施設設定                         │
│  • ⚠️ エスカレーション                 │
│  • ⏰ エスカレーションスケジュール       │
│  • 📱 QRコード発行                     │
│  • 💬 会話履歴                         │
│  • 🚪 ログアウト                       │
└────────┬───────────────────────────────┘
         │
         ├─→ FAQ管理
         │   ┌─────────────────────────────┐
         │   │  [+ 新規FAQ追加]             │
         │   │                               │
         │   │  カテゴリ: Basic (5件)       │
         │   │  • What time is check-in?   │
         │   │    → Check-in is 3pm-10pm   │
         │   │    [編集] [削除]            │
         │   │                               │
         │   │  カテゴリ: Facilities (8件)  │
         │   │  • WiFi password?           │
         │   │    → Password is: guest2024 │
         │   │    [編集] [削除]            │
         │   │                               │
         │   │  [埋め込みベクトル自動生成]  │
         │   └─────────────────────────────┘
         │
         ├─→ エスカレーションスケジュール
         │   ┌─────────────────────────────┐
         │   │  [+ 新規スケジュール追加]    │
         │   │                               │
         │   │  平日日中 (09:00-18:00)      │
         │   │  • モード: 早期 (0.85)       │
         │   │  • 言語: EN, JA              │
         │   │  • 通知: Email               │
         │   │  [編集] [削除]              │
         │   │                               │
         │   │  夜間 (18:00-09:00)          │
         │   │  • モード: 通常 (0.7)        │
         │   │  • 言語: All                 │
         │   │  • 通知: Email               │
         │   │  [編集] [削除]              │
         │   └─────────────────────────────┘
         │
         └─→ その他のメニュー項目...
```

### 5.3 エスカレーションフロー（v0.2）

```
ゲスト質問
    ↓
AI応答生成（RAG統合型）
    ↓
信頼度スコア計算
    ├─ 0.8以上: 高信頼度
    ├─ 0.7-0.8: 中信頼度
    └─ 0.7未満: 低信頼度
    ↓
エスカレーション判定
    ├─ 現在時刻・曜日取得
    ├─ エスカレーションスケジュール検索
    │   ├─ 該当スケジュールあり
    │   │   ├─ モード: 早期 (0.85)
    │   │   └─ モード: 通常 (0.7)
    │   └─ 該当スケジュールなし
    │       └─ デフォルト: 通常 (0.7)
    ↓
判定結果
    ├─ 信頼度 >= 閾値
    │   └─ 回答返却（エスカレーションなし）
    │
    ├─ 信頼度 < 閾値
    │   ├─ 緊急キーワード検出
    │   │   └─ 即時エスカレーション
    │   │       ├─ メール通知
    │   │       └─ ゲストに通知表示
    │   │
    │   └─ 通常エスカレーション
    │       ├─ エスカレーションテーブルに記録
    │       ├─ メール通知（スケジュール設定に従う）
    │       └─ ゲストに「スタッフに連絡しますか？」表示
    │
    └─ 3往復以上未解決
        └─ 自動エスカレーション
```

### 5.4 セッション管理フロー（v0.2）

```
QRコード読み取り
    ↓
/f/:facility_slug?location=entrance
    ↓
Cookie確認
    ├─ tabipera_session 存在
    │   ├─ セッション有効性チェック
    │   │   ├─ 24時間以内のアクティビティ
    │   │   │   └─ セッション有効 → チャット画面へ
    │   │   └─ 24時間経過
    │   │       └─ セッション無効 → ウェルカム画面へ
    │   └─ セッション無効
    │       └─ 新規セッション作成
    │
    └─ tabipera_session 不存在
        └─ ウェルカム画面
            └─ セッション作成
                ├─ POST /api/v1/chat (初回)
                ├─ session_id取得
                └─ Cookie保存
                    ├─ Name: tabipera_session
                    ├─ HttpOnly: false
                    ├─ Secure: true (本番)
                    ├─ SameSite: Lax
                    └─ Max-Age: 86400 (24時間)
    ↓
チャット画面
    ├─ メッセージ送信時
    │   └─ last_activity_at更新
    │
    └─ 24時間無動作
        └─ セッション自動終了
            └─ ウェルカム画面へリダイレクト
```

### 5.5 ダークモード切替フロー

```
ユーザー操作
    ↓
🌙 ダークモード切替ボタンクリック
    ↓
Pinia Store更新
    ├─ isDarkMode: true/false
    └─ localStorage保存
    ↓
CSS変数更新
    ├─ --bg-primary: #ffffff / #1a1a1a
    ├─ --text-primary: #000000 / #ffffff
    ├-- --bg-secondary: #f5f5f5 / #2d2d2d
    └─ ... (その他の色変数)
    ↓
全コンポーネント自動適用
    ├─ Tailwind CSS dark:クラス
    └─ 即座に反映
```

### 5.6 PWAインストールフロー

```
初回アクセス
    ↓
PWA要件確認
    ├─ HTTPS接続
    ├─ manifest.json存在
    └─ service worker登録
    ↓
インストールプロンプト表示
    ┌─────────────────────────────┐
    │  📱 Install やどぺら?        │
    │                             │
    │  Add to home screen for     │
    │  quick access                │
    │                             │
    │  [Install] [Not now]        │
    └─────────────────────────────┘
    ↓
ユーザーが「Install」選択
    ↓
ホーム画面に追加
    ├─ アイコン表示
    ├─ スプラッシュスクリーン
    └─ オフライン対応（基本情報表示）
```

### 5.7 スマホ最適化（375px-428px）

```
レスポンシブデザイン
    ├─ 375px (iPhone SE)
    │   ├─ 1カラムレイアウト
    │   ├─ フォントサイズ調整
    │   └─ タッチターゲット 44px以上
    │
    ├─ 428px (iPhone 12 Pro Max)
    │   ├─ 1カラムレイアウト
    │   ├─ 余白最適化
    │   └─ 固定フッター（チャット入力）
    │
    └─ 共通
        ├─ 横スクロール防止
        ├─ ビューポート設定
        │   └─ <meta name="viewport" content="width=device-width, initial-scale=1.0">
        └─ タッチジェスチャー対応
```

---

## 6. ディレクトリ構造

### 6.1 全体構造

```
yadopera/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                    # FastAPI application entry
│   │   ├── config.py                  # 環境変数・設定
│   │   ├── database.py                # DB接続設定（async）
│   │   ├── redis_client.py            # Redis接続設定（v0.2追加）
│   │   │
│   │   ├── api/                       # API層
│   │   │   ├── __init__.py
│   │   │   ├── deps.py                # 依存性注入
│   │   │   └── v1/
│   │   │       ├── __init__.py
│   │   │       ├── router.py          # APIルーター統合
│   │   │       ├── auth.py            # 認証エンドポイント（パスワードリセット追加）
│   │   │       ├── chat.py            # ゲスト会話エンドポイント（RAG統合）
│   │   │       ├── facility.py        # 施設管理エンドポイント
│   │   │       ├── faqs.py            # FAQ管理エンドポイント（埋め込みベクトル生成）
│   │   │       ├── conversations.py   # 会話履歴エンドポイント
│   │   │       ├── escalations.py     # エスカレーション管理（v0.2追加）
│   │   │       ├── escalation_schedule.py  # エスカレーションスケジュール（v0.2追加）
│   │   │       └── qrcodes.py         # QRコード生成エンドポイント
│   │   │
│   │   ├── models/                    # SQLAlchemyモデル
│   │   │   ├── __init__.py
│   │   │   ├── facility.py
│   │   │   ├── faq.py                 # embeddingカラム追加（v0.2）
│   │   │   ├── conversation.py
│   │   │   ├── message.py             # ai_confidence, matched_faq_ids追加（v0.2）
│   │   │   ├── escalation.py          # escalation_mode追加（v0.2）
│   │   │   ├── escalation_schedule.py # 新規追加（v0.2）
│   │   │   ├── user.py                # password_reset_token追加（v0.2）
│   │   │   └── qr_code.py
│   │   │
│   │   ├── schemas/                   # Pydanticスキーマ
│   │   │   ├── __init__.py
│   │   │   ├── facility.py
│   │   │   ├── faq.py
│   │   │   ├── chat.py                # ai_confidence, matched_faq_ids追加（v0.2）
│   │   │   ├── conversation.py
│   │   │   ├── escalation.py          # escalation_mode追加（v0.2）
│   │   │   ├── escalation_schedule.py # 新規追加（v0.2）
│   │   │   └── auth.py                # password_reset追加（v0.2）
│   │   │
│   │   ├── services/                  # ビジネスロジック
│   │   │   ├── __init__.py
│   │   │   ├── auth_service.py        # 認証・トークン管理（パスワードリセット追加）
│   │   │   ├── chat_service.py        # AI対話処理（RAG統合型）
│   │   │   ├── facility_service.py
│   │   │   ├── faq_service.py         # 埋め込みベクトル生成追加（v0.2）
│   │   │   ├── conversation_service.py
│   │   │   ├── escalation_service.py  # エスカレーション判定（スケジュール連動）（v0.2）
│   │   │   ├── escalation_schedule_service.py  # 新規追加（v0.2）
│   │   │   └── qrcode_service.py
│   │   │
│   │   ├── ai/                        # AI関連（RAG統合）
│   │   │   ├── __init__.py
│   │   │   ├── engine.py              # AI対話エンジン（RAG統合型）
│   │   │   ├── prompts.py             # プロンプトテンプレート
│   │   │   ├── embeddings.py          # 埋め込みベクトル生成（v0.2追加）
│   │   │   ├── vector_search.py       # pgvector検索（v0.2追加）
│   │   │   ├── confidence.py          # 信頼度スコア計算（v0.2追加）
│   │   │   └── openai_client.py       # OpenAI APIラッパー
│   │   │
│   │   ├── core/                      # コア機能
│   │   │   ├── __init__.py
│   │   │   ├── security.py            # パスワードハッシュ化等
│   │   │   ├── jwt.py                 # JWT生成・検証
│   │   │   └── exceptions.py          # カスタム例外
│   │   │
│   │   └── utils/                     # ユーティリティ
│   │       ├── __init__.py
│   │       ├── logger.py
│   │       ├── email.py               # エスカレーション通知、パスワードリセット（v0.2）
│   │       ├── session.py             # セッション管理（Redis連携）（v0.2）
│   │       └── rate_limit.py          # Rate Limiting（Redis使用）（v0.2）
│   │
│   ├── alembic/                       # DBマイグレーション
│   │   ├── versions/
│   │   │   ├── 001_initial_tables.py
│   │   │   ├── 002_add_pgvector.py    # pgvector拡張（v0.2）
│   │   │   ├── 003_add_embeddings.py   # FAQ埋め込みベクトル（v0.2）
│   │   │   ├── 004_escalation_schedule.py  # エスカレーションスケジュール（v0.2）
│   │   │   └── 005_password_reset.py  # パスワードリセット（v0.2）
│   │   ├── env.py
│   │   └── script.py.mako
│   │
│   ├── tests/                         # テストコード
│   │   ├── __init__.py
│   │   ├── conftest.py
│   │   ├── test_auth.py               # パスワードリセットテスト追加（v0.2）
│   │   ├── test_chat.py               # RAG統合テスト追加（v0.2）
│   │   ├── test_ai_engine.py         # 信頼度スコアテスト追加（v0.2）
│   │   ├── test_vector_search.py     # pgvector検索テスト（v0.2追加）
│   │   └── test_escalation_schedule.py  # エスカレーションスケジュールテスト（v0.2追加）
│   │
│   ├── .env.example
│   ├── .gitignore
│   ├── requirements.txt
│   ├── alembic.ini
│   ├── Dockerfile
│   └── README.md
│
├── frontend/
│   ├── public/
│   │   ├── index.html
│   │   ├── favicon.ico
│   │   ├── pwa-192x192.png            # PWAアイコン（v0.2追加）
│   │   ├── pwa-512x512.png            # PWAアイコン（v0.2追加）
│   │   └── manifest.json               # PWAマニフェスト（v0.2追加）
│   │
│   ├── src/
│   │   ├── main.ts                    # Vue entry point（TypeScript化）（v0.2）
│   │   ├── App.vue
│   │   │
│   │   ├── router/                    # Vue Router
│   │   │   ├── index.ts               # TypeScript化（v0.2）
│   │   │   ├── guest.ts               # ゲスト側ルート（v0.2）
│   │   │   └── admin.ts               # 管理側ルート（v0.2）
│   │   │
│   │   ├── stores/                    # Pinia (状態管理)
│   │   │   ├── index.ts
│   │   │   ├── auth.ts                # パスワードリセット追加（v0.2）
│   │   │   ├── chat.ts                # セッション管理追加（v0.2）
│   │   │   ├── facility.ts
│   │   │   ├── dashboard.ts           # ダッシュボード（v0.2追加）
│   │   │   └── theme.ts               # ダークモード管理（v0.2追加）
│   │   │
│   │   ├── api/                       # API通信
│   │   │   ├── axios.ts               # Axios設定（TypeScript化）（v0.2）
│   │   │   ├── auth.ts                # パスワードリセット追加（v0.2）
│   │   │   ├── chat.ts                # RAG統合型チャット（v0.2）
│   │   │   ├── facilities.ts
│   │   │   ├── faqs.ts
│   │   │   ├── escalations.ts         # エスカレーション（v0.2追加）
│   │   │   ├── escalation_schedule.ts # エスカレーションスケジュール（v0.2追加）
│   │   │   └── qrcodes.ts
│   │   │
│   │   ├── views/                     # ページコンポーネント
│   │   │   ├── guest/                 # ゲスト側
│   │   │   │   ├── LanguageSelect.vue
│   │   │   │   ├── Welcome.vue        # セッション作成追加（v0.2）
│   │   │   │   └── Chat.vue           # ダークモード、信頼度表示追加（v0.2）
│   │   │   │
│   │   │   └── admin/                 # 管理画面
│   │   │       ├── Login.vue
│   │   │       ├── PasswordResetRequest.vue  # 新規追加（v0.2）
│   │   │       ├── PasswordResetConfirm.vue  # 新規追加（v0.2）
│   │   │       ├── Dashboard.vue      # ポーリング追加（v0.2）
│   │   │       ├── FaqManagement.vue  # 埋め込みベクトル自動生成（v0.2）
│   │   │       ├── FacilitySettings.vue
│   │   │       ├── EscalationManagement.vue  # 新規追加（v0.2）
│   │   │       ├── EscalationSchedule.vue    # 新規追加（v0.2）
│   │   │       ├── ConversationHistory.vue
│   │   │       └── QRCodeGenerator.vue
│   │   │
│   │   ├── components/                # 再利用コンポーネント
│   │   │   ├── common/
│   │   │   │   ├── Button.vue
│   │   │   │   ├── Input.vue
│   │   │   │   ├── Modal.vue
│   │   │   │   ├── Loading.vue
│   │   │   │   └── DarkModeToggle.vue  # 新規追加（v0.2）
│   │   │   │
│   │   │   ├── guest/
│   │   │   │   ├── ChatMessage.vue     # 信頼度表示追加（v0.2）
│   │   │   │   ├── QuickQuestions.vue
│   │   │   │   ├── EscalationButton.vue
│   │   │   │   └── PWAInstallPrompt.vue  # 新規追加（v0.2）
│   │   │   │
│   │   │   └── admin/
│   │   │       ├── Sidebar.vue
│   │   │       ├── StatsCard.vue
│   │   │       ├── CategoryChart.vue
│   │   │       ├── ChatHistoryList.vue
│   │   │       ├── EscalationList.vue  # 新規追加（v0.2）
│   │   │       └── ScheduleForm.vue    # 新規追加（v0.2）
│   │   │
│   │   ├── composables/               # Vue Composition API
│   │   │   ├── useAuth.ts             # TypeScript化（v0.2）
│   │   │   ├── useChat.ts             # セッション管理追加（v0.2）
│   │   │   ├── useSession.ts          # Cookie管理追加（v0.2）
│   │   │   ├── useDarkMode.ts         # 新規追加（v0.2）
│   │   │   └── usePWA.ts              # 新規追加（v0.2）
│   │   │
│   │   ├── utils/                     # ユーティリティ
│   │   │   ├── constants.ts           # TypeScript化（v0.2）
│   │   │   ├── validators.ts
│   │   │   ├── formatters.ts
│   │   │   └── cookies.ts             # Cookie操作（v0.2追加）
│   │   │
│   │   └── assets/                    # 静的ファイル
│   │       ├── styles/
│   │       │   ├── tailwind.css
│   │       │   └── dark-mode.css      # ダークモードスタイル（v0.2追加）
│   │       └── images/
│   │
│   ├── .env.example
│   ├── .gitignore
│   ├── package.json
│   ├── tsconfig.json                  # TypeScript設定（v0.2追加）
│   ├── vite.config.ts                 # TypeScript化（v0.2）
│   ├── tailwind.config.js             # ダークモード設定追加（v0.2）
│   └── README.md
│
├── docs/                              # ドキュメント
│   ├── architecture.md                # 本ファイル
│   ├── api_specification.md
│   ├── deployment.md
│   └── user_manual.md
│
├── docker-compose.yml                 # ローカル開発用（Redis追加）（v0.2）
├── .gitignore
└── README.md
```

### 6.2 主要ファイルの責務（v0.2追加・変更分）

#### Backend

| ファイル | 責務 | v0.2での変更点 |
|---------|------|---------------|
| `app/redis_client.py` | Redis接続管理 | 新規追加 |
| `app/api/v1/escalations.py` | エスカレーション管理API | 新規追加 |
| `app/api/v1/escalation_schedule.py` | エスカレーションスケジュールAPI | 新規追加 |
| `app/models/faq.py` | FAQモデル | `embedding`カラム追加（pgvector） |
| `app/models/message.py` | メッセージモデル | `ai_confidence`, `matched_faq_ids`追加 |
| `app/models/escalation_schedule.py` | エスカレーションスケジュールモデル | 新規追加 |
| `app/services/chat_service.py` | AI対話処理 | RAG統合型に変更 |
| `app/services/faq_service.py` | FAQ管理 | 埋め込みベクトル自動生成追加 |
| `app/services/escalation_service.py` | エスカレーション判定 | スケジュール連動判定追加 |
| `app/services/escalation_schedule_service.py` | エスカレーションスケジュール管理 | 新規追加 |
| `app/ai/embeddings.py` | 埋め込みベクトル生成 | 新規追加 |
| `app/ai/vector_search.py` | pgvector検索 | 新規追加 |
| `app/ai/confidence.py` | 信頼度スコア計算 | 新規追加 |
| `app/utils/session.py` | セッション管理 | Redis連携追加 |
| `app/utils/rate_limit.py` | Rate Limiting | Redis使用追加 |

#### Frontend

| ファイル | 責務 | v0.2での変更点 |
|---------|------|---------------|
| `src/stores/theme.ts` | ダークモード状態管理 | 新規追加 |
| `src/stores/dashboard.ts` | ダッシュボード状態管理 | 新規追加 |
| `src/views/admin/PasswordResetRequest.vue` | パスワードリセット要求 | 新規追加 |
| `src/views/admin/PasswordResetConfirm.vue` | パスワードリセット確定 | 新規追加 |
| `src/views/admin/EscalationManagement.vue` | エスカレーション管理 | 新規追加 |
| `src/views/admin/EscalationSchedule.vue` | エスカレーションスケジュール | 新規追加 |
| `src/components/common/DarkModeToggle.vue` | ダークモード切替 | 新規追加 |
| `src/components/guest/PWAInstallPrompt.vue` | PWAインストールプロンプト | 新規追加 |
| `src/composables/useDarkMode.ts` | ダークモードComposable | 新規追加 |
| `src/composables/usePWA.ts` | PWA Composable | 新規追加 |
| `src/utils/cookies.ts` | Cookie操作 | 新規追加 |

### 6.3 環境変数設定（v0.2追加分）

#### Backend (.env)

```bash
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@host:5432/yadopera

# Redis (v0.2追加)
REDIS_URL=redis://localhost:6379/0
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# OpenAI (v0.2追加: Embeddings)
OPENAI_API_KEY=sk-proj-xxxxx
OPENAI_EMBEDDING_MODEL=text-embedding-3-small

# JWT
SECRET_KEY=your-secret-key-min-32-chars
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=10080  # 7日間（v0.2変更）
REFRESH_TOKEN_EXPIRE_DAYS=30

# Email (パスワードリセット用)（v0.2追加）
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=noreply@yadopera.com
SMTP_PASSWORD=xxxxx
FRONTEND_URL=https://yadopera.com

# CORS
FRONTEND_URL=https://yadopera.com
ADMIN_URL=https://admin.yadopera.com

# Environment
ENVIRONMENT=production
DEBUG=false
```

#### Frontend (.env.production)

```bash
VITE_API_BASE_URL=https://api.yadopera.com
VITE_ENVIRONMENT=production
VITE_PWA_ENABLED=true  # v0.2追加
```

---

## 7. データベース設計（PoC版）

### 7.1 ER図（v0.3）

```
┌─────────────────────────┐
│        users            │ (管理者)
├─────────────────────────┤
│ id SERIAL PK            │
│ facility_id INTEGER FK  │──→ facilities.id
│ email VARCHAR(255) UNIQUE│
│ password_hash VARCHAR   │ (bcrypt)
│ role VARCHAR(50)        │ ('owner', 'staff', 'admin')
│ full_name VARCHAR(255)  │
│ is_active BOOLEAN       │
│ last_login_at TIMESTAMP │
│ password_reset_token    │ (v0.2追加)
│ password_reset_expires  │ (v0.2追加)
│ created_at TIMESTAMP    │
│ updated_at TIMESTAMP    │
└────────┬────────────────┘
         │
         │ N:1
         ↓
┌─────────────────────────┐
│      facilities         │ (施設)
├─────────────────────────┤
│ id SERIAL PK            │
│ name VARCHAR(255)        │
│ slug VARCHAR(100) UNIQUE │ (v0.2追加: URL用)
│ email VARCHAR(255)      │
│ phone VARCHAR(50)       │
│ wifi_ssid VARCHAR(100)  │
│ wifi_password VARCHAR   │ (暗号化保存)
│ check_in_time TIME      │
│ check_out_time TIME     │
│ languages TEXT[]        │
│ timezone VARCHAR(50)    │
│ subscription_plan VARCHAR│
│ monthly_question_limit  │
│ is_active BOOLEAN       │
│ created_at TIMESTAMP    │
│ updated_at TIMESTAMP    │
└────────┬────────────────┘
         │
         │ 1:N              1:N              1:N
         ├───────────┬───────────────┬──────────────────┐
         ↓           ↓               ↓                  ↓
┌──────────────┐ ┌──────────────────┐ ┌──────────────────┐ ┌──────────────────┐
│     faqs     │ │  conversations   │ │escalation_sched. │ │   qr_codes       │
├──────────────┤ ├──────────────────┤ ├──────────────────┤ ├──────────────────┤
│ id SERIAL PK │ │ id SERIAL PK     │ │ id SERIAL PK     │ │ id SERIAL PK     │
│ facility_id  │ │ facility_id FK   │ │ facility_id FK   │ │ facility_id FK   │
│ category     │ │ session_id       │ │ day_of_week TEXT[]│ │ location VARCHAR │
│ language     │ │ guest_language   │ │ time_start TIME  │ │ url TEXT         │
│ question TEXT│ │ location VARCHAR │ │ time_end TIME    │ │ file_path VARCHAR│
│ answer TEXT  │ │ user_agent TEXT │ │ mode VARCHAR     │ │ scan_count INT   │
│ embedding    │ │ ip_address INET │ │ threshold DECIMAL│ │ last_scanned_at  │
│ vector(1536) │ │ started_at       │ │ languages TEXT[] │ │ created_at       │
│ priority INT │ │ last_activity_at │ │ notify_channels  │ │ updated_at       │
│ is_active    │ │ ended_at         │ │ is_active BOOLEAN│ └──────────────────┘
│ created_by   │ │ is_escalated    │ │ created_at       │
│ created_at   │ │ total_messages  │ │ updated_at       │
│ updated_at   │ │ auto_resolved   │ └──────────────────┘
└──────────────┘ └────────┬─────────┘
                          │
                          │ 1:N
                          ↓
                 ┌──────────────────────┐
                 │      messages        │
                 ├──────────────────────┤
                 │ id SERIAL PK         │
                 │ conversation_id FK   │
                 │ role VARCHAR(20)     │ ('user', 'assistant', 'system')
                 │ content TEXT         │
                 │ ai_confidence        │ (v0.2追加: 0.00-1.00)
                 │ matched_faq_ids      │ (v0.2追加: INTEGER[])
                 │ tokens_used INTEGER │
                 │ response_time_ms INT │
                 │ created_at TIMESTAMP │
                 └──────────┬───────────┘
                            │
                            │ 1:1 (optional)
                            ↓
                 ┌──────────────────────┐
                 │    escalations       │
                 ├──────────────────────┤
                 │ id SERIAL PK         │
                 │ facility_id FK       │
                 │ conversation_id FK   │
                 │ trigger_type VARCHAR │ (v0.2追加)
                 │ ai_confidence DECIMAL │
                 │ escalation_mode      │ (v0.2追加: 'normal', 'early')
                 │ notified_at          │
                 │ notification_channels│
                 │ resolved_at           │
                 │ resolved_by FK       │
                 │ resolution_notes     │
                 │ created_at           │
                 └──────────┬───────────┘
                            │
                            │ 1:1 (optional)
                            ↓
                 ┌──────────────────────┐
                 │   overnight_queue    │ ★v0.3新規
                 ├──────────────────────┤
                 │ id SERIAL PK         │
                 │ facility_id FK       │
                 │ escalation_id FK     │
                 │ guest_message TEXT   │
                 │ scheduled_notify_at  │ (翌朝8:00)
                 │ notified_at          │
                 │ resolved_at          │
                 │ resolved_by FK       │
                 │ created_at           │
                 └──────────────────────┘
```

**v0.3新規テーブル（ER図続き）**

```
┌─────────────────────────┐
│      facilities         │
└────────┬────────────────┘
         │
         │ 1:N              1:N              1:N
         ├───────────┬───────────────┬──────────────────┐
         ↓           ↓               ↓                  ↓
┌──────────────┐ ┌──────────────────┐ ┌──────────────────┐
│guest_feedback│ │faq_suggestions   │ │session_tokens    │ ★v0.3新規
├──────────────┤ ├──────────────────┤ ├──────────────────┤
│ id SERIAL PK │ │ id SERIAL PK     │ │ id SERIAL PK     │
│ message_id FK│ │ facility_id FK   │ │ facility_id FK   │
│ facility_id  │ │ source_message_id│ │ token VARCHAR(10)│ (4桁コード)
│ feedback_type│ │ suggested_question│ │ primary_session_id│
│ ('positive', │ │ suggested_answer │ │ linked_session_ids│ (TEXT[])
│  'negative') │ │ suggested_category│ │ created_at       │
│ created_at   │ │ status VARCHAR   │ │ expires_at       │ (24時間後)
│              │ │ ('pending',      │ └──────────────────┘
│              │ │  'approved',     │
│              │ │  'rejected')     │
│              │ │ reviewed_at      │
│              │ │ reviewed_by FK    │
│              │ │ created_at       │
│              │ └──────────────────┘
│              │
│              │ 1:N
│              ↓
│     ┌──────────────────────┐
│     │  question_patterns   │ ★v0.3新規
│     ├──────────────────────┤
│     │ id SERIAL PK         │
│     │ facility_id FK       │
│     │ pattern_embedding    │ (vector(1536))
│     │ total_count INT      │
│     │ resolved_count INT   │
│     │ resolution_rate      │ (GENERATED)
│     │ last_asked_at        │
│     │ created_at           │
│     │ updated_at           │
│     └──────────────────────┘
└──────────────┘

┌─────────────────────────┐
│   operator_faqs         │ ★v0.3新規（宿泊事業者向けFAQ）
├─────────────────────────┤
│ id SERIAL PK             │
│ category VARCHAR(100)    │ ('setup', 'qrcode', 'faq_management', etc.)
│ question TEXT            │
│ answer TEXT              │
│ related_url TEXT         │ (管理画面内リンク)
│ display_order INTEGER    │
│ is_active BOOLEAN        │
│ created_at TIMESTAMP     │
│ updated_at TIMESTAMP     │
└─────────────────────────┘
```

### 7.2 テーブル定義詳細（PoC版）

#### pgvector拡張の有効化

```sql
-- PostgreSQL拡張機能の有効化
CREATE EXTENSION IF NOT EXISTS vector;
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

#### users (管理者ユーザー)

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,  -- bcrypt
    role VARCHAR(50) DEFAULT 'staff',  -- 'owner', 'staff', 'admin'
    full_name VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP,
    password_reset_token VARCHAR(255),  -- v0.2追加
    password_reset_expires TIMESTAMP,   -- v0.2追加
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_facility_id ON users(facility_id);
CREATE INDEX idx_users_password_reset_token ON users(password_reset_token) WHERE password_reset_token IS NOT NULL;
```

#### facilities (宿泊施設)

```sql
CREATE TABLE facilities (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) UNIQUE NOT NULL,  -- v0.2追加: URL用識別子
    email VARCHAR(255) NOT NULL,
    phone VARCHAR(50),
    address TEXT,
    wifi_ssid VARCHAR(100),
    wifi_password VARCHAR(100),  -- 暗号化保存
    check_in_time TIME DEFAULT '15:00',
    check_out_time TIME DEFAULT '11:00',
    house_rules TEXT,
    local_info TEXT,
    languages TEXT[] DEFAULT ARRAY['en'],
    timezone VARCHAR(50) DEFAULT 'Asia/Tokyo',
    subscription_plan VARCHAR(50) DEFAULT 'small',  -- 'small', 'standard', 'premium'
    monthly_question_limit INTEGER DEFAULT 200,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_facilities_slug ON facilities(slug);
CREATE INDEX idx_facilities_is_active ON facilities(is_active);
```

#### faqs (FAQ + pgvector) - v0.2変更

```sql
CREATE TYPE faq_category AS ENUM (
    'basic',      -- 基本情報
    'facilities', -- 設備・サービス
    'location',   -- 周辺情報
    'trouble'     -- トラブル対応
);

CREATE TABLE faqs (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    category faq_category NOT NULL,
    language VARCHAR(10) DEFAULT 'en',  -- 'en', 'ja', 'zh-TW', 'fr'
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    embedding vector(1536),  -- v0.2追加: OpenAI text-embedding-3-small
    priority INTEGER DEFAULT 1,  -- 1-5
    is_active BOOLEAN DEFAULT TRUE,
    created_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- インデックス
CREATE INDEX idx_faqs_facility_id ON faqs(facility_id);
CREATE INDEX idx_faqs_category ON faqs(category);
CREATE INDEX idx_faqs_is_active ON faqs(is_active);
CREATE INDEX idx_faqs_language ON faqs(language);

-- v0.2追加: pgvectorインデックス（IVFFlat: 高速近似最近傍探索）
CREATE INDEX idx_faqs_embedding ON faqs 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);  -- データ量に応じて調整

-- 埋め込みベクトルがNULLでないFAQのみインデックス対象
-- （新規作成時はNULL、保存時に自動生成）
```

#### conversations (会話セッション) - v0.2変更

```sql
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    session_id VARCHAR(100) UNIQUE NOT NULL,  -- Cookie保存用（UUID文字列）
    guest_language VARCHAR(10) DEFAULT 'en',
    location VARCHAR(50),  -- 'entrance', 'room', 'kitchen', 'lounge'
    user_agent TEXT,
    ip_address INET,
    started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_activity_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- v0.2: 24時間判定用
    ended_at TIMESTAMP,
    is_escalated BOOLEAN DEFAULT FALSE,  -- v0.2追加
    total_messages INTEGER DEFAULT 0,     -- v0.2追加
    auto_resolved BOOLEAN DEFAULT FALSE   -- v0.2追加
);

CREATE INDEX idx_conversations_facility_id ON conversations(facility_id);
CREATE INDEX idx_conversations_session_id ON conversations(session_id);
CREATE INDEX idx_conversations_last_activity ON conversations(last_activity_at);
CREATE INDEX idx_conversations_is_escalated ON conversations(is_escalated);
```

#### messages (メッセージ) - v0.2変更

```sql
CREATE TYPE message_role AS ENUM ('user', 'assistant', 'system');

CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    role message_role NOT NULL,
    content TEXT NOT NULL,
    ai_confidence DECIMAL(3,2),  -- v0.2追加: 0.00-1.00
    matched_faq_ids INTEGER[],   -- v0.2追加: 使用したFAQ IDリスト
    tokens_used INTEGER,
    response_time_ms INTEGER,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
CREATE INDEX idx_messages_ai_confidence ON messages(ai_confidence) WHERE ai_confidence IS NOT NULL;
```

#### escalations (エスカレーション) - v0.2変更

```sql
CREATE TABLE escalations (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    conversation_id INTEGER NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    trigger_type VARCHAR(50) NOT NULL,  -- v0.2追加: 'low_confidence', 'keyword', 'multiple_turns', 'staff_mode'
    ai_confidence DECIMAL(3,2),  -- エスカレーション時の信頼度
    escalation_mode VARCHAR(50) DEFAULT 'normal',  -- v0.2追加: 'normal', 'early'
    notified_at TIMESTAMP,
    notification_channels TEXT[] DEFAULT ARRAY['email'],  -- v0.2追加: ['email', 'slack', 'line']
    resolved_at TIMESTAMP,
    resolved_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
    resolution_notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_escalations_facility_id ON escalations(facility_id);
CREATE INDEX idx_escalations_conversation_id ON escalations(conversation_id);
CREATE INDEX idx_escalations_resolved_at ON escalations(resolved_at) WHERE resolved_at IS NULL;
CREATE INDEX idx_escalations_trigger_type ON escalations(trigger_type);
```

#### escalation_schedules (エスカレーションスケジュール) - v0.2新規

```sql
CREATE TABLE escalation_schedules (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    day_of_week TEXT[] NOT NULL,  -- ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'] or ['all']
    time_start TIME NOT NULL,
    time_end TIME NOT NULL,
    mode VARCHAR(50) DEFAULT 'normal',  -- 'normal', 'early'
    threshold DECIMAL(3,2) DEFAULT 0.70,  -- 0.70 (normal) or 0.85 (early)
    languages TEXT[] DEFAULT ARRAY['en', 'ja'],
    notify_channels TEXT[] DEFAULT ARRAY['email'],  -- ['email', 'slack', 'line']
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_escalation_schedules_facility_id ON escalation_schedules(facility_id);
CREATE INDEX idx_escalation_schedules_is_active ON escalation_schedules(is_active);
```

#### qr_codes (QRコード)

```sql
CREATE TABLE qr_codes (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    location VARCHAR(100) NOT NULL,  -- 'entrance', 'room', 'kitchen', 'lounge', 'custom'
    url TEXT NOT NULL,  -- https://yadopera.com/f/{facility_slug}?location={location}
    file_path VARCHAR(255),  -- S3保存先
    scan_count INTEGER DEFAULT 0,
    last_scanned_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_qr_codes_facility_id ON qr_codes(facility_id);
CREATE INDEX idx_qr_codes_location ON qr_codes(location);
```

#### guest_feedback (ゲストフィードバック) - v0.3新規

```sql
CREATE TABLE guest_feedback (
    id SERIAL PRIMARY KEY,
    message_id INTEGER NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    feedback_type VARCHAR(10) NOT NULL,  -- 'positive', 'negative'
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_guest_feedback_message_id ON guest_feedback(message_id);
CREATE INDEX idx_guest_feedback_facility_id ON guest_feedback(facility_id);
CREATE INDEX idx_guest_feedback_type ON guest_feedback(feedback_type);
CREATE INDEX idx_guest_feedback_created_at ON guest_feedback(created_at);
```

#### faq_suggestions (FAQ追加提案) - v0.3新規

```sql
CREATE TYPE faq_suggestion_status AS ENUM ('pending', 'approved', 'rejected');

CREATE TABLE faq_suggestions (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    source_message_id INTEGER REFERENCES messages(id) ON DELETE SET NULL,
    suggested_question TEXT NOT NULL,
    suggested_answer TEXT,  -- GPT-4o miniで自動生成、編集可能
    suggested_category VARCHAR(100),  -- 自動推定
    status faq_suggestion_status DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    reviewed_at TIMESTAMP,
    reviewed_by INTEGER REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX idx_faq_suggestions_facility_id ON faq_suggestions(facility_id);
CREATE INDEX idx_faq_suggestions_status ON faq_suggestions(status);
CREATE INDEX idx_faq_suggestions_created_at ON faq_suggestions(created_at);
```

#### overnight_queue (夜間対応キュー) - v0.3新規

```sql
CREATE TABLE overnight_queue (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    escalation_id INTEGER NOT NULL REFERENCES escalations(id) ON DELETE CASCADE,
    guest_message TEXT NOT NULL,
    scheduled_notify_at TIMESTAMP NOT NULL,  -- 翌朝8:00
    notified_at TIMESTAMP,
    resolved_at TIMESTAMP,
    resolved_by INTEGER REFERENCES users(id) ON DELETE SET NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_overnight_queue_facility_id ON overnight_queue(facility_id);
CREATE INDEX idx_overnight_queue_scheduled_notify_at ON overnight_queue(scheduled_notify_at);
CREATE INDEX idx_overnight_queue_resolved_at ON overnight_queue(resolved_at) WHERE resolved_at IS NULL;
```

#### session_tokens (セッション統合トークン) - v0.3新規

```sql
CREATE TABLE session_tokens (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    token VARCHAR(10) UNIQUE NOT NULL,  -- 4桁英数字（例: 'AB12'）
    primary_session_id VARCHAR(100) NOT NULL REFERENCES conversations(session_id) ON DELETE CASCADE,
    linked_session_ids TEXT[] DEFAULT ARRAY[]::TEXT[],  -- 統合されたセッションID配列
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP NOT NULL  -- 24時間後
);

CREATE INDEX idx_session_tokens_token ON session_tokens(token);
CREATE INDEX idx_session_tokens_facility_id ON session_tokens(facility_id);
CREATE INDEX idx_session_tokens_expires_at ON session_tokens(expires_at);
CREATE INDEX idx_session_tokens_primary_session_id ON session_tokens(primary_session_id);
```

#### question_patterns (質問パターン解決率) - v0.3新規

```sql
CREATE TABLE question_patterns (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    pattern_embedding vector(1536) NOT NULL,  -- 質問パターンの埋め込みベクトル
    total_count INTEGER DEFAULT 0,
    resolved_count INTEGER DEFAULT 0,  -- エスカレーションなしで完了した回数
    resolution_rate DECIMAL(3,2) GENERATED ALWAYS AS 
        (CASE 
            WHEN total_count > 0 THEN resolved_count::DECIMAL / total_count
            ELSE 0.0
        END) STORED,
    last_asked_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_question_patterns_facility_id ON question_patterns(facility_id);
CREATE INDEX idx_question_patterns_resolution_rate ON question_patterns(resolution_rate);
CREATE INDEX idx_question_patterns_embedding ON question_patterns 
USING ivfflat (pattern_embedding vector_cosine_ops)
WITH (lists = 100);
```

#### operator_faqs (宿泊事業者向けFAQ) - v0.3新規

```sql
CREATE TYPE operator_faq_category AS ENUM (
    'setup',              -- 初期設定
    'qrcode',             -- QRコード設置
    'faq_management',     -- FAQ登録・編集
    'ai_logic',           -- AI応答の仕組み
    'logs',               -- ログ・分析
    'troubleshooting',    -- トラブルシューティング
    'billing',            -- 料金・請求
    'security'            -- セキュリティ・プライバシー
);

CREATE TABLE operator_faqs (
    id SERIAL PRIMARY KEY,
    category operator_faq_category NOT NULL,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    related_url TEXT,  -- 管理画面内リンク（例: '/admin/faqs'）
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_operator_faqs_category ON operator_faqs(category);
CREATE INDEX idx_operator_faqs_is_active ON operator_faqs(is_active);
CREATE INDEX idx_operator_faqs_display_order ON operator_faqs(display_order);
```

### 7.3 データ保持ポリシー（v0.3改訂）

**GDPR準拠の3ヶ月自動削除バッチ処理（v0.3詳細化）**

**削除対象テーブル（Phase 2でCeleryバッチ処理実装）**
- `conversations`: `ended_at < NOW() - INTERVAL '3 months'` のレコード
- `messages`: 削除対象conversation_idに紐づく全メッセージ
- `escalations`: `created_at < NOW() - INTERVAL '3 months' AND resolved_at IS NOT NULL` のレコード
- `overnight_queue`: `resolved_at < NOW() - INTERVAL '3 months'` のレコード（v0.3新規）
- `faq_suggestions`: `status = 'rejected' AND created_at < NOW() - INTERVAL '3 months'` のレコード（v0.3新規）
- `session_tokens`: `expires_at < NOW() - INTERVAL '3 months'` のレコード（v0.3新規）

**保持対象（削除しない）**
- `facilities`, `users`, `faqs`: 契約中は保持
- `guest_feedback`: 匿名化して統計データとして保持（v0.3新規）
- `faq_suggestions`: 承認済み（`status = 'approved'`）はFAQに統合済みのため保持
- `question_patterns`: 統計データとして保持（v0.3新規）
- `operator_faqs`: システムFAQとして保持（v0.3新規）

**実装方針（Phase 2）**
- Celeryバッチ処理で毎日深夜2:00に実行
- 削除前に統計データを抽出（匿名化）
- 削除ログを記録（監査用）

**MVP期間中（Phase 1）**
- 手動削除対応（管理画面から実行可能）
- 3ヶ月経過データのアラート通知

### 7.4 マイグレーション管理（Alembic）

#### マイグレーション順序

```bash
# 1. 初期テーブル作成
alembic revision --autogenerate -m "create initial tables"

# 2. pgvector拡張有効化
alembic revision -m "enable pgvector extension"

# 3. FAQ埋め込みベクトルカラム追加
alembic revision --autogenerate -m "add faq embedding column"

# 4. エスカレーションスケジュールテーブル追加
alembic revision --autogenerate -m "add escalation_schedules table"

# 5. パスワードリセットカラム追加（usersテーブル）
alembic revision --autogenerate -m "add password reset to users"

# 6. メッセージテーブルに信頼度・FAQ ID追加
alembic revision --autogenerate -m "add ai_confidence and matched_faq_ids to messages"

# 7. エスカレーションテーブル拡張
alembic revision --autogenerate -m "extend escalations table with mode and trigger_type"
```

#### マイグレーション実行

```bash
# 全マイグレーション実行
alembic upgrade head

# 特定バージョンまでロールバック
alembic downgrade -1

# 現在のバージョン確認
alembic current

# マイグレーション履歴確認
alembic history
```

### 7.5 インデックス戦略

**パフォーマンス最適化**

1. **pgvectorインデックス（IVFFlat）**
   - FAQ検索の高速化
   - リスト数はデータ量に応じて調整（初期: 100）

2. **セッション管理**
   - `conversations.last_activity_at` インデックス
   - 24時間判定クエリの高速化

3. **エスカレーション判定**
   - `escalations.resolved_at` 部分インデックス（未解決のみ）
   - `escalation_schedules.is_active` インデックス

4. **検索最適化**
   - `facilities.slug` ユニークインデックス（URL検索）
   - `faqs.facility_id + category` 複合インデックス（検討中）

---

## 8. API設計

### 8.1 APIバージョニング

**最初から実装**: `/api/v1/`

理由: 実装負荷ゼロ、将来的な後方互換性確保、破壊的変更時のスムーズな移行

### 8.2 RESTful API エンドポイント一覧

#### 認証系 (`/api/v1/auth`)

| Method | Endpoint | 説明 | 認証 |
|--------|----------|------|------|
| POST | `/auth/login` | ログイン | 不要 |
| POST | `/auth/logout` | ログアウト | JWT |
| POST | `/auth/password-reset` | パスワードリセット要求 | 不要 |
| POST | `/auth/password-reset/confirm` | パスワードリセット確定 | 不要 |

#### ゲスト系 (`/api/v1/facility`, `/api/v1/chat`, `/api/v1/session`) - v0.3拡張

| Method | Endpoint | 説明 | 認証 | v0.3 |
|--------|----------|------|------|------|
| GET | `/facility/{slug}` | 施設情報取得（公開） | 不要 | - |
| POST | `/chat` | チャットメッセージ送信（RAG統合型） | セッション | - |
| GET | `/chat/history/{session_id}` | 会話履歴取得 | セッション | - |
| **POST** | **`/chat/feedback`** | **ゲストフィードバック送信** | **セッション** | **★新規** |
| **POST** | **`/session/link`** | **セッション統合** | **セッション** | **★新規** |
| **GET** | **`/session/token/{token}`** | **トークン検証** | **不要** | **★新規** |

#### 管理系 (`/api/v1/admin/*`) - v0.3拡張

| Method | Endpoint | 説明 | 認証 | v0.3 |
|--------|----------|------|------|------|
| GET | `/admin/dashboard` | ダッシュボードデータ | JWT | - |
| GET | `/admin/faqs` | FAQ一覧取得 | JWT | - |
| POST | `/admin/faqs` | FAQ作成（埋め込みベクトル自動生成） | JWT | - |
| PUT | `/admin/faqs/{faq_id}` | FAQ更新 | JWT | - |
| DELETE | `/admin/faqs/{faq_id}` | FAQ削除 | JWT | - |
| **GET** | **`/admin/faq-suggestions`** | **FAQ追加提案一覧** | **JWT** | **★新規** |
| **POST** | **`/admin/faq-suggestions/{id}/approve`** | **提案承認** | **JWT** | **★新規** |
| **POST** | **`/admin/faq-suggestions/{id}/reject`** | **提案却下** | **JWT** | **★新規** |
| GET | `/admin/escalations` | エスカレーション一覧 | JWT | - |
| PUT | `/admin/escalations/{escalation_id}` | エスカレーション解決 | JWT | - |
| **GET** | **`/admin/overnight-queue`** | **夜間対応キュー** | **JWT** | **★新規** |
| **GET** | **`/admin/feedback-stats`** | **フィードバック統計** | **JWT** | **★新規** |
| GET | `/admin/escalation-schedule` | エスカレーションスケジュール一覧 | JWT | - |
| POST | `/admin/escalation-schedule` | エスカレーションスケジュール作成 | JWT | - |
| PUT | `/admin/escalation-schedule/{schedule_id}` | エスカレーションスケジュール更新 | JWT | - |
| POST | `/admin/qr-code` | QRコード生成 | JWT | - |

#### 事業者サポート系 (`/api/v1/help/*`) - v0.3新規（Phase 2）

| Method | Endpoint | 説明 | 認証 | フェーズ |
|--------|----------|------|------|---------|
| GET | `/help/faqs` | 事業者向けFAQ一覧 | JWT | Phase 2 |
| GET | `/help/faqs/{category}` | カテゴリ別FAQ | JWT | Phase 2 |
| POST | `/help/chat` | AIヘルプチャット（管理画面内） | JWT | Phase 2 |
| GET | `/help/search?q={query}` | FAQ検索 | JWT | Phase 2 |

### 8.3 APIリクエスト・レスポンス詳細（v0.2）

#### GET `/api/v1/facility/{slug}`

**リクエスト**
```
GET /api/v1/facility/tokyo-guesthouse?location=entrance
```

**レスポンス (200 OK)**
```json
{
  "facility": {
    "id": 1,
    "name": "Tokyo Guesthouse",
    "slug": "tokyo-guesthouse",
    "email": "info@tokyo-guesthouse.com",
    "phone": "+81-3-1234-5678",
    "check_in_time": "15:00",
    "check_out_time": "11:00",
    "wifi_ssid": "TokyoGuesthouse_WiFi"
  },
  "top_questions": [
    "What is the WiFi password?",
    "What time is check-in?",
    "Where is the nearest station?"
  ]
}
```

#### POST `/api/v1/chat` (RAG統合型)

**リクエスト**
```json
{
  "facility_id": 1,
  "message": "Where is the laundry room?",
  "language": "en",
  "location": "entrance",
  "session_id": "optional-existing-session-id"
}
```

**レスポンス (200 OK) - 成功時**
```json
{
  "message_id": 123,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "The laundry room is located on the 2nd floor, next to the kitchen. It's available 24/7. Washing machine costs ¥200 per load.",
  "ai_confidence": 0.92,
  "source": "rag_generated",
  "matched_faq_ids": [5, 12],
  "response_time_ms": 1850,
  "escalation": {
    "needed": false
  }
}
```

**レスポンス (200 OK) - エスカレーション必要時**
```json
{
  "message_id": 124,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "Sorry, I couldn't answer your question accurately. Would you like to contact the staff?",
  "ai_confidence": 0.65,
  "source": "escalation_needed",
  "matched_faq_ids": [],
  "response_time_ms": 1200,
  "escalation": {
    "needed": true,
    "mode": "normal",
    "trigger_type": "low_confidence",
    "reason": "AI confidence below threshold (0.65 < 0.70)"
  }
}
```

**レスポンス (200 OK) - 緊急キーワード検出時**
```json
{
  "message_id": 125,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "Emergency detected. Staff has been notified. Please wait for assistance.",
  "ai_confidence": 0.50,
  "source": "escalation_needed",
  "matched_faq_ids": [],
  "response_time_ms": 800,
  "escalation": {
    "needed": true,
    "mode": "normal",
    "trigger_type": "keyword",
    "reason": "Emergency keyword detected: 'locked out'",
    "notified": true
  }
}
```

#### GET `/api/v1/chat/history/{session_id}`

**リクエスト**
```
GET /api/v1/chat/history/550e8400-e29b-41d4-a716-446655440000
```

**レスポンス (200 OK)**
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "facility_id": 1,
  "language": "en",
  "location": "entrance",
  "started_at": "2025-11-19T10:00:00Z",
  "last_activity_at": "2025-11-19T10:15:00Z",
  "messages": [
    {
      "id": 123,
      "role": "user",
      "content": "Where is the laundry room?",
      "created_at": "2025-11-19T10:05:00Z"
    },
    {
      "id": 124,
      "role": "assistant",
      "content": "The laundry room is located on the 2nd floor...",
      "ai_confidence": 0.92,
      "matched_faq_ids": [5, 12],
      "response_time_ms": 1850,
      "created_at": "2025-11-19T10:05:01Z"
    }
  ]
}
```

#### POST `/api/v1/auth/login`

**リクエスト**
```json
{
  "email": "owner@guesthouse.com",
  "password": "secure_password"
}
```

**レスポンス (200 OK)**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token_type": "bearer",
  "expires_in": 604800,
  "user": {
    "id": 1,
    "email": "owner@guesthouse.com",
    "full_name": "John Doe",
    "role": "owner",
    "facility_id": 1
  }
}
```

#### POST `/api/v1/auth/password-reset`

**リクエスト**
```json
{
  "email": "owner@guesthouse.com"
}
```

**レスポンス (200 OK)**
```json
{
  "message": "Password reset email sent. Please check your inbox."
}
```

#### POST `/api/v1/auth/password-reset/confirm`

**リクエスト**
```json
{
  "token": "reset-token-from-email",
  "new_password": "new_secure_password"
}
```

**レスポンス (200 OK)**
```json
{
  "message": "Password reset successfully. You can now login with your new password."
}
```

#### GET `/api/v1/admin/dashboard`

**リクエスト**
```
GET /api/v1/admin/dashboard?period=week
Headers:
  Authorization: Bearer {access_token}
```

**レスポンス (200 OK)**
```json
{
  "period": {
    "start": "2025-11-11T00:00:00Z",
    "end": "2025-11-18T00:00:00Z"
  },
  "total_questions": 127,
  "auto_response_rate": 0.88,
  "average_response_time_ms": 2150,
  "average_confidence": 0.85,
  "category_breakdown": {
    "basic": 35,
    "facilities": 48,
    "location": 25,
    "trouble": 7
  },
  "top_questions": [
    {
      "question": "WiFi password?",
      "count": 23
    },
    {
      "question": "Check-in time?",
      "count": 18
    }
  ],
  "recent_conversations": [
    {
      "session_id": "550e8400-e29b-41d4-a716-446655440000",
      "guest_language": "en",
      "last_message": "Where is the laundry room?",
      "ai_confidence": 0.92,
      "created_at": "2025-11-19T10:05:00Z"
    }
  ],
  "unresolved_count": 8
}
```

#### POST `/api/v1/admin/faqs` (埋め込みベクトル自動生成)

**リクエスト**
```json
{
  "question": "What is the WiFi password?",
  "answer": "The WiFi password is guest2024. The SSID is TokyoGuesthouse_WiFi.",
  "category": "basic",
  "priority": 5,
  "language": "en"
}
```

**レスポンス (201 Created)**
```json
{
  "id": 15,
  "facility_id": 1,
  "category": "basic",
  "language": "en",
  "question": "What is the WiFi password?",
  "answer": "The WiFi password is guest2024. The SSID is TokyoGuesthouse_WiFi.",
  "priority": 5,
  "is_active": true,
  "embedding_generated": true,
  "created_at": "2025-11-19T10:00:00Z",
  "updated_at": "2025-11-19T10:00:00Z"
}
```

#### GET `/api/v1/admin/escalations`

**リクエスト**
```
GET /api/v1/admin/escalations?resolved=false&limit=20
Headers:
  Authorization: Bearer {access_token}
```

**レスポンス (200 OK)**
```json
{
  "escalations": [
    {
      "id": 5,
      "facility_id": 1,
      "conversation_id": 10,
      "trigger_type": "low_confidence",
      "ai_confidence": 0.65,
      "escalation_mode": "normal",
      "question": "Can I extend my checkout time?",
      "language": "en",
      "notified_at": "2025-11-19T10:10:00Z",
      "notification_channels": ["email"],
      "resolved_at": null,
      "resolved_by": null,
      "resolution_notes": null,
      "created_at": "2025-11-19T10:10:00Z"
    }
  ],
  "total": 8,
  "unresolved": 8
}
```

#### POST `/api/v1/admin/escalation-schedule`

**リクエスト**
```json
{
  "day_of_week": ["mon", "tue", "wed", "thu", "fri"],
  "time_start": "09:00",
  "time_end": "18:00",
  "mode": "early",
  "threshold": 0.85,
  "languages": ["en", "ja"],
  "notify_channels": ["email"]
}
```

**レスポンス (201 Created)**
```json
{
  "id": 3,
  "facility_id": 1,
  "day_of_week": ["mon", "tue", "wed", "thu", "fri"],
  "time_start": "09:00",
  "time_end": "18:00",
  "mode": "early",
  "threshold": 0.85,
  "languages": ["en", "ja"],
  "notify_channels": ["email"],
  "is_active": true,
  "created_at": "2025-11-19T10:00:00Z",
  "updated_at": "2025-11-19T10:00:00Z"
}
```

### 8.4 エラーレスポンス

#### 標準エラーフォーマット

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Human readable error message",
    "details": {
      "field": "Additional context"
    }
  }
}
```

#### エラーコード一覧

| HTTPステータス | エラーコード | 説明 |
|---------------|-------------|------|
| 400 | INVALID_REQUEST | リクエストデータが不正 |
| 401 | UNAUTHORIZED | 認証が必要 |
| 403 | FORBIDDEN | アクセス権限なし |
| 404 | NOT_FOUND | リソースが見つからない |
| 422 | VALIDATION_ERROR | バリデーションエラー |
| 429 | RATE_LIMIT_EXCEEDED | レート制限超過 |
| 500 | INTERNAL_ERROR | サーバー内部エラー |
| 503 | SERVICE_UNAVAILABLE | サービス一時停止（OpenAI API障害時） |

#### エラーレスポンス例

**401 Unauthorized**
```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Invalid or expired token",
    "details": {
      "token_type": "access_token"
    }
  }
}
```

**422 Validation Error**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": {
      "field": "email",
      "reason": "Invalid email format"
    }
  }
}
```

**503 Service Unavailable (OpenAI API障害時)**
```json
{
  "error": {
    "code": "SERVICE_UNAVAILABLE",
    "message": "AI service is temporarily unavailable. Please try again later.",
    "details": {
      "service": "openai_api",
      "error_type": "timeout"
    }
  }
}
```

### 8.5 Rate Limiting

| エンドポイント | 制限 | 理由 |
|--------------|------|------|
| `/api/v1/chat` | 60 requests/minute | ゲストの過度な利用防止 |
| `/api/v1/auth/login` | 5 requests/minute | ブルートフォース攻撃防止 |
| `/api/v1/auth/password-reset` | 3 requests/hour | スパム防止 |
| `/api/v1/admin/*` | 100 requests/minute | 管理画面の通常利用 |

**Rate Limit超過時のレスポンス**
```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Too many requests. Please try again later.",
    "details": {
      "retry_after": 60
    }
  }
}
```

---

## 9. APIレスポンス実装例（JSONスキーマ）

### 9.1 ゲスト側APIレスポンス

#### GET `/api/v1/facility/{slug}` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["facility", "top_questions"],
  "properties": {
    "facility": {
      "type": "object",
      "required": ["id", "name", "slug", "check_in_time", "check_out_time"],
      "properties": {
        "id": { "type": "integer" },
        "name": { "type": "string" },
        "slug": { "type": "string" },
        "email": { "type": "string", "format": "email" },
        "phone": { "type": "string" },
        "check_in_time": { "type": "string", "pattern": "^\\d{2}:\\d{2}$" },
        "check_out_time": { "type": "string", "pattern": "^\\d{2}:\\d{2}$" },
        "wifi_ssid": { "type": "string" }
      }
    },
    "top_questions": {
      "type": "array",
      "items": { "type": "string" },
      "minItems": 0,
      "maxItems": 3
    }
  }
}
```

**実装例**
```json
{
  "facility": {
    "id": 1,
    "name": "Tokyo Guesthouse",
    "slug": "tokyo-guesthouse",
    "email": "info@tokyo-guesthouse.com",
    "phone": "+81-3-1234-5678",
    "check_in_time": "15:00",
    "check_out_time": "11:00",
    "wifi_ssid": "TokyoGuesthouse_WiFi"
  },
  "top_questions": [
    "What is the WiFi password?",
    "What time is check-in?",
    "Where is the nearest station?"
  ]
}
```

#### POST `/api/v1/chat` レスポンススキーマ（RAG統合型）

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["message_id", "session_id", "response", "ai_confidence", "source", "escalation"],
  "properties": {
    "message_id": { "type": "integer" },
    "session_id": { 
      "type": "string",
      "format": "uuid",
      "description": "Cookieに保存するセッションID"
    },
    "response": { 
      "type": "string",
      "maxLength": 500,
      "description": "AI生成回答（最大200トークン相当）"
    },
    "ai_confidence": {
      "type": "number",
      "minimum": 0.0,
      "maximum": 1.0,
      "description": "信頼度スコア（0.0-1.0）"
    },
    "source": {
      "type": "string",
      "enum": ["rag_generated", "escalation_needed"],
      "description": "回答ソース"
    },
    "matched_faq_ids": {
      "type": "array",
      "items": { "type": "integer" },
      "description": "使用したFAQ IDリスト（RAG検索結果）"
    },
    "response_time_ms": {
      "type": "integer",
      "minimum": 0,
      "description": "レスポンス時間（ミリ秒）"
    },
    "escalation": {
      "type": "object",
      "required": ["needed"],
      "properties": {
        "needed": { "type": "boolean" },
        "mode": {
          "type": "string",
          "enum": ["normal", "early"],
          "description": "エスカレーションモード"
        },
        "trigger_type": {
          "type": "string",
          "enum": ["low_confidence", "keyword", "multiple_turns", "staff_mode"],
          "description": "エスカレーション理由"
        },
        "reason": {
          "type": "string",
          "description": "エスカレーション理由の詳細"
        },
        "notified": {
          "type": "boolean",
          "description": "スタッフに通知済みか"
        }
      }
    }
  }
}
```

**実装例 - 成功時**
```json
{
  "message_id": 123,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "The laundry room is located on the 2nd floor, next to the kitchen. It's available 24/7. Washing machine costs ¥200 per load.",
  "ai_confidence": 0.92,
  "source": "rag_generated",
  "matched_faq_ids": [5, 12],
  "response_time_ms": 1850,
  "escalation": {
    "needed": false
  }
}
```

**実装例 - エスカレーション必要時**
```json
{
  "message_id": 124,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "Sorry, I couldn't answer your question accurately. Would you like to contact the staff?",
  "ai_confidence": 0.65,
  "source": "escalation_needed",
  "matched_faq_ids": [],
  "response_time_ms": 1200,
  "escalation": {
    "needed": true,
    "mode": "normal",
    "trigger_type": "low_confidence",
    "reason": "AI confidence below threshold (0.65 < 0.70)",
    "notified": false
  }
}
```

**実装例 - 緊急キーワード検出時**
```json
{
  "message_id": 125,
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "response": "Emergency detected. Staff has been notified. Please wait for assistance.",
  "ai_confidence": 0.50,
  "source": "escalation_needed",
  "matched_faq_ids": [],
  "response_time_ms": 800,
  "escalation": {
    "needed": true,
    "mode": "normal",
    "trigger_type": "keyword",
    "reason": "Emergency keyword detected: 'locked out'",
    "notified": true
  }
}
```

#### GET `/api/v1/chat/history/{session_id}` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["session_id", "facility_id", "messages"],
  "properties": {
    "session_id": { "type": "string", "format": "uuid" },
    "facility_id": { "type": "integer" },
    "language": { "type": "string", "enum": ["en", "ja", "zh-TW", "fr"] },
    "location": { "type": "string" },
    "started_at": { "type": "string", "format": "date-time" },
    "last_activity_at": { "type": "string", "format": "date-time" },
    "messages": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "role", "content", "created_at"],
        "properties": {
          "id": { "type": "integer" },
          "role": { "type": "string", "enum": ["user", "assistant", "system"] },
          "content": { "type": "string" },
          "ai_confidence": { "type": "number", "minimum": 0.0, "maximum": 1.0 },
          "matched_faq_ids": { "type": "array", "items": { "type": "integer" } },
          "response_time_ms": { "type": "integer" },
          "created_at": { "type": "string", "format": "date-time" }
        }
      }
    }
  }
}
```

**実装例**
```json
{
  "session_id": "550e8400-e29b-41d4-a716-446655440000",
  "facility_id": 1,
  "language": "en",
  "location": "entrance",
  "started_at": "2025-11-19T10:00:00Z",
  "last_activity_at": "2025-11-19T10:15:00Z",
  "messages": [
    {
      "id": 123,
      "role": "user",
      "content": "Where is the laundry room?",
      "created_at": "2025-11-19T10:05:00Z"
    },
    {
      "id": 124,
      "role": "assistant",
      "content": "The laundry room is located on the 2nd floor, next to the kitchen. It's available 24/7. Washing machine costs ¥200 per load.",
      "ai_confidence": 0.92,
      "matched_faq_ids": [5, 12],
      "response_time_ms": 1850,
      "created_at": "2025-11-19T10:05:01Z"
    }
  ]
}
```

### 9.2 認証APIレスポンス

#### POST `/api/v1/auth/login` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["access_token", "refresh_token", "token_type", "expires_in", "user"],
  "properties": {
    "access_token": { 
      "type": "string",
      "description": "JWTアクセストークン（7日間有効）"
    },
    "refresh_token": {
      "type": "string",
      "description": "JWTリフレッシュトークン（30日間有効）"
    },
    "token_type": { "type": "string", "enum": ["bearer"] },
    "expires_in": {
      "type": "integer",
      "description": "アクセストークンの有効期限（秒）"
    },
    "user": {
      "type": "object",
      "required": ["id", "email", "role", "facility_id"],
      "properties": {
        "id": { "type": "integer" },
        "email": { "type": "string", "format": "email" },
        "full_name": { "type": "string" },
        "role": { "type": "string", "enum": ["owner", "staff", "admin"] },
        "facility_id": { "type": "integer" }
      }
    }
  }
}
```

**実装例**
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiZW1haWwiOiJvd25lckBndWVzdGhvdXNlLmNvbSIsImV4cCI6MTczNDU2NzgwMH0.xxx",
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NDc3MjE4MDB9.xxx",
  "token_type": "bearer",
  "expires_in": 604800,
  "user": {
    "id": 1,
    "email": "owner@guesthouse.com",
    "full_name": "John Doe",
    "role": "owner",
    "facility_id": 1
  }
}
```

#### POST `/api/v1/auth/password-reset` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["message"],
  "properties": {
    "message": {
      "type": "string",
      "description": "パスワードリセットメール送信完了メッセージ"
    }
  }
}
```

**実装例**
```json
{
  "message": "Password reset email sent. Please check your inbox."
}
```

#### POST `/api/v1/auth/password-reset/confirm` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["message"],
  "properties": {
    "message": {
      "type": "string",
      "description": "パスワードリセット完了メッセージ"
    }
  }
}
```

**実装例**
```json
{
  "message": "Password reset successfully. You can now login with your new password."
}
```

### 9.3 管理側APIレスポンス

#### GET `/api/v1/admin/dashboard` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["period", "total_questions", "auto_response_rate", "category_breakdown"],
  "properties": {
    "period": {
      "type": "object",
      "required": ["start", "end"],
      "properties": {
        "start": { "type": "string", "format": "date-time" },
        "end": { "type": "string", "format": "date-time" }
      }
    },
    "total_questions": { "type": "integer", "minimum": 0 },
    "auto_response_rate": {
      "type": "number",
      "minimum": 0.0,
      "maximum": 1.0,
      "description": "自動応答率（0.0-1.0）"
    },
    "average_response_time_ms": { "type": "integer", "minimum": 0 },
    "average_confidence": {
      "type": "number",
      "minimum": 0.0,
      "maximum": 1.0,
      "description": "平均信頼度スコア"
    },
    "category_breakdown": {
      "type": "object",
      "properties": {
        "basic": { "type": "integer", "minimum": 0 },
        "facilities": { "type": "integer", "minimum": 0 },
        "location": { "type": "integer", "minimum": 0 },
        "trouble": { "type": "integer", "minimum": 0 }
      }
    },
    "top_questions": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["question", "count"],
        "properties": {
          "question": { "type": "string" },
          "count": { "type": "integer", "minimum": 0 }
        }
      }
    },
    "recent_conversations": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["session_id", "last_message", "created_at"],
        "properties": {
          "session_id": { "type": "string", "format": "uuid" },
          "guest_language": { "type": "string" },
          "last_message": { "type": "string" },
          "ai_confidence": { "type": "number" },
          "created_at": { "type": "string", "format": "date-time" }
        }
      }
    },
    "unresolved_count": { "type": "integer", "minimum": 0 }
  }
}
```

**実装例**
```json
{
  "period": {
    "start": "2025-11-11T00:00:00Z",
    "end": "2025-11-18T00:00:00Z"
  },
  "total_questions": 127,
  "auto_response_rate": 0.88,
  "average_response_time_ms": 2150,
  "average_confidence": 0.85,
  "category_breakdown": {
    "basic": 35,
    "facilities": 48,
    "location": 25,
    "trouble": 7
  },
  "top_questions": [
    {
      "question": "WiFi password?",
      "count": 23
    },
    {
      "question": "Check-in time?",
      "count": 18
    }
  ],
  "recent_conversations": [
    {
      "session_id": "550e8400-e29b-41d4-a716-446655440000",
      "guest_language": "en",
      "last_message": "Where is the laundry room?",
      "ai_confidence": 0.92,
      "created_at": "2025-11-19T10:05:00Z"
    }
  ],
  "unresolved_count": 8
}
```

#### POST `/api/v1/admin/faqs` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["id", "facility_id", "category", "question", "answer", "embedding_generated"],
  "properties": {
    "id": { "type": "integer" },
    "facility_id": { "type": "integer" },
    "category": {
      "type": "string",
      "enum": ["basic", "facilities", "location", "trouble"]
    },
    "language": { "type": "string", "enum": ["en", "ja", "zh-TW", "fr"] },
    "question": { "type": "string", "maxLength": 500 },
    "answer": { "type": "string", "maxLength": 500 },
    "priority": { "type": "integer", "minimum": 1, "maximum": 5 },
    "is_active": { "type": "boolean" },
    "embedding_generated": {
      "type": "boolean",
      "description": "埋め込みベクトル生成完了フラグ"
    },
    "created_at": { "type": "string", "format": "date-time" },
    "updated_at": { "type": "string", "format": "date-time" }
  }
}
```

**実装例**
```json
{
  "id": 15,
  "facility_id": 1,
  "category": "basic",
  "language": "en",
  "question": "What is the WiFi password?",
  "answer": "The WiFi password is guest2024. The SSID is TokyoGuesthouse_WiFi.",
  "priority": 5,
  "is_active": true,
  "embedding_generated": true,
  "created_at": "2025-11-19T10:00:00Z",
  "updated_at": "2025-11-19T10:00:00Z"
}
```

#### GET `/api/v1/admin/escalations` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["escalations", "total", "unresolved"],
  "properties": {
    "escalations": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["id", "facility_id", "conversation_id", "trigger_type", "escalation_mode"],
        "properties": {
          "id": { "type": "integer" },
          "facility_id": { "type": "integer" },
          "conversation_id": { "type": "integer" },
          "trigger_type": {
            "type": "string",
            "enum": ["low_confidence", "keyword", "multiple_turns", "staff_mode"]
          },
          "ai_confidence": { "type": "number", "minimum": 0.0, "maximum": 1.0 },
          "escalation_mode": { "type": "string", "enum": ["normal", "early"] },
          "question": { "type": "string" },
          "language": { "type": "string" },
          "notified_at": { "type": "string", "format": "date-time" },
          "notification_channels": {
            "type": "array",
            "items": { "type": "string", "enum": ["email", "slack", "line"] }
          },
          "resolved_at": { "type": ["string", "null"], "format": "date-time" },
          "resolved_by": { "type": ["integer", "null"] },
          "resolution_notes": { "type": ["string", "null"] },
          "created_at": { "type": "string", "format": "date-time" }
        }
      }
    },
    "total": { "type": "integer", "minimum": 0 },
    "unresolved": { "type": "integer", "minimum": 0 }
  }
}
```

**実装例**
```json
{
  "escalations": [
    {
      "id": 5,
      "facility_id": 1,
      "conversation_id": 10,
      "trigger_type": "low_confidence",
      "ai_confidence": 0.65,
      "escalation_mode": "normal",
      "question": "Can I extend my checkout time?",
      "language": "en",
      "notified_at": "2025-11-19T10:10:00Z",
      "notification_channels": ["email"],
      "resolved_at": null,
      "resolved_by": null,
      "resolution_notes": null,
      "created_at": "2025-11-19T10:10:00Z"
    }
  ],
  "total": 8,
  "unresolved": 8
}
```

#### POST `/api/v1/admin/escalation-schedule` レスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["id", "facility_id", "day_of_week", "time_start", "time_end", "mode", "threshold"],
  "properties": {
    "id": { "type": "integer" },
    "facility_id": { "type": "integer" },
    "day_of_week": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": ["mon", "tue", "wed", "thu", "fri", "sat", "sun", "all"]
      },
      "description": "曜日配列、または['all']で全曜日"
    },
    "time_start": {
      "type": "string",
      "pattern": "^\\d{2}:\\d{2}$",
      "description": "開始時間（HH:MM形式）"
    },
    "time_end": {
      "type": "string",
      "pattern": "^\\d{2}:\\d{2}$",
      "description": "終了時間（HH:MM形式）"
    },
    "mode": {
      "type": "string",
      "enum": ["normal", "early"],
      "description": "エスカレーションモード"
    },
    "threshold": {
      "type": "number",
      "minimum": 0.0,
      "maximum": 1.0,
      "description": "信頼度閾値（0.70 or 0.85）"
    },
    "languages": {
      "type": "array",
      "items": { "type": "string", "enum": ["en", "ja", "zh-TW", "fr"] }
    },
    "notify_channels": {
      "type": "array",
      "items": { "type": "string", "enum": ["email", "slack", "line"] }
    },
    "is_active": { "type": "boolean" },
    "created_at": { "type": "string", "format": "date-time" },
    "updated_at": { "type": "string", "format": "date-time" }
  }
}
```

**実装例**
```json
{
  "id": 3,
  "facility_id": 1,
  "day_of_week": ["mon", "tue", "wed", "thu", "fri"],
  "time_start": "09:00",
  "time_end": "18:00",
  "mode": "early",
  "threshold": 0.85,
  "languages": ["en", "ja"],
  "notify_channels": ["email"],
  "is_active": true,
  "created_at": "2025-11-19T10:00:00Z",
  "updated_at": "2025-11-19T10:00:00Z"
}
```

### 9.4 エラーレスポンススキーマ

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "required": ["error"],
  "properties": {
    "error": {
      "type": "object",
      "required": ["code", "message"],
      "properties": {
        "code": {
          "type": "string",
          "enum": [
            "INVALID_REQUEST",
            "UNAUTHORIZED",
            "FORBIDDEN",
            "NOT_FOUND",
            "VALIDATION_ERROR",
            "RATE_LIMIT_EXCEEDED",
            "INTERNAL_ERROR",
            "SERVICE_UNAVAILABLE"
          ]
        },
        "message": {
          "type": "string",
          "description": "人間が読めるエラーメッセージ"
        },
        "details": {
          "type": "object",
          "description": "追加のエラー詳細情報"
        }
      }
    }
  }
}
```

**実装例 - 401 Unauthorized**
```json
{
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Invalid or expired token",
    "details": {
      "token_type": "access_token"
    }
  }
}
```

**実装例 - 422 Validation Error**
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": {
      "field": "email",
      "reason": "Invalid email format"
    }
  }
}
```

**実装例 - 503 Service Unavailable (OpenAI API障害時)**
```json
{
  "error": {
    "code": "SERVICE_UNAVAILABLE",
    "message": "AI service is temporarily unavailable. Please try again later.",
    "details": {
      "service": "openai_api",
      "error_type": "timeout",
      "retry_after": 60
    }
  }
}
```

### 9.5 Pydanticスキーマ実装例（FastAPI）

#### チャットレスポンススキーマ

```python
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class EscalationInfo(BaseModel):
    needed: bool
    mode: Optional[str] = Field(None, enum=["normal", "early"])
    trigger_type: Optional[str] = Field(
        None, 
        enum=["low_confidence", "keyword", "multiple_turns", "staff_mode"]
    )
    reason: Optional[str] = None
    notified: Optional[bool] = None

class ChatResponse(BaseModel):
    message_id: int
    session_id: str = Field(..., description="Cookieに保存するセッションID")
    response: str = Field(..., max_length=500)
    ai_confidence: float = Field(..., ge=0.0, le=1.0)
    source: str = Field(..., enum=["rag_generated", "escalation_needed"])
    matched_faq_ids: List[int] = Field(default_factory=list)
    response_time_ms: int = Field(..., ge=0)
    escalation: EscalationInfo
```

#### エスカレーションスケジュールスキーマ

```python
from pydantic import BaseModel, Field
from typing import List
from datetime import datetime

class EscalationScheduleCreate(BaseModel):
    day_of_week: List[str] = Field(
        ...,
        description="曜日配列、または['all']で全曜日"
    )
    time_start: str = Field(..., pattern=r"^\d{2}:\d{2}$")
    time_end: str = Field(..., pattern=r"^\d{2}:\d{2}$")
    mode: str = Field(..., enum=["normal", "early"])
    threshold: float = Field(..., ge=0.0, le=1.0)
    languages: List[str] = Field(default=["en", "ja"])
    notify_channels: List[str] = Field(default=["email"])

class EscalationScheduleResponse(BaseModel):
    id: int
    facility_id: int
    day_of_week: List[str]
    time_start: str
    time_end: str
    mode: str
    threshold: float
    languages: List[str]
    notify_channels: List[str]
    is_active: bool
    created_at: datetime
    updated_at: datetime
```

---

## 10. 認証・セキュリティ

### 10.1 認証フロー（v0.2）

#### 管理者ログイン

```
┌─────────┐
│ Client  │
└────┬────┘
     │ 1. POST /api/v1/auth/login
     │    {email, password}
     ↓
┌────────────────┐
│ FastAPI        │
│ auth.py        │
└────┬───────────┘
     │ 2. Verify password (bcrypt)
     ↓
┌────────────────┐
│ security.py    │
│ verify_password│
└────┬───────────┘
     │ 3. Generate JWT
     ↓
┌────────────────┐
│ jwt.py         │
│ create_tokens  │
│ - access_token │ (7日間有効) v0.2変更
│ - refresh_token│ (30日間有効) v0.2変更
└────┬───────────┘
     │ 4. Return tokens
     ↓
┌─────────┐
│ Client  │
│ Store:  │
│ - access_token (localStorage)
│ - refresh_token (localStorage)
└─────────┘
```

#### ゲストセッション（v0.2）

```
┌─────────┐
│ Guest   │
└────┬────┘
     │ 1. Scan QR code
     │    /f/{facility_slug}?location=entrance
     ↓
┌────────────────┐
│ Vue Router     │
└────┬───────────┘
     │ 2. POST /api/v1/chat
     │    (初回: session_idなし)
     ↓
┌────────────────┐
│ FastAPI        │
│ chat.py        │
└────┬───────────┘
     │ 3. Create session_id (UUID)
     │    Store in conversations table
     │    Store in Redis (v0.2追加)
     ↓
┌─────────┐
│ Client  │
│ Store session_id in Cookie:
│ - Name: tabipera_session
│ - HttpOnly: false (JSからアクセス必要)
│ - Secure: true (本番環境)
│ - SameSite: Lax
│ - Max-Age: 86400 (24時間) v0.2
│ - Path: /
└─────────┘
```

### 10.2 JWT設定（v0.2）

#### アクセストークン

```python
# app/core/jwt.py

ACCESS_TOKEN_EXPIRE_MINUTES = 10080  # v0.2変更: 7日間（v0.1では60分）

payload = {
    "sub": str(user.id),
    "email": user.email,
    "facility_id": user.facility_id,
    "role": user.role,
    "exp": datetime.utcnow() + timedelta(minutes=10080),
    "iat": datetime.utcnow(),
    "type": "access"
}

token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

#### リフレッシュトークン

```python
REFRESH_TOKEN_EXPIRE_DAYS = 30  # v0.2変更: 30日間（v0.1では7日間）

payload = {
    "sub": str(user.id),
    "exp": datetime.utcnow() + timedelta(days=30),
    "iat": datetime.utcnow(),
    "type": "refresh"
}

refresh_token = jwt.encode(payload, SECRET_KEY, algorithm="HS256")
```

#### JWT検証

```python
# app/api/deps.py

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """
    JWTトークンから現在のユーザーを取得
    """
    token = credentials.credentials
    
    try:
        payload = jwt.decode(
            token, 
            settings.SECRET_KEY, 
            algorithms=[settings.ALGORITHM]
        )
        
        if payload.get("type") != "access":
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token type"
            )
        
        user_id = payload.get("sub")
        if user_id is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token"
            )
        
        user = await db.get(User, int(user_id))
        if user is None or not user.is_active:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found or inactive"
            )
        
        return user
    
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token"
        )
```

### 10.3 セッション管理（v0.2）

#### Cookie設定（フロントエンド）

```typescript
// src/utils/cookies.ts

import Cookies from 'js-cookie';

export const SESSION_COOKIE_NAME = 'tabipera_session';
export const SESSION_MAX_AGE = 86400; // 24時間（秒）

export function setSessionCookie(sessionId: string): void {
  Cookies.set(SESSION_COOKIE_NAME, sessionId, {
    expires: 1, // 1日
    secure: import.meta.env.PROD, // 本番環境のみHTTPS
    sameSite: 'Lax',
    path: '/'
  });
}

export function getSessionCookie(): string | undefined {
  return Cookies.get(SESSION_COOKIE_NAME);
}

export function removeSessionCookie(): void {
  Cookies.remove(SESSION_COOKIE_NAME, { path: '/' });
}
```

#### セッション有効性チェック（バックエンド）

```python
# app/utils/session.py

from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.conversation import Conversation
from app.core.redis_client import redis_client

async def is_session_valid(
    session_id: str, 
    db: AsyncSession
) -> bool:
    """
    セッションが有効かチェック（v0.2）
    - Redisキャッシュ確認（高速化）
    - データベース確認
    - 24時間以内のアクティビティ確認
    """
    # 1. Redisキャッシュ確認（v0.2追加）
    cache_key = f"session:{session_id}"
    cached = await redis_client.get(cache_key)
    if cached:
        return True
    
    # 2. データベース確認
    conversation = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id,
            Conversation.is_active == True
        )
    )
    conversation = conversation.scalar_one_or_none()
    
    if conversation is None:
        return False
    
    # 3. 24時間以内のアクティビティ確認
    now = datetime.utcnow()
    if conversation.last_activity_at < now - timedelta(hours=24):
        # セッション無効化
        conversation.is_active = False
        await db.commit()
        return False
    
    # 4. Redisにキャッシュ（v0.2追加）
    remaining_seconds = int(
        (conversation.last_activity_at + timedelta(hours=24) - now).total_seconds()
    )
    if remaining_seconds > 0:
        await redis_client.setex(
            cache_key,
            remaining_seconds,
            "1"
        )
    
    return True

async def update_session_activity(
    session_id: str,
    db: AsyncSession
) -> None:
    """
    セッションのアクティビティを更新
    """
    conversation = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id
        )
    )
    conversation = conversation.scalar_one_or_none()
    
    if conversation:
        conversation.last_activity_at = datetime.utcnow()
        await db.commit()
        
        # Redisキャッシュ更新（v0.2追加）
        cache_key = f"session:{session_id}"
        await redis_client.setex(cache_key, 86400, "1")
```

### 10.4 パスワードリセットフロー（v0.2）

```
┌─────────┐
│ User    │
└────┬────┘
     │ 1. POST /api/v1/auth/password-reset
     │    {email}
     ↓
┌────────────────────────┐
│ FastAPI                │
│ auth.py                │
│ - ユーザー存在確認      │
│ - リセットトークン生成  │
│   (UUID, 有効期限1時間) │
│ - usersテーブルに保存   │
│   password_reset_token  │
│   password_reset_expires│
│ - メール送信            │
└────┬───────────────────┘
     │ 2. Email送信
     │    Subject: [やどぺら] パスワードリセット
     │    Link: /admin/password-reset/confirm?token={token}
     ↓
┌─────────┐
│ User    │
│ Click link│
└────┬────┘
     │ 3. GET /admin/password-reset/confirm?token={token}
     │    - トークン検証（有効期限確認）
     ↓
┌─────────┐
│ User    │
│ 新パスワード入力│
└────┬────┘
     │ 4. POST /api/v1/auth/password-reset/confirm
     │    {token, new_password}
     ↓
┌────────────────────────┐
│ FastAPI                │
│ - トークン検証          │
│ - パスワード検証        │
│   (最小8文字、複雑度)   │
│ - パスワード更新        │
│   (bcryptハッシュ化)    │
│ - トークン無効化        │
│   password_reset_token = NULL
│   password_reset_expires = NULL
│ - 完了通知              │
└────────────────────────┘
```

#### パスワードリセット実装例

```python
# app/services/auth_service.py

from datetime import datetime, timedelta
from uuid import uuid4
from passlib.context import CryptContext
from app.models.user import User
from app.utils.email import send_password_reset_email

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

async def request_password_reset(
    email: str,
    db: AsyncSession
) -> dict:
    """
    パスワードリセット要求（v0.2）
    """
    user = await db.execute(
        select(User).where(User.email == email, User.is_active == True)
    )
    user = user.scalar_one_or_none()
    
    if not user:
        # セキュリティのため、ユーザーが存在しない場合も成功レスポンスを返す
        return {"message": "Password reset email sent. Please check your inbox."}
    
    # リセットトークン生成
    reset_token = str(uuid4())
    expires_at = datetime.utcnow() + timedelta(hours=1)
    
    # ユーザーテーブルに保存
    user.password_reset_token = reset_token
    user.password_reset_expires = expires_at
    await db.commit()
    
    # メール送信
    reset_url = f"{settings.FRONTEND_URL}/admin/password-reset/confirm?token={reset_token}"
    await send_password_reset_email(user.email, reset_url)
    
    return {"message": "Password reset email sent. Please check your inbox."}

async def confirm_password_reset(
    token: str,
    new_password: str,
    db: AsyncSession
) -> dict:
    """
    パスワードリセット確定（v0.2）
    """
    # トークン検証
    user = await db.execute(
        select(User).where(
            User.password_reset_token == token,
            User.password_reset_expires > datetime.utcnow()
        )
    )
    user = user.scalar_one_or_none()
    
    if not user:
        raise HTTPException(
            status_code=400,
            detail="Invalid or expired token"
        )
    
    # パスワード検証
    if len(new_password) < 8:
        raise HTTPException(
            status_code=422,
            detail="Password must be at least 8 characters"
        )
    
    # パスワード更新
    user.password_hash = pwd_context.hash(new_password)
    user.password_reset_token = None
    user.password_reset_expires = None
    await db.commit()
    
    return {"message": "Password reset successfully. You can now login with your new password."}
```

### 10.5 セキュリティ対策

#### CORS設定

```python
# app/main.py

from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://yadopera.com",
        "https://admin.yadopera.com",
        "http://localhost:5173",  # 開発環境
        "http://localhost:3000"   # 開発環境
    ],
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["*"],
    expose_headers=["*"]
)
```

#### Rate Limiting（Redis使用、v0.2）

```python
# app/utils/rate_limit.py

from fastapi import Request, HTTPException, status
from app.core.redis_client import redis_client
import time

async def rate_limit_check(
    request: Request,
    key: str,
    limit: int,
    window: int = 60  # 秒
) -> None:
    """
    Rate Limitingチェック（Redis使用、v0.2）
    """
    # IPアドレス取得
    client_ip = request.client.host
    rate_limit_key = f"rate_limit:{key}:{client_ip}"
    
    # 現在のリクエスト数取得
    current = await redis_client.get(rate_limit_key)
    
    if current and int(current) >= limit:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail={
                "error": {
                    "code": "RATE_LIMIT_EXCEEDED",
                    "message": "Too many requests. Please try again later.",
                    "details": {
                        "retry_after": window
                    }
                }
            }
        )
    
    # リクエスト数インクリメント
    if current:
        await redis_client.incr(rate_limit_key)
    else:
        await redis_client.setex(rate_limit_key, window, "1")

# 使用例
@router.post("/api/v1/chat")
async def chat_message(
    request: Request,
    chat_request: ChatRequest,
    db: AsyncSession = Depends(get_db)
):
    await rate_limit_check(request, "chat", limit=60, window=60)
    # ... 処理続行
```

#### SQL Injection対策

- **SQLAlchemy ORM使用**: パラメータ化クエリで自動的にSQL Injectionを防止
- **Raw SQL禁止**: 直接SQLを書かない
- **入力検証**: Pydanticスキーマで自動バリデーション

```python
# 安全な例
user = await db.execute(
    select(User).where(User.email == email)  # パラメータ化クエリ
)

# 危険な例（使用禁止）
# user = await db.execute(f"SELECT * FROM users WHERE email = '{email}'")  # SQL Injection脆弱性
```

#### XSS対策

- **Vue.js自動エスケープ**: デフォルトでHTMLエスケープ
- **v-html使用禁止**: ユーザー入力の直接表示は禁止
- **Content Security Policy**: ヘッダーで設定（Phase 2）

```vue
<!-- 安全な例 -->
<template>
  <div>{{ userInput }}</div>  <!-- 自動エスケープ -->
</template>

<!-- 危険な例（使用禁止） -->
<template>
  <div v-html="userInput"></div>  <!-- XSS脆弱性 -->
</template>
```

#### パスワードセキュリティ

```python
# app/core/security.py

from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """
    パスワードをbcryptでハッシュ化
    """
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """
    パスワード検証
    """
    return pwd_context.verify(plain_password, hashed_password)

# パスワード強度チェック
def validate_password_strength(password: str) -> bool:
    """
    パスワード強度検証（v0.2）
    - 最小8文字
    - 大文字・小文字・数字を含む（推奨）
    """
    if len(password) < 8:
        return False
    # 追加の検証ロジック（オプション）
    return True
```

#### データ暗号化

```python
# WiFiパスワード等の機密情報は暗号化保存（v0.2）

from cryptography.fernet import Fernet
import os

# 環境変数から暗号化キー取得
ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY")
cipher = Fernet(ENCRYPTION_KEY.encode())

def encrypt_sensitive_data(data: str) -> str:
    """
    機密データの暗号化
    """
    return cipher.encrypt(data.encode()).decode()

def decrypt_sensitive_data(encrypted_data: str) -> str:
    """
    機密データの復号化
    """
    return cipher.decrypt(encrypted_data.encode()).decode()
```

### 10.6 セキュリティヘッダー

```python
# app/main.py

from fastapi.middleware.trustedhost import TrustedHostMiddleware

# Trusted Host Middleware
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["yadopera.com", "admin.yadopera.com", "*.yadopera.com"]
)

# セキュリティヘッダー（カスタムミドルウェア）
@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    response = await call_next(request)
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    return response
```

### 10.7 セッション管理のベストプラクティス（v0.2）

1. **Cookie設定**
   - `HttpOnly: false`（JSからアクセス必要、ゲストセッション管理のため）
   - `Secure: true`（本番環境のみ）
   - `SameSite: Lax`（CSRF対策）

2. **セッション有効期限**
   - 24時間無動作で自動終了
   - `last_activity_at`で判定

3. **Redisキャッシュ**
   - セッション有効性をRedisにキャッシュ（高速化）
   - 24時間のTTL設定

4. **複数デバイス対応**
   - 同一セッションIDで複数デバイスからアクセス可能
   - ゲストの行動パターンを考慮

---

## 11. AI対話エンジン設計（RAG統合型）

### 11.1 RAG統合型処理フロー（v0.3）

```
ゲスト質問受付
    ↓
Step 0: 安全カテゴリ判定★v0.3新規
    ├─ 医療関連キーワード検出
    ├─ 安全・避難関連キーワード検出
    └─ 検出時: 即エスカレーション（閾値無視）
    ↓ (通常質問のみ)
Step 1: 埋め込みベクトル生成
    ├─ OpenAI Embeddings API
    ├─ Model: text-embedding-3-small
    └─ 出力: 1536次元ベクトル
    ↓
Step 2: pgvector検索
    ├─ コサイン類似度計算
    ├─ IVFFlatインデックス使用
    ├─ Top 3 FAQ取得
    └─ 類似度スコア取得
    ↓
Step 3: コンテキスト構築
    ├─ 関連FAQ Top 3: 約300トークン
    ├─ 施設基本情報: 約150トークン
    ├─ システムプロンプト: 約100トークン
    └─ ゲスト質問: 約50トークン
    合計: 約600トークン（v0.1比50%削減）
    ↓
Step 4: GPT-4o-mini回答生成
    ├─ Model: gpt-4o-mini-2024-07-18
    ├─ Max tokens: 200
    ├─ Temperature: 0.7
    └─ 回答生成
    ↓
Step 5: 信頼度スコア計算★v0.3改善
    ├─ ベーススコア: 0.7
    ├─ FAQ類似度ボーナス（0.8以上: +0.3）
    ├─ 回答長ペナルティ（20文字未満: -0.2）
    ├─ 不確実性ワード検出（maybe等: -0.15）
    ├─ 質問具体性スコア（固有名詞・数値: +0.1）★新規
    ├─ 過去同一質問解決率（80%以上: +0.15）★新規
    └─ 施設カスタムFAQヒット（+0.2）★新規
    ↓
Step 6: エスカレーション判定
    ├─ 現在時刻・曜日取得
    ├─ エスカレーションスケジュール検索
    ├─ 閾値判定（通常0.7 / 早期0.85）
    ├─ 緊急キーワード検出
    ├─ 安全カテゴリは即エスカレ★v0.3新規
    └─ 3往復以上未解決チェック
    ↓
回答返却 or エスカレーション
    ↓ (エスカレーション時、22:00-8:00)
夜間対応キュー追加★v0.3新規
    ├─ 自動返信メッセージ送信
    ├─ overnight_queueテーブル保存
    └─ 翌朝8:00一括通知
```

### 11.2 実装コード（RAG統合型）

#### メインエンジン

```python
# app/ai/engine.py

from typing import List, Optional
from app.ai.embeddings import generate_embedding
from app.ai.vector_search import search_similar_faqs
from app.ai.confidence import calculate_confidence
from app.services.escalation_service import check_escalation_needed
from app.ai.openai_client import OpenAIClient

class RAGChatEngine:
    """
    RAG統合型AI対話エンジン（v0.2）
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.openai_client = OpenAIClient()
    
    async def process_message(
        self,
        message: str,
        facility_id: int,
        session_id: str,
        language: str = "en"
    ) -> ChatResponse:
        """
        RAG統合型でメッセージを処理
        """
        start_time = time.time()
        
        # Step 1: 埋め込みベクトル生成
        question_embedding = await generate_embedding(message)
        
        # Step 2: pgvector検索（Top 3 FAQ取得）
        similar_faqs = await search_similar_faqs(
            facility_id=facility_id,
            embedding=question_embedding,
            top_k=3,
            threshold=0.7  # コサイン類似度閾値
        )
        
        # Step 3: コンテキスト構築
        facility = await self._get_facility_info(facility_id)
        context = self._build_context(facility, similar_faqs, message)
        
        # Step 4: GPT-4o-mini回答生成
        ai_response = await self.openai_client.generate_response(
            prompt=context,
            max_tokens=200,
            temperature=0.7
        )
        
        # Step 5: 信頼度スコア計算
        confidence = await calculate_confidence(
            response_text=ai_response.text,
            similar_faqs=similar_faqs,
            question=message
        )
        
        # Step 6: エスカレーション判定
        escalation_info = await check_escalation_needed(
            facility_id=facility_id,
            confidence=confidence,
            message=message,
            session_id=session_id,
            db=self.db
        )
        
        response_time_ms = int((time.time() - start_time) * 1000)
        
        # メッセージ保存
        await self._save_message(
            conversation_id=conversation_id,
            role="assistant",
            content=ai_response.text,
            ai_confidence=confidence,
            matched_faq_ids=[faq.id for faq in similar_faqs],
            response_time_ms=response_time_ms
        )
        
        return ChatResponse(
            message_id=message_id,
            session_id=session_id,
            response=ai_response.text,
            ai_confidence=confidence,
            source="rag_generated" if not escalation_info.needed else "escalation_needed",
            matched_faq_ids=[faq.id for faq in similar_faqs],
            response_time_ms=response_time_ms,
            escalation=escalation_info
        )
```

#### 埋め込みベクトル生成

```python
# app/ai/embeddings.py

from openai import OpenAI
from app.core.config import settings

async def generate_embedding(text: str) -> List[float]:
    """
    テキストを埋め込みベクトルに変換（v0.2）
    Model: text-embedding-3-small (1536次元)
    """
    client = OpenAI(api_key=settings.OPENAI_API_KEY)
    
    response = client.embeddings.create(
        model="text-embedding-3-small",
        input=text
    )
    
    return response.data[0].embedding

async def generate_faq_embedding(faq: FAQ) -> List[float]:
    """
    FAQの埋め込みベクトル生成（保存時自動実行）
    """
    # 質問と回答を結合して埋め込み生成
    combined_text = f"{faq.question} {faq.answer}"
    return await generate_embedding(combined_text)
```

#### pgvector検索

```python
# app/ai/vector_search.py

from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from pgvector.sqlalchemy import Vector
from app.models.faq import FAQ

async def search_similar_faqs(
    facility_id: int,
    embedding: List[float],
    top_k: int = 3,
    threshold: float = 0.7,
    db: AsyncSession
) -> List[FAQ]:
    """
    pgvectorで類似FAQ検索（v0.2）
    コサイン類似度を使用
    """
    # ベクトルをPostgreSQL形式に変換
    embedding_vector = f"[{','.join(map(str, embedding))}]"
    
    # コサイン類似度で検索（1 - コサイン距離 = 類似度）
    query = select(
        FAQ,
        1 - func.cosine_distance(FAQ.embedding, embedding_vector).label('similarity')
    ).where(
        FAQ.facility_id == facility_id,
        FAQ.is_active == True,
        FAQ.embedding.isnot(None)  # 埋め込みベクトルが存在するもののみ
    ).order_by(
        func.cosine_distance(FAQ.embedding, embedding_vector).asc()
    ).limit(top_k)
    
    result = await db.execute(query)
    results = result.all()
    
    # 閾値以上の類似度のFAQのみ返す
    similar_faqs = []
    for faq, similarity in results:
        if similarity >= threshold:
            similar_faqs.append(faq)
    
    return similar_faqs
```

#### コンテキスト構築

```python
# app/ai/engine.py

def _build_context(
    self,
    facility: Facility,
    similar_faqs: List[FAQ],
    question: str
) -> str:
    """
    コンテキスト構築（約600トークン）
    """
    # 関連FAQ Top 3（約300トークン）
    faq_context = "\n".join([
        f"Q: {faq.question}\nA: {faq.answer}"
        for faq in similar_faqs[:3]
    ])
    
    # 施設基本情報（約150トークン）
    facility_info = f"""
Facility: {facility.name}
Check-in: {facility.check_in_time}
Check-out: {facility.check_out_time}
WiFi SSID: {facility.wifi_ssid}
House Rules: {facility.house_rules[:200]}
Local Info: {facility.local_info[:200]}
"""
    
    # システムプロンプト（約100トークン）
    system_prompt = """
You are a helpful assistant for a guesthouse.
Answer guests' questions based on the provided FAQs and facility information.
Be friendly, concise (under 200 characters), and helpful.
If you cannot answer confidently, suggest contacting staff.
"""
    
    # ゲスト質問（約50トークン）
    guest_question = f"Guest question: {question}"
    
    # コンテキスト結合
    context = f"""{system_prompt}

## Facility Information:
{facility_info}

## Relevant FAQs:
{faq_context}

## Guest's Question:
{guest_question}

## Your Response:
"""
    
    return context
```

#### 安全カテゴリ判定（v0.3新規）

```python
# app/ai/safety_check.py

# 医療関連キーワード
MEDICAL_KEYWORDS = [
    'hospital', 'doctor', 'ambulance', 'emergency', 'sick', 'injured',
    'fever', 'allergy', 'medicine', 'pharmacy', 'pain', 'bleeding', 'unconscious',
    '病院', '医者', '救急車', '具合悪い', '怪我', '熱', 'アレルギー', '薬', '痛い'
]

# 安全・避難関連キーワード
SAFETY_KEYWORDS = [
    'fire', 'earthquake', 'evacuation', 'escape', 'escape route',
    'emergency exit', 'tsunami', 'typhoon',
    '火災', '火事', '地震', '避難', '非常口', '津波', '台風'
]

def check_safety_category(question: str) -> bool:
    """
    安全カテゴリ判定（v0.3新規）
    医療・安全関連キーワード検出時は即エスカレーション
    """
    question_lower = question.lower()
    
    # 医療関連キーワード検出
    if any(keyword in question_lower for keyword in MEDICAL_KEYWORDS):
        return True
    
    # 安全・避難関連キーワード検出
    if any(keyword in question_lower for keyword in SAFETY_KEYWORDS):
        return True
    
    return False
```

#### 信頼度スコア計算（v0.3改善版）

```python
# app/ai/confidence.py

from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.models.faq import FAQ
from app.models.question_pattern import QuestionPattern

async def calculate_confidence(
    response_text: str,
    similar_faqs: List[FAQ],
    question: str,
    facility_id: int,
    db: AsyncSession
) -> float:
    """
    信頼度スコア計算（v0.3改善版）
    0.0-1.0の範囲
    """
    base_confidence = 0.7
    
    # FAQ類似度ボーナス（v0.2継続）
    if similar_faqs:
        # 最高類似度を取得
        max_similarity = max([faq.similarity for faq in similar_faqs if hasattr(faq, 'similarity')])
        if max_similarity >= 0.8:
            base_confidence += 0.3  # +0.3ボーナス
        elif max_similarity >= 0.7:
            base_confidence += 0.15  # +0.15ボーナス
    
    # 回答長ペナルティ（v0.2継続）
    if len(response_text) < 20:
        base_confidence -= 0.2  # -0.2ペナルティ
    
    # 不確実性ワード検出（v0.2継続）
    uncertain_phrases = [
        "i'm not sure",
        "i don't know",
        "maybe",
        "probably",
        "might be",
        "i think",
        "possibly"
    ]
    
    response_lower = response_text.lower()
    if any(phrase in response_lower for phrase in uncertain_phrases):
        base_confidence -= 0.15  # -0.15ペナルティ
    
    # v0.3新規: 質問具体性スコア（固有名詞・数値含む）
    import re
    has_proper_noun = bool(re.search(r'\b[A-Z][a-z]+\b', question))  # 固有名詞検出
    has_number = bool(re.search(r'\d+', question))  # 数値検出
    if has_proper_noun or has_number:
        base_confidence += 0.1  # +0.1ボーナス
    
    # v0.3新規: 過去同一質問解決率（80%以上で+0.15）
    from app.ai.embeddings import generate_embedding
    question_embedding = await generate_embedding(question)
    # question_patternsテーブルから類似パターンを検索
    # （実装詳細は省略、resolution_rate >= 0.8の場合）
    # if pattern_resolution_rate >= 0.8:
    #     base_confidence += 0.15
    
    # v0.3新規: 施設カスタムFAQヒット（テンプレート以外）
    if similar_faqs:
        # テンプレートFAQはcreated_byがNULL、カスタムFAQはユーザーIDが設定
        has_custom_faq = any(faq.created_by is not None for faq in similar_faqs)
        if has_custom_faq:
            base_confidence += 0.2  # +0.2ボーナス
    
    # 0.0-1.0の範囲にクリップ
    return max(0.0, min(1.0, base_confidence))
```

### 11.3 プロンプトテンプレート（RAG統合型）

```python
# app/ai/prompts.py

RAG_SYSTEM_PROMPT = """
You are a helpful assistant for {facility_name}, a guesthouse.

## Your role:
- Answer guests' questions based on the provided FAQs and facility information.
- Be friendly, concise (under 200 characters), and helpful.
- If you cannot answer confidently, suggest contacting staff.

## Facility Information:
{facility_info}

## Relevant FAQs (from vector search):
{faqs}

## Guest's question:
{question}

## Your Response (in English, under 200 characters):
"""

def build_rag_prompt(
    facility: Facility,
    similar_faqs: List[FAQ],
    question: str
) -> str:
    """
    RAG統合型プロンプト生成（v0.2）
    """
    facility_info = f"""
- Name: {facility.name}
- Check-in: {facility.check_in_time}
- Check-out: {facility.check_out_time}
- WiFi SSID: {facility.wifi_ssid}
- House Rules: {facility.house_rules}
- Local Info: {facility.local_info}
"""
    
    faq_text = "\n".join([
        f"Q: {faq.question}\nA: {faq.answer}"
        for faq in similar_faqs
    ])
    
    return RAG_SYSTEM_PROMPT.format(
        facility_name=facility.name,
        facility_info=facility_info,
        faqs=faq_text,
        question=question
    )
```

### 11.4 FAQ埋め込みベクトル自動生成

```python
# app/services/faq_service.py

async def create_faq(
    faq_data: FAQCreate,
    facility_id: int,
    user_id: int,
    db: AsyncSession
) -> FAQ:
    """
    FAQ作成（埋め込みベクトル自動生成、v0.2）
    """
    # FAQ作成
    faq = FAQ(
        facility_id=facility_id,
        category=faq_data.category,
        language=faq_data.language,
        question=faq_data.question,
        answer=faq_data.answer,
        priority=faq_data.priority,
        created_by=user_id
    )
    
    db.add(faq)
    await db.flush()  # IDを取得するため
    
    # 埋め込みベクトル生成
    combined_text = f"{faq.question} {faq.answer}"
    embedding = await generate_embedding(combined_text)
    
    # ベクトルをPostgreSQL形式に変換
    faq.embedding = embedding
    
    await db.commit()
    await db.refresh(faq)
    
    return faq

async def update_faq(
    faq_id: int,
    faq_data: FAQUpdate,
    db: AsyncSession
) -> FAQ:
    """
    FAQ更新（質問・回答変更時は埋め込みベクトル再生成、v0.2）
    """
    faq = await db.get(FAQ, faq_id)
    
    # 質問・回答が変更された場合、埋め込みベクトル再生成
    if faq_data.question or faq_data.answer:
        if faq_data.question:
            faq.question = faq_data.question
        if faq_data.answer:
            faq.answer = faq_data.answer
        
        # 埋め込みベクトル再生成
        combined_text = f"{faq.question} {faq.answer}"
        embedding = await generate_embedding(combined_text)
        faq.embedding = embedding
    
    # その他のフィールド更新
    if faq_data.category:
        faq.category = faq_data.category
    if faq_data.priority is not None:
        faq.priority = faq_data.priority
    if faq_data.is_active is not None:
        faq.is_active = faq_data.is_active
    
    await db.commit()
    await db.refresh(faq)
    
    return faq
```

### 11.5 コスト効率（RAG統合による改善）

#### v0.1（従来方式）との比較

**v0.1（従来方式）**
- プロンプト: 約1,200トークン（全FAQ含む）
- 1質問あたり: 約¥0.064
- 月100件/施設: ¥6.4/月

**v0.2（RAG統合型）**
- プロンプト: 約600トークン（関連FAQ Top 3のみ）
- 1質問あたり: **¥0.033**（48%削減）
  - Input: 600トークン × $0.15/1M = $0.00009
  - Output: 200トークン × $0.60/1M = $0.00012
  - Embedding: 1回 × $0.02/1M = $0.00003（無視可能）
  - 合計: $0.00021 × ¥155 = ¥0.033
- 月100件/施設: ¥3.3/月

**削減効果**
- コスト削減率: 48%
- プロンプトサイズ: 50%削減
- レスポンス品質: 維持（関連FAQのみ使用で精度向上）

### 11.6 OpenAI API障害時フォールバック

```python
# app/ai/openai_client.py

class OpenAIClient:
    """
    OpenAI APIラッパー（フォールバック対応、v0.2）
    """
    
    FALLBACK_MESSAGES = {
        "en": (
            "Sorry, the automatic support system is temporarily unavailable. "
            "Please contact the staff directly for assistance."
        ),
        "ja": (
            "現在、自動案内システムが一時的に利用できません。"
            "お手数ですがスタッフへ直接お問い合わせください。"
        )
    }
    
    async def generate_response(
        self,
        prompt: str,
        max_tokens: int = 200,
        temperature: float = 0.7,
        language: str = "en"
    ) -> str:
        """
        AI応答生成（フォールバック付き）
        """
        try:
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini-2024-07-18",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                temperature=temperature,
                timeout=5.0  # 5秒タイムアウト
            )
            return response.choices[0].message.content
        
        except OpenAIError as e:
            # ログ記録
            logger.error(
                "OpenAI API error",
                extra={
                    "error_type": type(e).__name__,
                    "error_message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                }
            )
            
            # フォールバックメッセージ返却
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
        
        except Exception as e:
            logger.critical(f"Unexpected error in AI generation: {e}", exc_info=True)
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
    
    async def generate_embedding(
        self,
        text: str
    ) -> List[float]:
        """
        埋め込みベクトル生成（フォールバック付き）
        """
        try:
            response = await self.client.embeddings.create(
                model="text-embedding-3-small",
                input=text,
                timeout=3.0
            )
            return response.data[0].embedding
        
        except OpenAIError as e:
            logger.error(f"OpenAI Embeddings API error: {e}")
            # 埋め込み生成失敗時は空ベクトル返却（検索結果なしになる）
            return [0.0] * 1536
        
        except Exception as e:
            logger.critical(f"Unexpected error in embedding generation: {e}", exc_info=True)
            return [0.0] * 1536
```

### 11.7 パフォーマンス最適化

#### pgvectorインデックス最適化

```sql
-- IVFFlatインデックス作成（高速近似最近傍探索）
CREATE INDEX idx_faqs_embedding ON faqs 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- データ量に応じたリスト数調整
-- 100件以下: lists = 10
-- 100-1000件: lists = 100
-- 1000件以上: lists = 1000

-- インデックス再構築（データ追加後）
REINDEX INDEX idx_faqs_embedding;
```

#### キャッシュ戦略（Phase 2）

```python
# 頻出FAQの埋め込みベクトルをRedisにキャッシュ
# 同じ質問パターンが来た場合、埋め込み生成をスキップ
```

---

## 12. エスカレーション管理

### 12.1 エスカレーション判定フロー（v0.3）

```
AI回答生成完了
    ↓
判定0: 安全カテゴリ判定★v0.3新規
    ├─ 医療関連キーワード検出 → 即エスカレーション（閾値無視）
    ├─ 安全・避難関連キーワード検出 → 即エスカレーション（閾値無視）
    └─ 通常質問 → 次へ
    ↓
信頼度スコア取得
    ↓
現在時刻・曜日・言語取得
    ↓
エスカレーションスケジュール検索
    ├─ 該当スケジュールあり
    │   ├─ モード: early → 閾値 0.85
    │   └─ モード: normal → 閾値 0.7
    └─ 該当スケジュールなし
        └─ デフォルト: normal → 閾値 0.7
    ↓
判定1: 信頼度 < 閾値？
    ├─ Yes → エスカレーション必要
    └─ No → 判定2へ
    ↓
判定2: 緊急キーワード検出？
    ├─ Yes → 即時エスカレーション
    └─ No → 判定3へ
    ↓
判定3: 3往復以上未解決？
    ├─ Yes → 自動エスカレーション
    └─ No → 回答返却
    ↓
エスカレーション記録
    ├─ escalationsテーブルに保存
    ├─ 現在時刻判定（22:00-8:00？）★v0.3新規
    │   ├─ 夜間 → 夜間対応キュー追加
    │   │   ├─ 自動返信メッセージ送信
    │   │   ├─ overnight_queueテーブル保存
    │   │   └─ scheduled_notify_at: 翌朝8:00
    │   └─ 日中 → 即時通知
    ├─ 通知送信（スケジュール設定に従う）
    └─ ゲストに通知表示
```

### 12.2 エスカレーション判定実装

```python
# app/services/escalation_service.py

from datetime import datetime, time
from typing import Optional
from app.models.escalation_schedule import EscalationSchedule
from app.models.escalation import Escalation
from app.utils.email import send_escalation_notification

class EscalationService:
    """
    エスカレーション管理サービス（v0.2）
    """
    
    # 緊急キーワードリスト
    EMERGENCY_KEYWORDS = [
        "emergency", "help", "urgent", "locked out", 
        "lost key", "sick", "injured", "fire", "police",
        "accident", "medical", "hospital"
    ]
    
    async def check_escalation_needed(
        self,
        facility_id: int,
        confidence: float,
        message: str,
        session_id: str,
        language: str,
        conversation_id: int,
        db: AsyncSession
    ) -> EscalationInfo:
        """
        エスカレーション必要か判定（v0.2）
        """
        # 現在時刻・曜日取得
        now = datetime.utcnow()
        current_time = now.time()
        current_weekday = now.strftime("%a").lower()  # 'mon', 'tue', etc.
        
        # エスカレーションスケジュール検索
        schedule = await self._find_matching_schedule(
            facility_id=facility_id,
            weekday=current_weekday,
            current_time=current_time,
            language=language,
            db=db
        )
        
        # 閾値決定
        if schedule:
            threshold = schedule.threshold
            mode = schedule.mode
            notify_channels = schedule.notify_channels
        else:
            threshold = 0.7  # デフォルト
            mode = "normal"
            notify_channels = ["email"]
        
        # 判定1: 信頼度 < 閾値
        if confidence < threshold:
            trigger_type = "low_confidence"
            reason = f"AI confidence below threshold ({confidence:.2f} < {threshold})"
        
        # 判定2: 緊急キーワード検出
        elif self._detect_emergency_keywords(message):
            trigger_type = "keyword"
            reason = f"Emergency keyword detected in message"
            # 緊急時は即座に通知
            await self._create_escalation(
                facility_id=facility_id,
                conversation_id=conversation_id,
                trigger_type=trigger_type,
                confidence=confidence,
                escalation_mode=mode,
                question=message,
                language=language,
                notify_channels=notify_channels,
                db=db
            )
            return EscalationInfo(
                needed=True,
                mode=mode,
                trigger_type=trigger_type,
                reason=reason,
                notified=True
            )
        
        # 判定3: 3往復以上未解決
        elif await self._check_multiple_turns_unresolved(conversation_id, db):
            trigger_type = "multiple_turns"
            reason = "3 or more turns without resolution"
        
        else:
            # エスカレーション不要
            return EscalationInfo(needed=False)
        
        # エスカレーション作成
        escalation = await self._create_escalation(
            facility_id=facility_id,
            conversation_id=conversation_id,
            trigger_type=trigger_type,
            confidence=confidence,
            escalation_mode=mode,
            question=message,
            language=language,
            notify_channels=notify_channels,
            db=db
        )
        
        return EscalationInfo(
            needed=True,
            mode=mode,
            trigger_type=trigger_type,
            reason=reason,
            notified=escalation.notified_at is not None
        )
    
    async def _find_matching_schedule(
        self,
        facility_id: int,
        weekday: str,
        current_time: time,
        language: str,
        db: AsyncSession
    ) -> Optional[EscalationSchedule]:
        """
        該当するエスカレーションスケジュールを検索（v0.2）
        """
        # アクティブなスケジュール取得
        schedules = await db.execute(
            select(EscalationSchedule).where(
                EscalationSchedule.facility_id == facility_id,
                EscalationSchedule.is_active == True
            )
        )
        schedules = schedules.scalars().all()
        
        for schedule in schedules:
            # 曜日チェック
            if "all" in schedule.day_of_week:
                day_match = True
            else:
                day_match = weekday in schedule.day_of_week
            
            if not day_match:
                continue
            
            # 時間帯チェック
            if schedule.time_start <= schedule.time_end:
                # 通常の時間帯（例: 09:00-18:00）
                time_match = schedule.time_start <= current_time <= schedule.time_end
            else:
                # 日を跨ぐ時間帯（例: 18:00-09:00）
                time_match = current_time >= schedule.time_start or current_time <= schedule.time_end
            
            if not time_match:
                continue
            
            # 言語チェック
            if language in schedule.languages or "all" in schedule.languages:
                return schedule
        
        return None
    
    def _detect_emergency_keywords(self, message: str) -> bool:
        """
        緊急キーワード検出（v0.2）
        """
        message_lower = message.lower()
        return any(keyword in message_lower for keyword in self.EMERGENCY_KEYWORDS)
    
    async def _check_multiple_turns_unresolved(
        self,
        conversation_id: int,
        db: AsyncSession
    ) -> bool:
        """
        3往復以上未解決かチェック（v0.2）
        """
        # 会話のメッセージ数を取得
        message_count = await db.execute(
            select(func.count(Message.id)).where(
                Message.conversation_id == conversation_id
            )
        )
        count = message_count.scalar()
        
        # 3往復 = 6メッセージ以上（user + assistant × 3）
        return count >= 6
    
    async def _create_escalation(
        self,
        facility_id: int,
        conversation_id: int,
        trigger_type: str,
        confidence: float,
        escalation_mode: str,
        question: str,
        language: str,
        notify_channels: List[str],
        db: AsyncSession
    ) -> Escalation:
        """
        エスカレーション記録作成（v0.2）
        """
        escalation = Escalation(
            facility_id=facility_id,
            conversation_id=conversation_id,
            trigger_type=trigger_type,
            ai_confidence=confidence,
            escalation_mode=escalation_mode,
            question=question,
            language=language,
            notification_channels=notify_channels
        )
        
        db.add(escalation)
        await db.flush()
        
        # 通知送信
        await self._send_notifications(
            escalation=escalation,
            notify_channels=notify_channels,
            db=db
        )
        
        escalation.notified_at = datetime.utcnow()
        await db.commit()
        await db.refresh(escalation)
        
        return escalation
    
    async def _send_notifications(
        self,
        escalation: Escalation,
        notify_channels: List[str],
        db: AsyncSession
    ) -> None:
        """
        通知送信（v0.2）
        """
        facility = await db.get(Facility, escalation.facility_id)
        
        for channel in notify_channels:
            if channel == "email":
                await send_escalation_notification(
                    facility=facility,
                    escalation=escalation
                )
            elif channel == "slack":
                # Phase 2で実装
                pass
            elif channel == "line":
                # Phase 2で実装
                pass
```

### 12.3 エスカレーションスケジュール管理

#### スケジュール作成・更新

```python
# app/services/escalation_schedule_service.py

async def create_escalation_schedule(
    facility_id: int,
    schedule_data: EscalationScheduleCreate,
    db: AsyncSession
) -> EscalationSchedule:
    """
    エスカレーションスケジュール作成（v0.2）
    """
    schedule = EscalationSchedule(
        facility_id=facility_id,
        day_of_week=schedule_data.day_of_week,
        time_start=schedule_data.time_start,
        time_end=schedule_data.time_end,
        mode=schedule_data.mode,
        threshold=schedule_data.threshold,
        languages=schedule_data.languages,
        notify_channels=schedule_data.notify_channels,
        is_active=True
    )
    
    db.add(schedule)
    await db.commit()
    await db.refresh(schedule)
    
    return schedule

async def update_escalation_schedule(
    schedule_id: int,
    schedule_data: EscalationScheduleUpdate,
    db: AsyncSession
) -> EscalationSchedule:
    """
    エスカレーションスケジュール更新（v0.2）
    """
    schedule = await db.get(EscalationSchedule, schedule_id)
    
    if schedule_data.day_of_week:
        schedule.day_of_week = schedule_data.day_of_week
    if schedule_data.time_start:
        schedule.time_start = schedule_data.time_start
    if schedule_data.time_end:
        schedule.time_end = schedule_data.time_end
    if schedule_data.mode:
        schedule.mode = schedule_data.mode
    if schedule_data.threshold:
        schedule.threshold = schedule_data.threshold
    if schedule_data.languages:
        schedule.languages = schedule_data.languages
    if schedule_data.notify_channels:
        schedule.notify_channels = schedule_data.notify_channels
    if schedule_data.is_active is not None:
        schedule.is_active = schedule_data.is_active
    
    schedule.updated_at = datetime.utcnow()
    await db.commit()
    await db.refresh(schedule)
    
    return schedule
```

### 12.4 エスカレーション解決処理

```python
# app/services/escalation_service.py

async def resolve_escalation(
    escalation_id: int,
    user_id: int,
    resolution_notes: Optional[str],
    db: AsyncSession
) -> Escalation:
    """
    エスカレーション解決処理（v0.2）
    """
    escalation = await db.get(Escalation, escalation_id)
    
    if not escalation:
        raise HTTPException(status_code=404, detail="Escalation not found")
    
    escalation.resolved_at = datetime.utcnow()
    escalation.resolved_by = user_id
    escalation.resolution_notes = resolution_notes
    
    await db.commit()
    await db.refresh(escalation)
    
    return escalation
```

### 12.5 通知機能

#### メール通知

```python
# app/utils/email.py

async def send_escalation_notification(
    facility: Facility,
    escalation: Escalation
) -> None:
    """
    エスカレーションメール通知（v0.2）
    """
    subject = f"[やどぺら] エスカレーション: {facility.name}"
    
    body = f"""
施設名: {facility.name}
エスカレーションID: {escalation.id}

質問内容:
{escalation.question}

言語: {escalation.language}
信頼度: {escalation.ai_confidence:.2f}
エスカレーションモード: {escalation.escalation_mode}
理由: {escalation.trigger_type}

管理画面で確認・対応してください:
https://admin.yadopera.com/admin/escalations/{escalation.id}
"""
    
    # 施設の管理者メールアドレスに送信
    recipients = await get_facility_admin_emails(facility.id)
    
    for recipient in recipients:
        await send_email(
            to=recipient,
            subject=subject,
            body=body
        )
```

### 12.6 夜間対応キュー処理（v0.3新規）

#### 夜間対応フロー実装

```python
# app/services/overnight_queue_service.py

from datetime import datetime, time, timedelta
from app.models.overnight_queue import OvernightQueue
from app.models.escalation import Escalation

class OvernightQueueService:
    """
    夜間対応キュー管理サービス（v0.3新規）
    """
    
    NIGHT_START = time(22, 0)  # 22:00
    NIGHT_END = time(8, 0)     # 8:00
    
    async def add_to_overnight_queue(
        self,
        facility_id: int,
        escalation_id: int,
        guest_message: str,
        db: AsyncSession
    ) -> OvernightQueue:
        """
        夜間対応キューに追加（v0.3新規）
        """
        now = datetime.utcnow()
        # 翌朝8:00を計算
        if now.hour >= 22 or now.hour < 8:
            # 夜間時間帯
            if now.hour < 8:
                # 0:00-8:00 → 当日8:00
                scheduled_time = now.replace(hour=8, minute=0, second=0, microsecond=0)
            else:
                # 22:00-23:59 → 翌日8:00
                scheduled_time = (now + timedelta(days=1)).replace(hour=8, minute=0, second=0, microsecond=0)
        else:
            # 日中時間帯（通常は呼ばないが念のため）
            scheduled_time = now.replace(hour=8, minute=0, second=0, microsecond=0)
        
        overnight_queue = OvernightQueue(
            facility_id=facility_id,
            escalation_id=escalation_id,
            guest_message=guest_message,
            scheduled_notify_at=scheduled_time
        )
        
        db.add(overnight_queue)
        await db.commit()
        await db.refresh(overnight_queue)
        
        return overnight_queue
    
    async def send_overnight_auto_reply(
        self,
        conversation_id: int,
        language: str,
        db: AsyncSession
    ) -> None:
        """
        夜間自動返信メッセージ送信（v0.3新規）
        """
        if language == 'en':
            message = (
                "Thank you for your message. Our staff will respond "
                "by 9:00 AM tomorrow morning. For life-threatening "
                "emergencies, please call 119 (ambulance/fire) or "
                "110 (police)."
            )
        else:  # 日本語
            message = (
                "お問い合わせありがとうございます。明朝9時までに"
                "スタッフよりご連絡いたします。緊急の場合は"
                "119（救急・消防）または110（警察）へお電話ください。"
            )
        
        # メッセージを会話に追加
        await self._add_system_message(conversation_id, message, db)
    
    async def process_scheduled_notifications(
        self,
        db: AsyncSession
    ) -> List[OvernightQueue]:
        """
        翌朝8:00の一括通知処理（Celeryバッチ、Phase 2実装）
        """
        now = datetime.utcnow()
        # 8:00-8:30の範囲で未通知のキューを取得
        queues = await db.execute(
            select(OvernightQueue)
            .where(
                OvernightQueue.scheduled_notify_at >= now.replace(hour=8, minute=0),
                OvernightQueue.scheduled_notify_at < now.replace(hour=8, minute=30),
                OvernightQueue.notified_at.is_(None)
            )
        )
        
        queues_list = queues.scalars().all()
        
        for queue in queues_list:
            # スタッフへ通知送信
            escalation = await db.get(Escalation, queue.escalation_id)
            await send_escalation_notification(
                facility_id=queue.facility_id,
                escalation=escalation
            )
            
            queue.notified_at = now
            await db.commit()
        
        return queues_list
```

### 12.7 エスカレーション統計

```python
# app/services/escalation_service.py

async def get_escalation_stats(
    facility_id: int,
    start_date: datetime,
    end_date: datetime,
    db: AsyncSession
) -> dict:
    """
    エスカレーション統計取得（v0.2）
    """
    # 総エスカレーション数
    total = await db.execute(
        select(func.count(Escalation.id)).where(
            Escalation.facility_id == facility_id,
            Escalation.created_at >= start_date,
            Escalation.created_at <= end_date
        )
    )
    total_count = total.scalar()
    
    # 未解決数
    unresolved = await db.execute(
        select(func.count(Escalation.id)).where(
            Escalation.facility_id == facility_id,
            Escalation.resolved_at.is_(None),
            Escalation.created_at >= start_date,
            Escalation.created_at <= end_date
        )
    )
    unresolved_count = unresolved.scalar()
    
    # トリガータイプ別集計
    by_trigger = await db.execute(
        select(
            Escalation.trigger_type,
            func.count(Escalation.id).label('count')
        ).where(
            Escalation.facility_id == facility_id,
            Escalation.created_at >= start_date,
            Escalation.created_at <= end_date
        ).group_by(Escalation.trigger_type)
    )
    trigger_breakdown = {row.trigger_type: row.count for row in by_trigger.all()}
    
    # モード別集計
    by_mode = await db.execute(
        select(
            Escalation.escalation_mode,
            func.count(Escalation.id).label('count')
        ).where(
            Escalation.facility_id == facility_id,
            Escalation.created_at >= start_date,
            Escalation.created_at <= end_date
        ).group_by(Escalation.escalation_mode)
    )
    mode_breakdown = {row.escalation_mode: row.count for row in by_mode.all()}
    
    return {
        "total": total_count,
        "unresolved": unresolved_count,
        "resolved": total_count - unresolved_count,
        "resolution_rate": (total_count - unresolved_count) / total_count if total_count > 0 else 0,
        "by_trigger_type": trigger_breakdown,
        "by_mode": mode_breakdown
    }
```

### 12.7 エスカレーション設定例

#### 例1: 平日日中（早期エスカレーション）

```yaml
day_of_week: ["mon", "tue", "wed", "thu", "fri"]
time_start: "09:00"
time_end: "18:00"
mode: "early"
threshold: 0.85
languages: ["en", "ja"]
notify_channels: ["email"]
```

**動作**
- 平日9時-18時の間
- 信頼度 < 0.85でエスカレーション
- 英語・日本語対応
- メール通知

#### 例2: 夜間（通常モード）

```yaml
day_of_week: ["all"]
time_start: "18:00"
time_end: "09:00"
mode: "normal"
threshold: 0.7
languages: ["en", "ja"]
notify_channels: ["email"]
```

**動作**
- 全曜日18時-翌9時の間
- 信頼度 < 0.7でエスカレーション
- 緊急キーワード検出時は即座に通知

#### 例3: 週末（早期エスカレーション）

```yaml
day_of_week: ["sat", "sun"]
time_start: "10:00"
time_end: "16:00"
mode: "early"
threshold: 0.85
languages: ["en", "ja", "zh-TW"]
notify_channels: ["email"]
```

**動作**
- 土日10時-16時の間
- 信頼度 < 0.85でエスカレーション
- 英語・日本語・繁体中国語対応

---

## 13. エラーハンドリング

### 13.1 エラー階層（v0.2）

```
┌─────────────────────────────┐
│  HTTPException (FastAPI)    │ ← クライアントエラー (4xx)
└─────────────────────────────┘
              ↑
┌─────────────────────────────┐
│  AppException (Custom)      │ ← ビジネスロジックエラー
└─────────────────────────────┘
              ↑
      ┌───────┴───────┬──────────────┐
      ↓               ↓              ↓
┌─────────────┐ ┌─────────────┐ ┌─────────────┐
│ AIException │ │VectorSearch │ │Escalation   │
│             │ │Exception    │ │Exception    │
│ (OpenAI API)│ │ (pgvector)  │ │ (v0.2追加)  │
└─────────────┘ └─────────────┘ └─────────────┘
      ↓               ↓              ↓
┌─────────────────────────────────────────┐
│  DatabaseException (Custom)             │ ← DB処理エラー
│  - PostgreSQL接続エラー                   │
│  - pgvector拡張エラー                    │
└─────────────────────────────────────────┘
      ↓
┌─────────────────────────────────────────┐
│  RedisException (Custom)                │ ← Redis処理エラー（v0.2追加）
│  - 接続エラー                            │
│  - キャッシュエラー                      │
└─────────────────────────────────────────┘
```

### 13.2 カスタム例外定義（v0.2）

```python
# app/core/exceptions.py

class AppException(Exception):
    """アプリケーション基底例外"""
    def __init__(self, message: str, code: str, details: dict = None):
        self.message = message
        self.code = code
        self.details = details or {}
        super().__init__(self.message)

class AIException(AppException):
    """AI処理関連例外（v0.2拡張）"""
    def __init__(self, message: str, error_type: str = None, details: dict = None):
        super().__init__(message, "AI_ERROR", details)
        self.error_type = error_type  # 'timeout', 'rate_limit', 'server_error'

class EmbeddingException(AIException):
    """埋め込みベクトル生成エラー（v0.2追加）"""
    pass

class VectorSearchException(AppException):
    """pgvector検索エラー（v0.2追加）"""
    def __init__(self, message: str, details: dict = None):
        super().__init__(message, "VECTOR_SEARCH_ERROR", details)

class EscalationException(AppException):
    """エスカレーション処理エラー（v0.2追加）"""
    def __init__(self, message: str, details: dict = None):
        super().__init__(message, "ESCALATION_ERROR", details)

class DatabaseException(AppException):
    """データベース関連例外"""
    def __init__(self, message: str, details: dict = None):
        super().__init__(message, "DATABASE_ERROR", details)

class RedisException(AppException):
    """Redis処理エラー（v0.2追加）"""
    def __init__(self, message: str, details: dict = None):
        super().__init__(message, "REDIS_ERROR", details)

class AuthenticationException(AppException):
    """認証関連例外"""
    def __init__(self, message: str, details: dict = None):
        super().__init__(message, "AUTH_ERROR", details)

class ValidationException(AppException):
    """バリデーションエラー"""
    def __init__(self, message: str, field: str = None, details: dict = None):
        super().__init__(message, "VALIDATION_ERROR", details)
        self.field = field
```

### 13.3 OpenAI API障害時フォールバック（v0.2拡張）

```python
# app/ai/openai_client.py

from openai import OpenAI, OpenAIError, APITimeoutError, RateLimitError
import logging

logger = logging.getLogger(__name__)

class OpenAIClient:
    """
    OpenAI APIラッパー（フォールバック対応、v0.2拡張）
    """
    
    FALLBACK_MESSAGES = {
        "en": (
            "Sorry, the automatic support system is temporarily unavailable. "
            "Please contact the staff directly for assistance."
        ),
        "ja": (
            "現在、自動案内システムが一時的に利用できません。"
            "お手数ですがスタッフへ直接お問い合わせください。"
        )
    }
    
    async def generate_response(
        self,
        prompt: str,
        max_tokens: int = 200,
        temperature: float = 0.7,
        language: str = "en"
    ) -> str:
        """
        AI応答生成（フォールバック付き、v0.2）
        """
        try:
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini-2024-07-18",
                messages=[{"role": "user", "content": prompt}],
                max_tokens=max_tokens,
                temperature=temperature,
                timeout=5.0  # 5秒タイムアウト
            )
            return response.choices[0].message.content
        
        except APITimeoutError as e:
            error_type = "timeout"
            logger.error(
                "OpenAI API timeout",
                extra={
                    "error_type": error_type,
                    "error_message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                }
            )
            await self._record_fallback_event(error_type, language)
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
        
        except RateLimitError as e:
            error_type = "rate_limit"
            logger.warning(
                "OpenAI API rate limit exceeded",
                extra={
                    "error_type": error_type,
                    "error_message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                }
            )
            await self._record_fallback_event(error_type, language)
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
        
        except OpenAIError as e:
            error_type = "server_error"
            logger.error(
                "OpenAI API error",
                extra={
                    "error_type": error_type,
                    "error_message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                },
                exc_info=True
            )
            await self._record_fallback_event(error_type, language)
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
        
        except Exception as e:
            error_type = "unexpected_error"
            logger.critical(
                "Unexpected error in AI generation",
                extra={
                    "error_type": error_type,
                    "error_message": str(e),
                    "timestamp": datetime.utcnow().isoformat()
                },
                exc_info=True
            )
            await self._record_fallback_event(error_type, language)
            return self.FALLBACK_MESSAGES.get(language, self.FALLBACK_MESSAGES["en"])
    
    async def generate_embedding(
        self,
        text: str
    ) -> List[float]:
        """
        埋め込みベクトル生成（フォールバック付き、v0.2）
        """
        try:
            response = await self.client.embeddings.create(
                model="text-embedding-3-small",
                input=text,
                timeout=3.0
            )
            return response.data[0].embedding
        
        except APITimeoutError as e:
            logger.error(f"OpenAI Embeddings API timeout: {e}")
            # 空ベクトル返却（検索結果なしになる）
            return [0.0] * 1536
        
        except RateLimitError as e:
            logger.warning(f"OpenAI Embeddings API rate limit: {e}")
            return [0.0] * 1536
        
        except OpenAIError as e:
            logger.error(f"OpenAI Embeddings API error: {e}", exc_info=True)
            return [0.0] * 1536
        
        except Exception as e:
            logger.critical(f"Unexpected error in embedding generation: {e}", exc_info=True)
            return [0.0] * 1536
    
    async def _record_fallback_event(
        self,
        error_type: str,
        language: str
    ) -> None:
        """
        フォールバックイベントをログ記録（v0.2）
        """
        logger.warning(
            "AI API error: fallback_message_triggered",
            extra={
                "timestamp": datetime.utcnow().isoformat(),
                "event": "openai_fallback",
                "error_type": error_type,
                "language": language
            }
        )
        
        # メトリクス記録（Phase 2で実装）
        # await metrics.record_fallback_event(error_type, language)
```

### 13.4 pgvector検索エラーハンドリング（v0.2）

```python
# app/ai/vector_search.py

from sqlalchemy.exc import SQLAlchemyError
from app.core.exceptions import VectorSearchException, DatabaseException

async def search_similar_faqs(
    facility_id: int,
    embedding: List[float],
    top_k: int = 3,
    threshold: float = 0.7,
    db: AsyncSession
) -> List[FAQ]:
    """
    pgvectorで類似FAQ検索（エラーハンドリング付き、v0.2）
    """
    try:
        embedding_vector = f"[{','.join(map(str, embedding))}]"
        
        query = select(
            FAQ,
            1 - func.cosine_distance(FAQ.embedding, embedding_vector).label('similarity')
        ).where(
            FAQ.facility_id == facility_id,
            FAQ.is_active == True,
            FAQ.embedding.isnot(None)
        ).order_by(
            func.cosine_distance(FAQ.embedding, embedding_vector).asc()
        ).limit(top_k)
        
        result = await db.execute(query)
        results = result.all()
        
        similar_faqs = []
        for faq, similarity in results:
            if similarity >= threshold:
                similar_faqs.append(faq)
        
        return similar_faqs
    
    except SQLAlchemyError as e:
        logger.error(
            "pgvector search error",
            extra={
                "error_type": "database_error",
                "error_message": str(e),
                "facility_id": facility_id
            },
            exc_info=True
        )
        # エラー時は空リスト返却（検索結果なしとして処理続行）
        return []
    
    except Exception as e:
        logger.critical(
            "Unexpected error in vector search",
            extra={
                "error_type": "unexpected_error",
                "error_message": str(e),
                "facility_id": facility_id
            },
            exc_info=True
        )
        return []
```

### 13.5 Redisエラーハンドリング（v0.2）

```python
# app/core/redis_client.py

from redis import Redis, ConnectionError, TimeoutError
from app.core.exceptions import RedisException
import logging

logger = logging.getLogger(__name__)

class RedisClient:
    """
    Redis接続管理（エラーハンドリング付き、v0.2）
    """
    
    def __init__(self):
        self.client = Redis.from_url(
            settings.REDIS_URL,
            decode_responses=True,
            socket_connect_timeout=2,
            socket_timeout=2
        )
    
    async def get(self, key: str) -> Optional[str]:
        """
        値取得（エラー時はNone返却）
        """
        try:
            return await self.client.get(key)
        except (ConnectionError, TimeoutError) as e:
            logger.warning(f"Redis connection error: {e}")
            return None
        except Exception as e:
            logger.error(f"Redis get error: {e}", exc_info=True)
            return None
    
    async def setex(self, key: str, time: int, value: str) -> bool:
        """
        値設定（TTL付き、エラー時はFalse返却）
        """
        try:
            await self.client.setex(key, time, value)
            return True
        except (ConnectionError, TimeoutError) as e:
            logger.warning(f"Redis connection error: {e}")
            return False
        except Exception as e:
            logger.error(f"Redis setex error: {e}", exc_info=True)
            return False
    
    async def incr(self, key: str) -> Optional[int]:
        """
        値インクリメント（エラー時はNone返却）
        """
        try:
            return await self.client.incr(key)
        except (ConnectionError, TimeoutError) as e:
            logger.warning(f"Redis connection error: {e}")
            return None
        except Exception as e:
            logger.error(f"Redis incr error: {e}", exc_info=True)
            return None
```

### 13.6 グローバル例外ハンドラ（v0.2拡張）

```python
# app/main.py

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from app.core.exceptions import (
    AppException, AIException, VectorSearchException,
    EscalationException, DatabaseException, RedisException,
    AuthenticationException, ValidationException
)
import logging

logger = logging.getLogger(__name__)

app = FastAPI()

# カスタム例外ハンドラ
@app.exception_handler(AIException)
async def ai_exception_handler(request: Request, exc: AIException):
    """AI処理エラーハンドラ（v0.2）"""
    logger.error(
        f"AI Exception: {exc.message}",
        extra={
            "error_type": exc.error_type,
            "details": exc.details
        }
    )
    
    # OpenAI API障害時は503返却
    if exc.error_type in ["timeout", "rate_limit", "server_error"]:
        return JSONResponse(
            status_code=503,
            content={
                "error": {
                    "code": "SERVICE_UNAVAILABLE",
                    "message": "AI service is temporarily unavailable. Please try again later.",
                    "details": {
                        "service": "openai_api",
                        "error_type": exc.error_type
                    }
                }
            }
        )
    
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": exc.details
            }
        }
    )

@app.exception_handler(VectorSearchException)
async def vector_search_exception_handler(request: Request, exc: VectorSearchException):
    """pgvector検索エラーハンドラ（v0.2追加）"""
    logger.error(f"Vector Search Exception: {exc.message}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": exc.code,
                "message": "Vector search failed. Please try again.",
                "details": exc.details
            }
        }
    )

@app.exception_handler(EscalationException)
async def escalation_exception_handler(request: Request, exc: EscalationException):
    """エスカレーション処理エラーハンドラ（v0.2追加）"""
    logger.error(f"Escalation Exception: {exc.message}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": exc.details
            }
        }
    )

@app.exception_handler(DatabaseException)
async def database_exception_handler(request: Request, exc: DatabaseException):
    """データベースエラーハンドラ"""
    logger.error(f"Database Exception: {exc.message}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": exc.code,
                "message": "Database error occurred. Please try again later.",
                "details": exc.details
            }
        }
    )

@app.exception_handler(RedisException)
async def redis_exception_handler(request: Request, exc: RedisException):
    """Redisエラーハンドラ（v0.2追加）"""
    logger.warning(f"Redis Exception: {exc.message}")
    # Redisエラーは致命的ではないため、処理続行
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": exc.code,
                "message": "Cache service error. Please try again.",
                "details": exc.details
            }
        }
    )

@app.exception_handler(AuthenticationException)
async def authentication_exception_handler(request: Request, exc: AuthenticationException):
    """認証エラーハンドラ"""
    return JSONResponse(
        status_code=401,
        content={
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": exc.details
            }
        }
    )

@app.exception_handler(ValidationException)
async def validation_exception_handler(request: Request, exc: ValidationException):
    """バリデーションエラーハンドラ"""
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": {
                    "field": exc.field,
                    **exc.details
                }
            }
        }
    )

@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    """アプリケーション基底例外ハンドラ"""
    return JSONResponse(
        status_code=400,
        content={
            "error": {
                "code": exc.code,
                "message": exc.message,
                "details": exc.details
            }
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """予期しないエラーハンドラ"""
    logger.critical(
        f"Unhandled exception: {exc}",
        extra={
            "path": request.url.path,
            "method": request.method
        },
        exc_info=True
    )
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_ERROR",
                "message": "An unexpected error occurred. Please try again later.",
                "details": {}
            }
        }
    )
```

### 13.7 エラーログ記録（v0.2）

```python
# app/utils/logger.py

import logging
import json
from datetime import datetime

class StructuredLogger:
    """
    構造化ログ記録（v0.2）
    """
    
    def __init__(self, name: str):
        self.logger = logging.getLogger(name)
    
    def log_error(
        self,
        message: str,
        error_type: str,
        error_code: str = None,
        details: dict = None,
        exc_info: bool = False
    ):
        """
        エラーログ記録
        """
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "ERROR",
            "message": message,
            "error_type": error_type,
            "error_code": error_code,
            "details": details or {}
        }
        
        self.logger.error(
            json.dumps(log_data, ensure_ascii=False),
            exc_info=exc_info
        )
    
    def log_fallback_event(
        self,
        service: str,
        error_type: str,
        language: str = None,
        session_id: str = None
    ):
        """
        フォールバックイベントログ（v0.2）
        """
        log_data = {
            "timestamp": datetime.utcnow().isoformat(),
            "level": "WARNING",
            "event": "fallback_triggered",
            "service": service,
            "error_type": error_type,
            "language": language,
            "session_id": session_id
        }
        
        self.logger.warning(
            json.dumps(log_data, ensure_ascii=False)
        )
```

### 13.8 エラー回復戦略

#### リトライ戦略

```python
# app/utils/retry.py

from tenacity import retry, stop_after_attempt, wait_exponential

@retry(
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=2, max=10)
)
async def retry_openai_call(func, *args, **kwargs):
    """
    OpenAI API呼び出しのリトライ（v0.2）
    最大3回、指数バックオフ
    """
    try:
        return await func(*args, **kwargs)
    except (APITimeoutError, RateLimitError) as e:
        logger.warning(f"Retrying OpenAI API call: {e}")
        raise  # リトライ
    except OpenAIError as e:
        # その他のエラーはリトライしない
        raise
```

#### フォールバックチェーン

```
1. 通常処理（RAG統合型）
   ↓ 失敗
2. 埋め込みベクトル生成スキップ（FAQ全文検索）
   ↓ 失敗
3. フォールバックメッセージ返却
   ↓
4. エスカレーション記録
```

---

## 14. デプロイメント

### 14.1 Render.com構成（v0.2）

```
┌─────────────────────────────────────┐
│         Render.com                  │
│                                     │
│  ┌───────────────────────────────┐ │
│  │  Web Service (FastAPI)        │ │
│  │  - Region: Oregon (US-West)   │ │
│  │  - Instance: Standard         │ │
│  │  - Auto-deploy: main branch   │ │
│  │  - Health Check: /api/v1/health│ │
│  └───────────────────────────────┘ │
│                                     │
│  ┌───────────────────────────────┐ │
│  │  PostgreSQL (Managed)         │ │
│  │  - Version: 15                │ │
│  │  - Plan: Starter              │ │
│  │  - Storage: 1GB               │ │
│  │  - Extensions: pgvector       │ │ (v0.2追加)
│  └───────────────────────────────┘ │
│                                     │
│  ┌───────────────────────────────┐ │
│  │  Static Site (Vue.js)         │ │
│  │  - Build: npm run build        │ │
│  │  - Publish: dist/             │ │
│  │  - PWA対応                     │ │ (v0.2追加)
│  └───────────────────────────────┘ │
│                                     │
│  ┌───────────────────────────────┐ │
│  │  Redis Cloud (External)      │ │ (v0.2追加)
│  │  - Plan: Free → Paid          │ │
│  │  - Region: US-West            │ │
│  └───────────────────────────────┘ │
└─────────────────────────────────────┘
```

### 14.2 環境変数設定（v0.2）

#### Backend (.env)

```bash
# Database
DATABASE_URL=postgresql+asyncpg://user:pass@host:5432/yadopera

# Redis (v0.2追加)
REDIS_URL=redis://localhost:6379/0
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_DB=0

# JWT
SECRET_KEY=your-secret-key-min-32-chars
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=10080  # v0.2変更: 7日間
REFRESH_TOKEN_EXPIRE_DAYS=30       # v0.2変更: 30日間

# OpenAI (v0.2拡張)
OPENAI_API_KEY=sk-proj-xxxxx
OPENAI_EMBEDDING_MODEL=text-embedding-3-small  # v0.2追加

# Email (パスワードリセット用)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=noreply@yadopera.com
SMTP_PASSWORD=xxxxx
FRONTEND_URL=https://yadopera.com  # v0.2追加

# CORS
FRONTEND_URL=https://yadopera.com
ADMIN_URL=https://admin.yadopera.com

# AWS S3 (QRコード保存)
AWS_ACCESS_KEY_ID=xxxxx
AWS_SECRET_ACCESS_KEY=xxxxx
AWS_S3_BUCKET=yadopera-qrcodes
AWS_REGION=ap-northeast-1

# Encryption (機密データ暗号化、v0.2追加)
ENCRYPTION_KEY=xxxxx  # Fernet key

# Environment
ENVIRONMENT=production
DEBUG=false
```

#### Frontend (.env.production)

```bash
VITE_API_BASE_URL=https://api.yadopera.com
VITE_ENVIRONMENT=production
VITE_PWA_ENABLED=true  # v0.2追加
```

### 14.3 デプロイフロー（v0.2）

```
┌──────────────┐
│  Developer   │
└──────┬───────┘
       │ git push origin main
       ↓
┌──────────────┐
│   GitHub     │
└──────┬───────┘
       │ Webhook
       ↓
┌───────────────────────────┐
│  Render.com               │
│  1. Pull latest code      │
│  2. Build Docker image    │
│  3. Install dependencies  │
│  4. Run migrations        │
│     - pgvector拡張有効化  │ (v0.2追加)
│     - テーブル作成         │
│     - インデックス作成     │
│  5. Health check          │
│     - DB接続確認          │
│     - Redis接続確認       │ (v0.2追加)
│     - OpenAI API確認      │
│  6. Switch traffic        │
└───────────────────────────┘
```

### 14.4 Dockerfile（v0.2）

#### Backend Dockerfile

```dockerfile
# backend/Dockerfile

FROM python:3.11-slim

WORKDIR /app

# システム依存関係インストール
RUN apt-get update && apt-get install -y \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# Python依存関係インストール
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# アプリケーションコピー
COPY ./app ./app
COPY alembic.ini .
COPY ./alembic ./alembic

# 環境変数
ENV PYTHONUNBUFFERED=1

# マイグレーション実行とサーバー起動
CMD alembic upgrade head && \
    uvicorn app.main:app --host 0.0.0.0 --port $PORT --workers 2
```

#### Frontend Dockerfile

```dockerfile
# frontend/Dockerfile

FROM node:18-alpine AS build

WORKDIR /app

# 依存関係インストール
COPY package*.json ./
RUN npm ci

# アプリケーションコピーとビルド
COPY . .
RUN npm run build

# 本番環境用Nginx
FROM nginx:alpine

# ビルド成果物コピー
COPY --from=build /app/dist /usr/share/nginx/html

# Nginx設定
COPY nginx.conf /etc/nginx/conf.d/default.conf

# PWA用設定（v0.2追加）
COPY public/manifest.json /usr/share/nginx/html/
COPY public/pwa-*.png /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

#### docker-compose.yml（ローカル開発用、v0.2）

```yaml
version: '3.8'

services:
  postgres:
    image: pgvector/pgvector:pg15
    environment:
      POSTGRES_USER: yadopera
      POSTGRES_PASSWORD: yadopera
      POSTGRES_DB: yadopera
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    command: postgres -c shared_preload_libraries=vector

  redis:
    image: redis:7.2-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      DATABASE_URL: postgresql+asyncpg://yadopera:yadopera@postgres:5432/yadopera
      REDIS_URL: redis://redis:6379/0
      OPENAI_API_KEY: ${OPENAI_API_KEY}
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend:/app

  frontend:
    build: ./frontend
    ports:
      - "5173:80"
    environment:
      VITE_API_BASE_URL: http://localhost:8000
    depends_on:
      - backend

volumes:
  postgres_data:
  redis_data:
```

### 14.5 データベース初期化（pgvector拡張、v0.2）

```sql
-- マイグレーション: 002_add_pgvector.py

"""add pgvector extension

Revision ID: 002
Revises: 001
Create Date: 2025-11-19
"""
from alembic import op
import sqlalchemy as sa

def upgrade():
    # pgvector拡張有効化
    op.execute("CREATE EXTENSION IF NOT EXISTS vector")
    op.execute("CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"")

def downgrade():
    op.execute("DROP EXTENSION IF EXISTS vector")
    op.execute("DROP EXTENSION IF EXISTS \"uuid-ossp\"")
```

### 14.6 ヘルスチェック（v0.2拡張）

```python
# app/api/v1/router.py

from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.core.redis_client import redis_client
from app.ai.openai_client import OpenAIClient
from openai import OpenAI

router = APIRouter()

@router.get("/health")
async def health_check(db: AsyncSession = Depends(get_db)):
    """
    ヘルスチェックエンドポイント（v0.2拡張）
    - DB接続確認
    - pgvector拡張確認
    - Redis接続確認
    - OpenAI API接続確認
    """
    health_status = {
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "services": {}
    }
    
    # DB接続チェック
    try:
        result = await db.execute("SELECT 1")
        result.scalar()
        health_status["services"]["database"] = "connected"
        
        # pgvector拡張確認（v0.2追加）
        result = await db.execute(
            "SELECT EXISTS(SELECT 1 FROM pg_extension WHERE extname = 'vector')"
        )
        pgvector_enabled = result.scalar()
        health_status["services"]["pgvector"] = "enabled" if pgvector_enabled else "disabled"
    except Exception as e:
        health_status["status"] = "unhealthy"
        health_status["services"]["database"] = f"error: {str(e)}"
        return JSONResponse(
            status_code=503,
            content=health_status
        )
    
    # Redis接続チェック（v0.2追加）
    try:
        await redis_client.get("health_check")
        health_status["services"]["redis"] = "connected"
    except Exception as e:
        health_status["status"] = "degraded"  # Redisは致命的ではない
        health_status["services"]["redis"] = f"error: {str(e)}"
    
    # OpenAI API チェック
    try:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        client.models.list()
        health_status["services"]["openai"] = "connected"
    except Exception as e:
        health_status["status"] = "degraded"
        health_status["services"]["openai"] = f"error: {str(e)}"
    
    # ステータスコード決定
    status_code = 200 if health_status["status"] == "healthy" else 503
    
    return JSONResponse(
        status_code=status_code,
        content=health_status
    )
```

### 14.7 デプロイ前チェックリスト（v0.2）

#### バックエンド

- [ ] 環境変数設定完了
  - [ ] DATABASE_URL
  - [ ] REDIS_URL（v0.2追加）
  - [ ] OPENAI_API_KEY
  - [ ] OPENAI_EMBEDDING_MODEL（v0.2追加）
  - [ ] SECRET_KEY
  - [ ] ENCRYPTION_KEY（v0.2追加）
- [ ] データベースマイグレーション実行
  - [ ] pgvector拡張有効化（v0.2追加）
  - [ ] 全テーブル作成
  - [ ] インデックス作成（IVFFlat含む）
- [ ] Redis接続確認（v0.2追加）
- [ ] SSL証明書設定
- [ ] CORS設定確認
- [ ] ヘルスチェック動作確認
- [ ] エラーログ監視設定
- [ ] バックアップ設定

#### フロントエンド

- [ ] 環境変数設定完了
  - [ ] VITE_API_BASE_URL
  - [ ] VITE_PWA_ENABLED（v0.2追加）
- [ ] ビルド成功確認
- [ ] PWAマニフェスト設定（v0.2追加）
- [ ] Service Worker登録確認（v0.2追加）
- [ ] ダークモード動作確認（v0.2追加）

### 14.8 本番環境設定（Render.com）

#### Web Service設定

```yaml
# render.yaml

services:
  - type: web
    name: yadopera-api
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: alembic upgrade head && uvicorn app.main:app --host 0.0.0.0 --port $PORT
    envVars:
      - key: DATABASE_URL
        fromDatabase:
          name: yadopera-db
          property: connectionString
      - key: REDIS_URL
        sync: false  # 外部Redis Cloud
      - key: OPENAI_API_KEY
        sync: false
      - key: SECRET_KEY
        generateValue: true
    healthCheckPath: /api/v1/health
    autoDeploy: true
```

#### PostgreSQL設定

```yaml
databases:
  - name: yadopera-db
    plan: starter
    postgresMajorVersion: 15
    extensions:
      - vector  # v0.2追加: pgvector拡張
```

### 14.9 バックアップ戦略

#### データベースバックアップ

```bash
# 日次バックアップ（Render.com自動）
# 手動バックアップ
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d).sql

# リストア
psql $DATABASE_URL < backup_20251119.sql
```

#### Redisバックアップ（v0.2）

- Redis Cloud: 自動バックアップ（有料プラン）
- 手動バックアップ: `redis-cli --rdb dump.rdb`

### 14.10 モニタリング（Phase 2）

#### 推奨ツール

- **ログ監視**: Render.com内蔵ログ、または外部サービス（Sentry等）
- **メトリクス**: Render.comメトリクス、または外部サービス（Datadog等）
- **アラート**: エラー率、レスポンス時間、可用性

---

## 15. パフォーマンス要件

### 15.1 レスポンスタイム目標（v0.2）

| エンドポイント | 目標 | 最大 | 備考 |
|--------------|------|------|------|
| `/api/v1/chat` | 2秒以内 | 3秒 | RAG統合型（埋め込み+検索+生成） |
| `/api/v1/auth/login` | 500ms以内 | 1秒 | - |
| `/api/v1/admin/faqs` (一覧) | 200ms以内 | 500ms | - |
| `/api/v1/admin/dashboard` | 1秒以内 | 2秒 | ポーリング対応 |
| `/api/v1/facility/{slug}` | 300ms以内 | 500ms | Redisキャッシュ（v0.2） |

#### RAG統合型チャットの内訳（目標2秒）

```
埋め込みベクトル生成: 200-300ms
pgvector検索: 50-100ms
GPT-4o-mini回答生成: 1,000-1,500ms
信頼度計算・エスカレーション判定: 50-100ms
合計: 1,300-2,000ms（目標2秒以内）
```

### 15.2 最適化戦略（v0.2）

#### データベースクエリ最適化

```python
# N+1問題対策: Eager Loading
from sqlalchemy.orm import joinedload

# Bad
conversations = await db.execute(select(Conversation))
for conv in conversations.scalars():
    messages = await db.execute(
        select(Message).where(Message.conversation_id == conv.id)
    )  # 追加クエリ発生

# Good
conversations = await db.execute(
    select(Conversation)
    .options(joinedload(Conversation.messages))
)
# 1回のクエリで関連データ取得
```

#### pgvectorインデックス最適化（v0.2）

```sql
-- IVFFlatインデックス作成
CREATE INDEX idx_faqs_embedding ON faqs 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- データ量に応じたリスト数調整
-- 100件以下: lists = 10
-- 100-1000件: lists = 100
-- 1000件以上: lists = 1000

-- インデックス再構築（定期的に）
REINDEX INDEX idx_faqs_embedding;

-- 統計情報更新
ANALYZE faqs;
```

#### Redisキャッシュ戦略（v0.2）

```python
# app/utils/cache.py

from app.core.redis_client import redis_client
import json

async def get_cached_facility(slug: str) -> Optional[Facility]:
    """
    施設情報キャッシュ取得（v0.2）
    TTL: 1時間
    """
    cache_key = f"facility:{slug}"
    cached = await redis_client.get(cache_key)
    
    if cached:
        return Facility(**json.loads(cached))
    
    return None

async def cache_facility(slug: str, facility: Facility, ttl: int = 3600):
    """
    施設情報キャッシュ保存（v0.2）
    """
    cache_key = f"facility:{slug}"
    await redis_client.setex(
        cache_key,
        ttl,
        json.dumps(facility.dict())
    )

async def get_cached_session(session_id: str) -> Optional[bool]:
    """
    セッション有効性キャッシュ（v0.2）
    TTL: 残り有効期限
    """
    cache_key = f"session:{session_id}"
    return await redis_client.get(cache_key)

# 頻出FAQの埋め込みベクトルキャッシュ（Phase 2）
async def get_cached_embedding(text: str) -> Optional[List[float]]:
    """
    埋め込みベクトルキャッシュ（Phase 2）
    同じ質問パターンが来た場合、埋め込み生成をスキップ
    """
    cache_key = f"embedding:{hash(text)}"
    cached = await redis_client.get(cache_key)
    
    if cached:
        return json.loads(cached)
    
    return None
```

#### OpenAI API呼び出し最適化

```python
# タイムアウト設定
response = await client.chat.completions.create(
    model="gpt-4o-mini-2024-07-18",
    messages=[...],
    max_tokens=200,  # 出力トークン制限
    temperature=0.7,
    timeout=5.0  # 5秒でタイムアウト
)

# 埋め込みベクトル生成（並列処理可能、v0.2）
import asyncio

async def generate_faq_embeddings_batch(faqs: List[FAQ]):
    """
    複数FAQの埋め込みベクトルを並列生成（v0.2）
    """
    tasks = [
        generate_embedding(f"{faq.question} {faq.answer}")
        for faq in faqs
    ]
    embeddings = await asyncio.gather(*tasks)
    return embeddings
```

### 15.3 パフォーマンス監視指標

#### 主要メトリクス

| 指標 | 目標値 | 測定方法 |
|------|--------|----------|
| API応答時間（P50） | < 1.5秒 | ログ分析 |
| API応答時間（P95） | < 3秒 | ログ分析 |
| API応答時間（P99） | < 5秒 | ログ分析 |
| エラー率 | < 0.1% | エラーログ集計 |
| 可用性 | > 99.5% | ヘルスチェック |
| データベース接続プール使用率 | < 80% | モニタリング |
| Redis接続エラー率 | < 0.01% | ログ分析 |

#### チャットAPI詳細メトリクス（v0.2）

| 処理段階 | 目標時間 | 最大時間 |
|---------|---------|---------|
| 埋め込みベクトル生成 | 200ms | 500ms |
| pgvector検索 | 50ms | 200ms |
| GPT-4o-mini回答生成 | 1,000ms | 2,000ms |
| 信頼度計算 | 10ms | 50ms |
| エスカレーション判定 | 20ms | 100ms |
| データベース保存 | 50ms | 200ms |
| **合計** | **1,330ms** | **3,050ms** |

### 15.4 スケーラビリティ考慮事項

#### 同時接続数

- **目標**: 100同時接続
- **最大**: 500同時接続（Phase 2）
- **対策**: 
  - データベース接続プール（最大20接続）
  - Redis接続プール（最大10接続）
  - 非同期処理（FastAPI async/await）

#### データベース負荷

- **読み取り**: 主にFAQ検索、会話履歴取得
- **書き込み**: メッセージ保存、エスカレーション記録
- **対策**:
  - 読み取りレプリカ（Phase 2）
  - インデックス最適化
  - クエリ最適化

#### Redis負荷

- **セッション管理**: 高頻度アクセス
- **キャッシュ**: 施設情報、FAQ埋め込みベクトル
- **Rate Limiting**: リクエスト数カウント
- **対策**:
  - Redis Cloud（スケーラブル）
  - 適切なTTL設定
  - メモリ使用量監視

### 15.5 ボトルネック対策

#### 1. 埋め込みベクトル生成の最適化

```python
# バッチ処理（FAQ一括生成時）
async def generate_faq_embeddings_batch(faqs: List[FAQ]):
    """
    複数FAQの埋め込みベクトルを並列生成
    レート制限を考慮（OpenAI API制限）
    """
    # 10件ずつバッチ処理
    batch_size = 10
    for i in range(0, len(faqs), batch_size):
        batch = faqs[i:i+batch_size]
        tasks = [
            generate_embedding(f"{faq.question} {faq.answer}")
            for faq in batch
        ]
        embeddings = await asyncio.gather(*tasks)
        
        # レート制限対策（1秒待機）
        if i + batch_size < len(faqs):
            await asyncio.sleep(1)
```

#### 2. pgvector検索の最適化

```sql
-- インデックス最適化
CREATE INDEX idx_faqs_embedding ON faqs 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- 検索クエリ最適化
-- Top 3のみ取得（LIMIT句使用）
SELECT 
    id, question, answer,
    1 - (embedding <=> $1::vector) as similarity
FROM faqs
WHERE facility_id = $2
  AND is_active = TRUE
  AND embedding IS NOT NULL
ORDER BY embedding <=> $1::vector
LIMIT 3;
```

#### 3. データベース接続プール設定

```python
# app/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

engine = create_async_engine(
    settings.DATABASE_URL,
    pool_size=20,  # 接続プールサイズ
    max_overflow=10,  # オーバーフロー接続数
    pool_pre_ping=True,  # 接続有効性チェック
    pool_recycle=3600,  # 1時間で接続再生成
    echo=False  # SQLログ出力（本番ではFalse）
)

AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)
```

#### 4. Redis接続プール設定

```python
# app/core/redis_client.py

from redis.asyncio import ConnectionPool, Redis

pool = ConnectionPool.from_url(
    settings.REDIS_URL,
    max_connections=10,  # 最大接続数
    decode_responses=True
)

redis_client = Redis(connection_pool=pool)
```

### 15.6 想定利用量

- **月間質問数**: 100件/施設（想定）
- **同時接続数**: 最大10施設同時利用（PoC版）
- **ピーク時**: 夜間（22-8時）に30件/月/施設
- **総質問数**: 100-150施設 × 100件/月 = 10,000-15,000件/月（想定）

### 15.7 負荷テスト目標（PoC版）

#### シナリオ1: 通常負荷

- **同時ユーザー数**: 10施設 × 10同時接続 = 100接続
- **リクエスト数**: 100 req/min
- **目標**: 全リクエストが3秒以内に完了

#### シナリオ2: ピーク負荷

- **同時ユーザー数**: 30施設 × 20同時接続 = 600接続
- **リクエスト数**: 600 req/min
- **目標**: 95%のリクエストが5秒以内に完了

#### シナリオ3: ストレステスト

- **同時ユーザー数**: 100施設 × 50同時接続 = 5,000接続
- **リクエスト数**: 5,000 req/min
- **目標**: システムがクラッシュせず、エラーハンドリングが機能

### 15.8 パフォーマンス改善ロードマップ

#### Phase 1 (MVP/PoC)
- [x] 非同期処理（FastAPI async/await）
- [x] pgvectorインデックス最適化
- [x] Redisキャッシュ（セッション、施設情報）
- [x] データベース接続プール

#### Phase 2 (PoC後)
- [ ] FAQ埋め込みベクトルキャッシュ
- [ ] 読み取りレプリカ（PostgreSQL）
- [ ] CDN活用（静的ファイル）
- [ ] ストリーミング応答（チャット）

#### Phase 3 (本格展開)
- [ ] 水平スケーリング（複数インスタンス）
- [ ] データベースシャーディング
- [ ] 分散キャッシュ（Redis Cluster）

---

## 16. 開発規約

### 16.1 コーディング規約

#### Python (Backend)

- **フォーマッター**: Black (line length: 100)
- **リンター**: Ruff (Flake8 + isort統合)
- **型ヒント**: 必須 (Python 3.11+)
- **命名規則**:
  - 関数: `snake_case`
  - クラス: `PascalCase`
  - 定数: `UPPER_SNAKE_CASE`
  - プライベートメソッド: `_leading_underscore`

```python
# Good: RAG統合型チャットエンジン
from typing import Optional
from app.models import Message, FAQ
from app.ai.rag_engine import RAGEngine

class ChatEngine:
    """RAG統合型チャットエンジン"""
    
    def __init__(self, rag_engine: RAGEngine):
        self.rag_engine = rag_engine
    
    async def process_message(
        self,
        message: str,
        facility_id: str,
        session_id: str
    ) -> dict[str, Any]:
        """
        チャットメッセージを処理する（RAG統合型）
        
        Args:
            message: ゲストのメッセージ
            facility_id: 施設ID
            session_id: セッションID
            
        Returns:
            dict: AI応答（content, ai_confidence, matched_faq_ids）
        """
        # 埋め込みベクトル生成
        embedding = await self.rag_engine.generate_embedding(message)
        
        # pgvectorで類似FAQ検索
        similar_faqs = await self.rag_engine.search_faqs(
            embedding=embedding,
            facility_id=facility_id,
            top_k=3
        )
        
        # コンテキスト構築
        context = self._build_context(similar_faqs, facility_id)
        
        # GPT-4o miniで回答生成
        response = await self.rag_engine.generate_response(
            question=message,
            context=context
        )
        
        # 信頼度スコア計算
        confidence = self._calculate_confidence(
            response=response,
            similar_faqs=similar_faqs
        )
        
        return {
            "content": response,
            "ai_confidence": confidence,
            "matched_faq_ids": [faq.id for faq in similar_faqs]
        }
    
    def _build_context(
        self,
        faqs: list[FAQ],
        facility_id: str
    ) -> str:
        """コンテキスト構築（プライベートメソッド）"""
        ...
```

#### TypeScript (Frontend)

- **フォーマッター**: Prettier
- **リンター**: ESLint (Vue 3 + TypeScript)
- **型定義**: 必須 (TypeScript strict mode)
- **命名規則**:
  - 変数・関数: `camelCase`
  - コンポーネント: `PascalCase`
  - 定数: `UPPER_SNAKE_CASE`
  - 型・インターフェース: `PascalCase` (I prefix不要)

```typescript
// Good: Vue 3 Composition API + TypeScript
import { ref, computed, onMounted } from 'vue'
import { useChatStore } from '@/stores/chat'
import type { ChatMessage, ChatResponse } from '@/types/chat'

interface ChatProps {
  facilityId: string
  sessionId: string
}

export default defineComponent({
  name: 'ChatView',
  props: {
    facilityId: {
      type: String,
      required: true
    },
    sessionId: {
      type: String,
      required: true
    }
  },
  setup(props: ChatProps) {
    const chatStore = useChatStore()
    const messages = ref<ChatMessage[]>([])
    const isLoading = ref<boolean>(false)
    
    const hasMessages = computed(() => messages.value.length > 0)
    
    const sendMessage = async (content: string): Promise<void> => {
      if (!content.trim() || isLoading.value) return
      
      isLoading.value = true
      try {
        const response: ChatResponse = await chatStore.sendMessage({
          facilityId: props.facilityId,
          sessionId: props.sessionId,
          message: content
        })
        
        messages.value.push({
          role: 'user',
          content: content,
          timestamp: new Date()
        })
        
        messages.value.push({
          role: 'assistant',
          content: response.content,
          aiConfidence: response.ai_confidence,
          matchedFaqIds: response.matched_faq_ids,
          timestamp: new Date()
        })
      } catch (error) {
        console.error('Failed to send message:', error)
        throw error
      } finally {
        isLoading.value = false
      }
    }
    
    onMounted(async () => {
      await chatStore.loadHistory(props.sessionId)
      messages.value = chatStore.messages
    })
    
    return {
      messages,
      isLoading,
      hasMessages,
      sendMessage
    }
  }
})
```

#### SQL (Database)

- **命名規則**:
  - テーブル: `snake_case` (複数形)
  - カラム: `snake_case`
  - インデックス: `idx_<table>_<column>`
  - 外部キー: `fk_<table>_<referenced_table>`

```sql
-- Good: pgvector統合テーブル定義
CREATE TABLE faqs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    facility_id UUID NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    question TEXT NOT NULL,
    answer TEXT NOT NULL,
    language VARCHAR(10) NOT NULL DEFAULT 'en',
    category VARCHAR(50),
    embedding vector(1536),  -- OpenAI text-embedding-3-small
    is_active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);

-- pgvectorインデックス
CREATE INDEX idx_faqs_embedding ON faqs 
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- 複合インデックス
CREATE INDEX idx_faqs_facility_language ON faqs(facility_id, language, is_active);
```

### 16.2 Git規約

#### ブランチ戦略

```
main (本番)
  ↑
develop (開発)
  ↑
feature/xxx (機能開発)
  ├ feature/rag-integration
  ├ feature/escalation-schedule
  ├ feature/password-reset
  └ feature/dark-mode
hotfix/xxx (緊急修正)
release/v0.2.x (リリース準備)
```

#### コミットメッセージ

```
<type>(<scope>): <subject>

<body>

<footer>

Types:
- feat: 新機能
- fix: バグ修正
- docs: ドキュメント
- style: フォーマット
- refactor: リファクタリング
- test: テスト追加
- chore: ビルド・設定変更
- perf: パフォーマンス改善
- ci: CI/CD変更

Scopes:
- backend: FastAPI関連
- frontend: Vue.js関連
- db: データベース関連
- ai: AI/RAG関連
- auth: 認証関連
- ui: UI/UX関連
```

例:
```
feat(ai): Add RAG integration with pgvector

- Implement embedding generation using OpenAI text-embedding-3-small
- Add pgvector similarity search for FAQ matching
- Integrate GPT-4o mini with context building
- Calculate AI confidence score with FAQ similarity bonus

Closes #123
```

```
fix(auth): Fix password reset token expiration

- Set token expiration to 1 hour (was 24 hours)
- Add token validation in reset confirmation endpoint
- Update error messages for expired tokens

Fixes #456
```

### 16.3 テスト規約

#### Backend (pytest)

```python
# tests/test_chat_rag.py

import pytest
from unittest.mock import AsyncMock, patch
from app.ai.rag_engine import RAGEngine
from app.ai.chat_engine import ChatEngine

@pytest.fixture
async def rag_engine():
    """RAGエンジンのモック"""
    engine = RAGEngine()
    engine.generate_embedding = AsyncMock(
        return_value=[0.1] * 1536  # ダミー埋め込みベクトル
    )
    engine.search_faqs = AsyncMock(
        return_value=[
            FAQ(id="faq-1", question="WiFi?", answer="guest2024"),
            FAQ(id="faq-2", question="Checkout?", answer="11:00 AM")
        ]
    )
    engine.generate_response = AsyncMock(
        return_value="The WiFi password is guest2024."
    )
    return engine

@pytest.fixture
async def chat_engine(rag_engine):
    """チャットエンジン"""
    return ChatEngine(rag_engine=rag_engine)

@pytest.mark.asyncio
async def test_rag_faq_matching(chat_engine, rag_engine):
    """RAGによるFAQマッチングのテスト"""
    message = "What is the WiFi password?"
    facility_id = "test-facility-uuid"
    session_id = "test-session-uuid"
    
    response = await chat_engine.process_message(
        message=message,
        facility_id=facility_id,
        session_id=session_id
    )
    
    assert response["content"] == "The WiFi password is guest2024."
    assert response["ai_confidence"] >= 0.7
    assert "faq-1" in response["matched_faq_ids"]
    
    # RAGエンジンの呼び出し確認
    rag_engine.generate_embedding.assert_called_once_with(message)
    rag_engine.search_faqs.assert_called_once()

@pytest.mark.asyncio
async def test_confidence_calculation_with_faq_bonus(chat_engine):
    """FAQ類似度ボーナスによる信頼度計算のテスト"""
    similar_faqs = [
        FAQ(id="faq-1", similarity=0.85),  # 高類似度
        FAQ(id="faq-2", similarity=0.75)
    ]
    response = "The WiFi password is guest2024."
    
    confidence = chat_engine._calculate_confidence(
        response=response,
        similar_faqs=similar_faqs
    )
    
    # FAQ類似度0.85以上で+0.3ボーナス
    assert confidence >= 0.8
```

#### Frontend (Vitest + Vue Test Utils)

```typescript
// tests/unit/ChatView.spec.ts

import { mount } from '@vue/test-utils'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { createPinia, setActivePinia } from 'pinia'
import ChatView from '@/views/guest/ChatView.vue'
import { useChatStore } from '@/stores/chat'

describe('ChatView.vue', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  
  it('sends message and displays AI response with confidence', async () => {
    const chatStore = useChatStore()
    const sendMessageSpy = vi.spyOn(chatStore, 'sendMessage')
      .mockResolvedValue({
        content: 'The WiFi password is guest2024.',
        ai_confidence: 0.85,
        matched_faq_ids: ['faq-1']
      })
    
    const wrapper = mount(ChatView, {
      props: {
        facilityId: 'test-facility',
        sessionId: 'test-session'
      },
      global: {
        plugins: [createPinia()]
      }
    })
    
    const input = wrapper.find('input[type="text"]')
    const button = wrapper.find('button[type="submit"]')
    
    await input.setValue('What is the WiFi password?')
    await button.trigger('click')
    
    await wrapper.vm.$nextTick()
    
    expect(sendMessageSpy).toHaveBeenCalledWith({
      facilityId: 'test-facility',
      sessionId: 'test-session',
      message: 'What is the WiFi password?'
    })
    
    expect(wrapper.text()).toContain('The WiFi password is guest2024.')
    expect(wrapper.text()).toContain('Confidence: 85%')
  })
  
  it('displays dark mode toggle', async () => {
    const wrapper = mount(ChatView, {
      props: {
        facilityId: 'test-facility',
        sessionId: 'test-session'
      }
    })
    
    const darkModeToggle = wrapper.find('[data-testid="dark-mode-toggle"]')
    expect(darkModeToggle.exists()).toBe(true)
    
    await darkModeToggle.trigger('click')
    expect(document.documentElement.classList.contains('dark')).toBe(true)
  })
})
```

#### テストカバレッジ目標

- **Backend**: 80%以上（AIエンジン、認証、APIエンドポイント）
- **Frontend**: 70%以上（コンポーネント、ストア、ユーティリティ）
- **統合テスト**: 主要フロー（チャット、認証、エスカレーション）

### 16.4 ドキュメント規約

#### API仕様書

- **OpenAPI 3.0形式**
- **FastAPIの自動生成機能使用**
- `/docs` (Swagger UI)
- `/redoc` (ReDoc)
- **v0.2追加**: RAG統合型レスポンス、エスカレーションスケジュール、パスワードリセット

```python
# app/api/v1/chat.py

from fastapi import APIRouter, Depends
from pydantic import BaseModel, Field
from typing import Optional

router = APIRouter(prefix="/chat", tags=["chat"])

class ChatMessageRequest(BaseModel):
    """チャットメッセージリクエスト"""
    message: str = Field(..., min_length=1, max_length=500)
    session_id: str = Field(..., description="セッションID")

class ChatMessageResponse(BaseModel):
    """チャットメッセージレスポンス（RAG統合型）"""
    content: str = Field(..., description="AI応答")
    ai_confidence: float = Field(
        ...,
        ge=0.0,
        le=1.0,
        description="AI信頼度スコア（0.0-1.0）"
    )
    matched_faq_ids: list[str] = Field(
        default_factory=list,
        description="マッチしたFAQ IDリスト"
    )
    escalation_required: bool = Field(
        default=False,
        description="エスカレーション要否"
    )

@router.post("/message", response_model=ChatMessageResponse)
async def send_message(
    request: ChatMessageRequest,
    facility_id: str = Depends(get_facility_id)
):
    """
    チャットメッセージ送信（RAG統合型）
    
    - 埋め込みベクトル生成
    - pgvectorで類似FAQ検索
    - GPT-4o miniで回答生成
    - 信頼度スコア計算
    - エスカレーション判定
    """
    ...
```

#### コードコメント

```python
# 複雑なロジックにのみコメント
# 自明なコードにはコメント不要

# Good: RAG統合処理の説明
# Generate embedding vector using OpenAI text-embedding-3-small
# Dimension: 1536, Cost: ¥0.0001/1K tokens
embedding = await self.rag_engine.generate_embedding(question)

# Search similar FAQs using pgvector cosine similarity
# Top 3 results, threshold: 0.7
similar_faqs = await self.rag_engine.search_faqs(
    embedding=embedding,
    facility_id=facility_id,
    top_k=3
)

# Calculate confidence with FAQ similarity bonus
# Bonus: +0.3 if similarity >= 0.8, Penalty: -0.2 if response < 20 chars
confidence = self._calculate_confidence(response, similar_faqs)

# Bad: 自明なコードへの不要なコメント
# Get facility by ID
facility = db.query(Facility).filter(Facility.id == facility_id).first()
```

### 16.5 環境変数管理

#### Backend (.env.example)

```bash
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/yadopera
POSTGRES_USER=yadopera
POSTGRES_PASSWORD=your_password
POSTGRES_DB=yadopera

# Redis
REDIS_URL=redis://localhost:6379/0
REDIS_SESSION_DB=1
REDIS_CACHE_DB=2
REDIS_RATE_LIMIT_DB=3

# OpenAI API
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o-mini
OPENAI_EMBEDDING_MODEL=text-embedding-3-small
OPENAI_EMBEDDING_DIMENSION=1536

# JWT
JWT_SECRET_KEY=your-secret-key-change-in-production
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=10080  # 7 days
JWT_REFRESH_TOKEN_EXPIRE_DAYS=30

# Session
SESSION_COOKIE_NAME=yadopera_session
SESSION_COOKIE_MAX_AGE=86400  # 24 hours
SESSION_COOKIE_SECURE=true  # HTTPS only
SESSION_COOKIE_HTTPONLY=true

# CORS
CORS_ORIGINS=https://yadopera.com,https://admin.yadopera.com
CORS_ALLOW_CREDENTIALS=true

# AWS S3 (QR Code Storage)
AWS_ACCESS_KEY_ID=...
AWS_SECRET_ACCESS_KEY=...
AWS_S3_BUCKET=yadopera-qr-codes
AWS_REGION=ap-northeast-1

# Email (Password Reset)
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=...
SMTP_PASSWORD=...
SMTP_FROM_EMAIL=noreply@yadopera.com

# Rate Limiting
RATE_LIMIT_CHAT_PER_MINUTE=10
RATE_LIMIT_AUTH_PER_MINUTE=5

# Environment
ENVIRONMENT=development  # development, staging, production
DEBUG=true
LOG_LEVEL=INFO
```

#### Frontend (.env.example)

```bash
# API
VITE_API_BASE_URL=http://localhost:8000/api/v1
VITE_API_TIMEOUT=30000

# Frontend
VITE_APP_NAME=やどぺら
VITE_APP_VERSION=0.2.0
VITE_PWA_ENABLED=true

# Feature Flags
VITE_FEATURE_DARK_MODE=true
VITE_FEATURE_PWA=true
VITE_FEATURE_ESCALATION_SCHEDULE=true

# Environment
VITE_ENVIRONMENT=development  # development, staging, production
```

### 16.6 セキュリティ規約

#### パスワード管理

```python
# Good: bcrypt使用、ラウンド数12
from bcrypt import hashpw, gensalt, checkpw

def hash_password(password: str) -> str:
    """パスワードハッシュ化（bcrypt）"""
    salt = gensalt(rounds=12)
    return hashpw(password.encode('utf-8'), salt).decode('utf-8')

def verify_password(password: str, hashed: str) -> bool:
    """パスワード検証"""
    return checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
```

#### SQLインジェクション対策

```python
# Good: SQLAlchemy ORM使用（自動エスケープ）
user = db.query(User).filter(User.email == email).first()

# Bad: 生SQL（絶対に使用禁止）
# db.execute(f"SELECT * FROM users WHERE email = '{email}'")
```

#### XSS対策

```typescript
// Good: Vue 3の自動エスケープ
<template>
  <div>{{ userInput }}</div>  <!-- 自動エスケープ -->
</template>

// 危険: v-html使用時はサニタイズ必須
import DOMPurify from 'dompurify'
<div v-html="DOMPurify.sanitize(htmlContent)"></div>
```

#### セッション管理

```python
# Good: Redis + Cookie、24時間有効期限
session_id = str(uuid.uuid4())
session_data = {
    "facility_id": facility_id,
    "created_at": datetime.utcnow().isoformat(),
    "expires_at": (datetime.utcnow() + timedelta(hours=24)).isoformat()
}

await redis.setex(
    f"session:{session_id}",
    86400,  # 24 hours
    json.dumps(session_data)
)

response.set_cookie(
    key="yadopera_session",
    value=session_id,
    max_age=86400,
    httponly=True,
    secure=True,
    samesite="lax"
)
```

### 16.7 パフォーマンス規約

#### データベースクエリ最適化

```python
# Good: インデックス活用、N+1問題回避
faqs = db.query(FAQ).filter(
    FAQ.facility_id == facility_id,
    FAQ.is_active == True
).options(
    joinedload(FAQ.facility)  # Eager loading
).all()

# Bad: N+1問題
# for faq in faqs:
#     facility = db.query(Facility).filter(Facility.id == faq.facility_id).first()
```

#### Redisキャッシュ戦略

```python
# Good: キャッシュキー設計、TTL設定
CACHE_TTL_FACILITY_INFO = 3600  # 1 hour
CACHE_TTL_FAQ_LIST = 1800  # 30 minutes

async def get_facility_info(facility_id: str) -> dict:
    cache_key = f"facility:{facility_id}:info"
    
    # キャッシュ確認
    cached = await redis.get(cache_key)
    if cached:
        return json.loads(cached)
    
    # DB取得
    facility = db.query(Facility).filter(Facility.id == facility_id).first()
    info = {
        "id": facility.id,
        "name": facility.name,
        "wifi_password": facility.wifi_password
    }
    
    # キャッシュ保存
    await redis.setex(cache_key, CACHE_TTL_FACILITY_INFO, json.dumps(info))
    return info
```

#### pgvector最適化

```python
# Good: インデックス活用、Top K制限
similar_faqs = await db.execute(
    select(FAQ)
    .filter(FAQ.facility_id == facility_id)
    .filter(FAQ.is_active == True)
    .order_by(FAQ.embedding.cosine_distance(embedding))
    .limit(3)  # Top 3のみ取得
)
```

### 16.8 コードレビュー規約

#### レビューチェックリスト

- [ ] 型ヒント（Python/TypeScript）が適切に記述されている
- [ ] エラーハンドリングが適切に実装されている
- [ ] セキュリティ対策（SQLi/XSS/認証）が実装されている
- [ ] テストコードが追加されている（新機能）
- [ ] パフォーマンス最適化（N+1問題、キャッシュ）が考慮されている
- [ ] ドキュメント（コメント、API仕様）が更新されている
- [ ] 環境変数が`.env.example`に追加されている（新規追加時）
- [ ] マイグレーションスクリプトが追加されている（DB変更時）

#### レビューコメント例

```python
# レビューコメント: 型ヒント追加推奨
# Before
def process_message(message, facility_id):
    ...

# After
def process_message(message: str, facility_id: str) -> dict[str, Any]:
    ...
```

```python
# レビューコメント: エラーハンドリング追加
# Before
response = await openai_client.chat.completions.create(...)

# After
try:
    response = await openai_client.chat.completions.create(...)
except openai.APIError as e:
    logger.error(f"OpenAI API error: {e}")
    raise HTTPException(status_code=503, detail="AI service unavailable")
```

---

## 付録

### A. FAQ初期テンプレート30件

開発時に参照できるFAQ初期テンプレートの詳細リストです。

#### 基本情報（5件）

1. **チェックイン/チェックアウト時間は？**
   - カテゴリ: `basic`
   - 優先度: 5
   - 回答例: "Check-in is from 3:00 PM to 10:00 PM. Check-out is by 11:00 AM."

2. **WiFiパスワードは？**
   - カテゴリ: `basic`
   - 優先度: 5
   - 回答例: "The WiFi password is guest2024. The SSID is [FacilityName]_WiFi."

3. **門限はありますか？**
   - カテゴリ: `basic`
   - 優先度: 4
   - 回答例: "There is no curfew, but please be considerate of other guests after 10:00 PM."

4. **朝食は提供されますか？**
   - カテゴリ: `basic`
   - 優先度: 3
   - 回答例: "Breakfast is not included, but there are many cafes nearby. Ask staff for recommendations."

5. **支払い方法は？**
   - カテゴリ: `basic`
   - 優先度: 4
   - 回答例: "We accept cash and credit cards (Visa, Mastercard). Payment is due at check-in."

#### 設備・サービス（10件）

6. **コインランドリーはありますか？**
   - カテゴリ: `facilities`
   - 優先度: 4
   - 回答例: "Yes, there is a coin laundry on the 2nd floor. Washing costs ¥200 per load."

7. **キッチンは使えますか？**
   - カテゴリ: `facilities`
   - 優先度: 4
   - 回答例: "Yes, the shared kitchen is available 24/7. Please clean up after use."

8. **タオルはありますか？**
   - カテゴリ: `facilities`
   - 優先度: 3
   - 回答例: "Towels are available at the reception. Please return them before check-out."

9. **ドライヤーはありますか？**
   - カテゴリ: `facilities`
   - 優先度: 3
   - 回答例: "Hair dryers are available in the shared bathroom on each floor."

10. **喫煙所はありますか？**
    - カテゴリ: `facilities`
    - 優先度: 3
    - 回答例: "Smoking is only allowed in the designated area outside. Smoking inside is strictly prohibited."

11. **荷物預かりはできますか？**
    - カテゴリ: `facilities`
    - 優先度: 3
    - 回答例: "Yes, we can store your luggage before check-in or after check-out. Please ask at reception."

12. **自転車レンタルはありますか？**
    - カテゴリ: `facilities`
    - 優先度: 2
    - 回答例: "Bicycle rental is available nearby. Ask staff for details and recommendations."

13. **シャワーは24時間使えますか？**
    - カテゴリ: `facilities`
    - 優先度: 4
    - 回答例: "Yes, showers are available 24/7. Hot water is available from 6:00 AM to 11:00 PM."

14. **共用スペースの利用時間は？**
    - カテゴリ: `facilities`
    - 優先度: 3
    - 回答例: "The common area is open 24/7, but please keep noise down after 10:00 PM."

15. **プリンターは使えますか？**
    - カテゴリ: `facilities`
    - 優先度: 2
    - 回答例: "A printer is available at the reception. Printing costs ¥50 per page."

#### 周辺情報（5件）

16. **最寄りのコンビニはどこですか？**
    - カテゴリ: `location`
    - 優先度: 4
    - 回答例: "The nearest convenience store is 7-Eleven, about 3 minutes walk. Turn right at the main entrance."

17. **おすすめのレストランは？**
    - カテゴリ: `location`
    - 優先度: 3
    - 回答例: "There are many great restaurants nearby. Ask staff for recommendations based on your preferences."

18. **駅までの行き方は？**
    - カテゴリ: `location`
    - 優先度: 5
    - 回答例: "The nearest station is [StationName], about 10 minutes walk. Turn left at the main entrance and go straight."

19. **近くのATMはどこですか？**
    - カテゴリ: `location`
    - 優先度: 3
    - 回答例: "There is an ATM at the convenience store nearby, or at the bank 5 minutes away."

20. **観光地へのアクセスは？**
    - カテゴリ: `location`
    - 優先度: 3
    - 回答例: "Popular tourist spots are easily accessible by train. Ask staff for a map and directions."

#### トラブル対応（5件）

21. **鍵を部屋に忘れました**
    - カテゴリ: `trouble`
    - 優先度: 5
    - 回答例: "Please contact staff immediately. We can help you access your room. Emergency contact: [Phone Number]."

22. **WiFiに繋がりません**
    - カテゴリ: `trouble`
    - 優先度: 4
    - 回答例: "Please check the SSID and password. If it still doesn't work, try restarting your device or contact staff."

23. **エアコンが動きません**
    - カテゴリ: `trouble`
    - 優先度: 4
    - 回答例: "Please check the remote control batteries. If it still doesn't work, contact staff and we'll send someone to help."

24. **お湯が出ません**
    - カテゴリ: `trouble`
    - 優先度: 4
    - 回答例: "Hot water is available from 6:00 AM to 11:00 PM. If it's during these hours and still not working, contact staff."

25. **騒音が気になります**
    - カテゴリ: `trouble`
    - 優先度: 3
    - 回答例: "We apologize for the inconvenience. Please contact staff and we'll address the issue immediately."

#### 拡張（5件）

26. **チェックアウト延長は可能ですか？**
    - カテゴリ: `basic`
    - 優先度: 3
    - 回答例: "Late check-out may be possible depending on availability. Please ask staff at least one day in advance."

27. **宅配便は受け取れますか？**
    - カテゴリ: `facilities`
    - 優先度: 2
    - 回答例: "Yes, we can receive packages. Please include your name and check-in date. Contact staff for details."

28. **タクシーを呼んでもらえますか？**
    - カテゴリ: `location`
    - 優先度: 3
    - 回答例: "Yes, we can help you call a taxi. Please ask at reception or contact staff."

29. **延泊したいのですが**
    - カテゴリ: `basic`
    - 優先度: 3
    - 回答例: "Extension is possible if rooms are available. Please contact staff as soon as possible to check availability."

30. **アレルギー対応はできますか？**
    - カテゴリ: `basic`
    - 優先度: 2
    - 回答例: "Please inform staff about any allergies when you check in. We'll do our best to accommodate your needs."

---

以上で「やどぺら v0.2 アーキテクチャ設計書」の全16セクションと付録が完成しました。


================================================================================
YadOPERA メールアドレス確認機能実装計画書
================================================================================

作成日: 2026年01月26日
バージョン: v1.0
対象: Phase 4 新規登録ページのメール認証機能実装

================================================================================
目次
================================================================================

1. 概要
2. 現状分析
3. Brevo設定ガイド
4. データベース設計
5. バックエンド実装
6. フロントエンド実装
7. Docker環境での動作確認手順
8. ステージング環境デプロイ手順
9. 本番環境デプロイ手順
10. トラブルシューティング

================================================================================
1. 概要
================================================================================

## 1.1 目的
新規登録時にメールアドレスの確認を行い、不正登録を防止する。

## 1.2 要件
- 登録時にメールアドレスに確認用URLを送信
- 確認用URLの有効期限は24時間
- メール確認完了まではログイン不可
- メール再送信機能を提供
- Brevo無料プラン（月300通）を使用

## 1.3 実装フロー

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. ユーザーが新規登録フォームを送信                              │
│    ↓                                                             │
│ 2. バックエンド: 施設・ユーザー作成（is_active=False）          │
│    ↓                                                             │
│ 3. バックエンド: 確認トークン生成（UUID4）                      │
│    ↓                                                             │
│ 4. バックエンド: Brevoで確認メール送信                          │
│    ↓                                                             │
│ 5. フロントエンド: 「確認メールを送信しました」画面表示        │
│    ↓                                                             │
│ 6. ユーザー: メール内のURLをクリック                            │
│    ↓                                                             │
│ 7. バックエンド: トークン検証・有効期限チェック                │
│    ↓                                                             │
│ 8. バックエンド: is_active=True, email_verified=True に更新    │
│    ↓                                                             │
│ 9. フロントエンド: 「確認完了、ログインしてください」画面表示  │
└─────────────────────────────────────────────────────────────────┘
```

================================================================================
2. 現状分析
================================================================================

## 2.1 現在の登録フロー

**フロントエンド (frontend/src/views/admin/Register.vue)**
- 施設名、メールアドレス、パスワード、料金プランを入力
- `/api/v1/auth/register` にPOSTリクエスト
- 成功時は即座にログイン状態になる

**バックエンド (backend/app/api/v1/auth.py)**
- `register_facility()` エンドポイント
- 施設とユーザーを作成し、即座にJWTトークンを返却
- FAQ自動投入はバックグラウンドで実行

**問題点**
- メールアドレスの確認なし
- 不正なメールアドレスでも登録可能
- なりすまし登録のリスク

## 2.2 必要な変更

### データベース
- usersテーブルに以下を追加:
  - email_verified (Boolean)
  - verification_token (String)
  - verification_token_expires (DateTime)

### バックエンド
- メール送信サービス（Brevo連携）
- トークン生成・検証ロジック
- 新規登録API修正（is_active=False）
- メール確認API追加
- 再送信API追加

### フロントエンド
- Register.vue修正（成功時の遷移先変更）
- メール確認待ち画面（EmailVerificationPending.vue）
- メール確認完了画面（EmailVerificationSuccess.vue）
- 再送信ボタン

================================================================================
3. Brevo設定ガイド
================================================================================

## 3.1 Brevo API Key取得手順

1. Brevoにログイン
   URL: https://app.brevo.com/

2. 右上のアカウント名をクリック → 「SMTP & API」を選択

3. 「API Keys」タブを選択

4. 「Create a new API key」をクリック

5. API Key名を入力（例: "YadOPERA Production"）

6. 生成されたAPI Keyをコピー（一度しか表示されないので注意）

7. backend/.env に追加:
   ```
   BREVO_API_KEY=xkeysib-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
   ```

## 3.2 送信元メールアドレス（noreply@yadopera.com）設定手順

### 3.2.1 Brevoでドメイン認証

1. Brevoにログイン後、「Senders, Domains & Dedicated IPs」を選択

2. 「Domains」タブを選択

3. 「Add a Domain」をクリック

4. ドメイン名「yadopera.com」を入力

5. Brevoが提供するDNSレコード情報を確認（次のステップで使用）

### 3.2.2 DNS設定（Cloudflare）

Cloudflareのダッシュボードで以下のDNSレコードを追加:

**SPFレコード（TXTレコード）**
```
Type: TXT
Name: @
Content: v=spf1 include:spf.brevo.com ~all
TTL: Auto
Proxy: DNS only（オレンジ雲マークOFF）
```

**DKIMレコード（TXTレコード、Brevoが提供）**
```
Type: TXT
Name: mail._domainkey
Content: [Brevoが提供する値をコピー]
TTL: Auto
Proxy: DNS only（オレンジ雲マークOFF）
```

**MXレコード（オプション、受信用）**
```
Type: MX
Name: @
Content: mx.brevo.com
Priority: 10
TTL: Auto
Proxy: DNS only（オレンジ雲マークOFF）
```

### 3.2.3 DNS設定確認

1. DNS設定後、10-30分待つ（DNS伝播時間）

2. ターミナルで確認:
   ```bash
   # SPFレコード確認
   dig TXT yadopera.com +short
   
   # DKIMレコード確認
   dig TXT mail._domainkey.yadopera.com +short
   ```

3. Brevoのダッシュボードで「Verify」をクリック

4. 認証成功すると緑色のチェックマークが表示される

### 3.2.4 送信元メールアドレス追加

1. Brevoで「Senders, Domains & Dedicated IPs」→「Senders」タブ

2. 「Add a Sender」をクリック

3. 以下を入力:
   - Email: noreply@yadopera.com
   - Name: YadOPERA
   - Default: チェック（デフォルト送信元にする）

4. 「Create」をクリック

5. 確認メールが noreply@yadopera.com に送信される
   （このアドレスのメール受信設定が必要）

6. 確認メール内のリンクをクリックして認証完了

**注意**: noreply@yadopera.comのメール受信設定
- Cloudflareの「Email Routing」機能を使用
- noreply@yadopera.comを別のメールアドレス（例: kurinobu@example.com）に転送
- または、Brevoの「Inbox」機能を使用

## 3.3 Brevo無料プランの制限

- 月間送信上限: 300通
- 1日送信上限: 制限なし
- 送信速度制限: なし
- Brevoロゴ: メール下部に表示される（有料プランで削除可能）

**想定送信数（MVP段階）**
- 新規登録: 3施設×1通 = 3通
- 再送信: 3施設×2通（想定） = 6通
- 合計: 9通/月（十分余裕あり）

================================================================================
4. データベース設計
================================================================================

## 4.1 usersテーブル修正

### 追加カラム

```sql
-- メールアドレス確認済みフラグ
email_verified BOOLEAN DEFAULT FALSE NOT NULL

-- メール確認トークン（UUID4形式）
verification_token VARCHAR(255) NULL

-- トークン有効期限（24時間後）
verification_token_expires TIMESTAMP WITH TIME ZONE NULL

-- インデックス（トークン検索用）
CREATE INDEX idx_users_verification_token 
ON users(verification_token) 
WHERE verification_token IS NOT NULL;
```

### 修正後のusersテーブル全体像

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    facility_id INTEGER NOT NULL REFERENCES facilities(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) DEFAULT 'staff',
    full_name VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE,
    email_verified BOOLEAN DEFAULT FALSE NOT NULL,  -- ★追加
    verification_token VARCHAR(255),  -- ★追加
    verification_token_expires TIMESTAMP WITH TIME ZONE,  -- ★追加
    last_login_at TIMESTAMP WITH TIME ZONE,
    password_reset_token VARCHAR(255),
    password_reset_expires TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- インデックス
CREATE UNIQUE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_facility_id ON users(facility_id);
CREATE INDEX idx_users_password_reset_token ON users(password_reset_token) 
    WHERE password_reset_token IS NOT NULL;
CREATE INDEX idx_users_verification_token ON users(verification_token)  -- ★追加
    WHERE verification_token IS NOT NULL;
```

## 4.2 マイグレーションファイル作成

**ファイル名**: `backend/alembic/versions/013_add_email_verification.py`

```python
"""add email verification

Revision ID: 013
Revises: 012
Create Date: 2026-01-26 10:00:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '013'
down_revision = '012'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # email_verified カラム追加（デフォルト: False）
    op.add_column('users', sa.Column('email_verified', sa.Boolean(), 
                                      nullable=False, server_default='false'))
    
    # verification_token カラム追加
    op.add_column('users', sa.Column('verification_token', sa.String(255), 
                                      nullable=True))
    
    # verification_token_expires カラム追加
    op.add_column('users', sa.Column('verification_token_expires', 
                                      sa.DateTime(timezone=True), nullable=True))
    
    # verification_token インデックス作成（部分インデックス）
    op.execute("""
        CREATE INDEX idx_users_verification_token 
        ON users(verification_token) 
        WHERE verification_token IS NOT NULL
    """)
    
    # 既存ユーザーは全員メール確認済みとして扱う
    op.execute("UPDATE users SET email_verified = true WHERE id IS NOT NULL")


def downgrade() -> None:
    # インデックス削除
    op.drop_index('idx_users_verification_token', table_name='users')
    
    # カラム削除
    op.drop_column('users', 'verification_token_expires')
    op.drop_column('users', 'verification_token')
    op.drop_column('users', 'email_verified')
```

## 4.3 マイグレーション実行

```bash
# Docker環境で実行
docker-compose exec backend alembic upgrade head

# 確認
docker-compose exec backend alembic current
```

================================================================================
5. バックエンド実装
================================================================================

## 5.1 Brevoライブラリインストール

### requirements.txt に追加

**ファイル**: `backend/requirements.txt`

```txt
# 既存の依存関係...

# Email
sib-api-v3-sdk==7.6.0  # Brevo公式SDKの最新版
```

### インストール実行

```bash
# Docker環境で実行
docker-compose exec backend pip install sib-api-v3-sdk==7.6.0

# または、コンテナ再ビルド
docker-compose build backend
docker-compose up -d backend
```

## 5.2 環境変数設定

### backend/.env に追加

```env
# Email (Brevo)
BREVO_API_KEY=xkeysib-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
BREVO_SENDER_EMAIL=noreply@yadopera.com
BREVO_SENDER_NAME=YadOPERA

# Frontend URL (メール内のリンク用)
FRONTEND_URL=http://localhost:5173
```

### backend/.env.example に追加

```env
# Email (Brevo)
BREVO_API_KEY=your_brevo_api_key_here
BREVO_SENDER_EMAIL=noreply@yadopera.com
BREVO_SENDER_NAME=YadOPERA

# Frontend URL (メール内のリンク用)
FRONTEND_URL=http://localhost:5173
```

## 5.3 メール送信サービス作成

**ファイル**: `backend/app/services/email_service.py`（新規作成）

```python
"""
メール送信サービス（Brevo連携）
"""

import sib_api_v3_sdk
from sib_api_v3_sdk.rest import ApiException
from app.core.config import settings
import logging
from typing import Optional

logger = logging.getLogger(__name__)


class EmailService:
    """
    Brevoを使用したメール送信サービス
    """
    
    def __init__(self):
        """
        Brevo API設定
        """
        configuration = sib_api_v3_sdk.Configuration()
        configuration.api_key['api-key'] = settings.brevo_api_key
        self.api_instance = sib_api_v3_sdk.TransactionalEmailsApi(
            sib_api_v3_sdk.ApiClient(configuration)
        )
    
    async def send_verification_email(
        self,
        to_email: str,
        to_name: str,
        verification_url: str
    ) -> bool:
        """
        メールアドレス確認メールを送信
        
        Args:
            to_email: 送信先メールアドレス
            to_name: 送信先名（施設名）
            verification_url: 確認用URL
        
        Returns:
            送信成功時True、失敗時False
        """
        try:
            # メール本文（HTML）
            html_content = f"""
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メールアドレス確認 - YadOPERA</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="background-color: #f8f9fa; border-radius: 10px; padding: 30px; margin-bottom: 20px;">
        <h1 style="color: #2563eb; margin-top: 0;">YadOPERA</h1>
        <h2 style="color: #1f2937; margin-bottom: 20px;">メールアドレス確認</h2>
        
        <p style="font-size: 16px; margin-bottom: 20px;">
            {to_name} 様
        </p>
        
        <p style="font-size: 16px; margin-bottom: 20px;">
            YadOPERAにご登録いただきありがとうございます。<br>
            以下のボタンをクリックして、メールアドレスの確認を完了してください。
        </p>
        
        <div style="text-align: center; margin: 30px 0;">
            <a href="{verification_url}" 
               style="display: inline-block; background-color: #2563eb; color: white; 
                      padding: 15px 40px; text-decoration: none; border-radius: 5px; 
                      font-size: 16px; font-weight: bold;">
                メールアドレスを確認する
            </a>
        </div>
        
        <p style="font-size: 14px; color: #6b7280; margin-bottom: 10px;">
            ボタンをクリックできない場合は、以下のURLをブラウザにコピー＆ペーストしてください：
        </p>
        <p style="font-size: 14px; color: #2563eb; word-break: break-all; margin-bottom: 20px;">
            {verification_url}
        </p>
        
        <p style="font-size: 14px; color: #ef4444; margin-bottom: 10px;">
            <strong>※ このリンクは24時間後に無効になります。</strong>
        </p>
        
        <p style="font-size: 14px; color: #6b7280; margin-bottom: 20px;">
            このメールに心当たりがない場合は、無視していただいて構いません。
        </p>
    </div>
    
    <div style="text-align: center; font-size: 12px; color: #9ca3af; padding-top: 20px; border-top: 1px solid #e5e7eb;">
        <p>© 2026 YadOPERA. All rights reserved.</p>
        <p>このメールは送信専用です。返信いただいてもお答えできません。</p>
    </div>
</body>
</html>
            """
            
            # メール本文（プレーンテキスト）
            text_content = f"""
YadOPERA - メールアドレス確認

{to_name} 様

YadOPERAにご登録いただきありがとうございます。
以下のURLにアクセスして、メールアドレスの確認を完了してください。

{verification_url}

※ このリンクは24時間後に無効になります。

このメールに心当たりがない場合は、無視していただいて構いません。

---
© 2026 YadOPERA. All rights reserved.
このメールは送信専用です。返信いただいてもお答えできません。
            """
            
            # メール送信設定
            send_smtp_email = sib_api_v3_sdk.SendSmtpEmail(
                to=[{"email": to_email, "name": to_name}],
                sender={
                    "email": settings.brevo_sender_email,
                    "name": settings.brevo_sender_name
                },
                subject="【YadOPERA】メールアドレス確認のお願い",
                html_content=html_content,
                text_content=text_content
            )
            
            # メール送信
            api_response = self.api_instance.send_transac_email(send_smtp_email)
            logger.info(
                f"Verification email sent successfully: to={to_email}, "
                f"message_id={api_response.message_id}"
            )
            return True
            
        except ApiException as e:
            logger.error(
                f"Brevo API error: to={to_email}, status={e.status}, "
                f"reason={e.reason}, body={e.body}"
            )
            return False
        except Exception as e:
            logger.error(
                f"Unexpected error sending verification email: to={to_email}, "
                f"error={str(e)}",
                exc_info=True
            )
            return False
    
    async def send_verification_reminder_email(
        self,
        to_email: str,
        to_name: str,
        verification_url: str
    ) -> bool:
        """
        メールアドレス確認リマインダーメールを送信（再送信用）
        
        Args:
            to_email: 送信先メールアドレス
            to_name: 送信先名（施設名）
            verification_url: 確認用URL
        
        Returns:
            送信成功時True、失敗時False
        """
        try:
            # メール本文（HTML）
            html_content = f"""
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メールアドレス確認（再送） - YadOPERA</title>
</head>
<body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px;">
    <div style="background-color: #f8f9fa; border-radius: 10px; padding: 30px; margin-bottom: 20px;">
        <h1 style="color: #2563eb; margin-top: 0;">YadOPERA</h1>
        <h2 style="color: #1f2937; margin-bottom: 20px;">メールアドレス確認（再送）</h2>
        
        <p style="font-size: 16px; margin-bottom: 20px;">
            {to_name} 様
        </p>
        
        <p style="font-size: 16px; margin-bottom: 20px;">
            メールアドレス確認メールを再送信いたしました。<br>
            以下のボタンをクリックして、メールアドレスの確認を完了してください。
        </p>
        
        <div style="text-align: center; margin: 30px 0;">
            <a href="{verification_url}" 
               style="display: inline-block; background-color: #2563eb; color: white; 
                      padding: 15px 40px; text-decoration: none; border-radius: 5px; 
                      font-size: 16px; font-weight: bold;">
                メールアドレスを確認する
            </a>
        </div>
        
        <p style="font-size: 14px; color: #6b7280; margin-bottom: 10px;">
            ボタンをクリックできない場合は、以下のURLをブラウザにコピー＆ペーストしてください：
        </p>
        <p style="font-size: 14px; color: #2563eb; word-break: break-all; margin-bottom: 20px;">
            {verification_url}
        </p>
        
        <p style="font-size: 14px; color: #ef4444; margin-bottom: 10px;">
            <strong>※ このリンクは24時間後に無効になります。</strong>
        </p>
        
        <p style="font-size: 14px; color: #6b7280; margin-bottom: 20px;">
            このメールに心当たりがない場合は、無視していただいて構いません。
        </p>
    </div>
    
    <div style="text-align: center; font-size: 12px; color: #9ca3af; padding-top: 20px; border-top: 1px solid #e5e7eb;">
        <p>© 2026 YadOPERA. All rights reserved.</p>
        <p>このメールは送信専用です。返信いただいてもお答えできません。</p>
    </div>
</body>
</html>
            """
            
            # メール本文（プレーンテキスト）
            text_content = f"""
YadOPERA - メールアドレス確認（再送）

{to_name} 様

メールアドレス確認メールを再送信いたしました。
以下のURLにアクセスして、メールアドレスの確認を完了してください。

{verification_url}

※ このリンクは24時間後に無効になります。

このメールに心当たりがない場合は、無視していただいて構いません。

---
© 2026 YadOPERA. All rights reserved.
このメールは送信専用です。返信いただいてもお答えできません。
            """
            
            # メール送信設定
            send_smtp_email = sib_api_v3_sdk.SendSmtpEmail(
                to=[{"email": to_email, "name": to_name}],
                sender={
                    "email": settings.brevo_sender_email,
                    "name": settings.brevo_sender_name
                },
                subject="【YadOPERA】メールアドレス確認のお願い（再送）",
                html_content=html_content,
                text_content=text_content
            )
            
            # メール送信
            api_response = self.api_instance.send_transac_email(send_smtp_email)
            logger.info(
                f"Verification reminder email sent successfully: to={to_email}, "
                f"message_id={api_response.message_id}"
            )
            return True
            
        except ApiException as e:
            logger.error(
                f"Brevo API error (reminder): to={to_email}, status={e.status}, "
                f"reason={e.reason}, body={e.body}"
            )
            return False
        except Exception as e:
            logger.error(
                f"Unexpected error sending verification reminder email: to={to_email}, "
                f"error={str(e)}",
                exc_info=True
            )
            return False
```

## 5.4 設定ファイル修正

**ファイル**: `backend/app/core/config.py`

```python
# 既存のインポート...
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # 既存の設定...
    
    # Email (Brevo) 設定追加
    brevo_api_key: str = ""
    brevo_sender_email: str = "noreply@yadopera.com"
    brevo_sender_name: str = "YadOPERA"
    
    # Frontend URL（メール内のリンク用）
    frontend_url: str = "http://localhost:5173"
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()
```

## 5.5 ユーザーモデル修正

**ファイル**: `backend/app/models/user.py`

```python
"""
ユーザーモデル
"""

from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.database import Base


class User(Base):
    """
    管理者ユーザーモデル
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    facility_id = Column(Integer, ForeignKey("facilities.id", ondelete="CASCADE"), 
                         nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    role = Column(String(50), default="staff")
    full_name = Column(String(255))
    is_active = Column(Boolean, default=True)
    
    # メールアドレス確認関連（★追加）
    email_verified = Column(Boolean, default=False, nullable=False)
    verification_token = Column(String(255), index=True)
    verification_token_expires = Column(DateTime(timezone=True))
    
    last_login_at = Column(DateTime(timezone=True))
    password_reset_token = Column(String(255), index=True)
    password_reset_expires = Column(DateTime(timezone=True))
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), 
                        onupdate=func.now())

    # リレーションシップ
    facility = relationship("Facility", back_populates="users")
```

## 5.6 認証スキーマ修正

**ファイル**: `backend/app/schemas/auth.py`

```python
"""
認証関連スキーマ
"""

from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime


class LoginRequest(BaseModel):
    """
    ログインリクエスト
    """
    email: EmailStr = Field(..., description="メールアドレス")
    password: str = Field(..., min_length=8, description="パスワード")


class UserResponse(BaseModel):
    """
    ユーザー情報レスポンス
    """
    id: int
    email: str
    full_name: Optional[str] = None
    role: str
    facility_id: int
    is_active: bool
    email_verified: bool  # ★追加

    class Config:
        from_attributes = True


class LoginResponse(BaseModel):
    """
    ログインレスポンス
    """
    access_token: str = Field(..., description="JWTアクセストークン")
    token_type: str = Field(default="bearer", description="トークンタイプ")
    expires_in: int = Field(..., description="トークン有効期限（秒）")
    user: UserResponse = Field(..., description="ユーザー情報")


class LogoutResponse(BaseModel):
    """
    ログアウトレスポンス
    """
    message: str = Field(default="Logged out successfully", description="ログアウトメッセージ")


class PasswordChangeRequest(BaseModel):
    """
    パスワード変更リクエスト
    """
    current_password: str = Field(..., min_length=1, description="現在のパスワード")
    new_password: str = Field(..., min_length=8, description="新しいパスワード（最小8文字）")
    confirm_password: str = Field(..., min_length=8, description="新しいパスワード（確認）")


class PasswordChangeResponse(BaseModel):
    """
    パスワード変更レスポンス
    """
    message: str = Field(default="Password changed successfully", 
                         description="パスワード変更メッセージ")


class FacilityRegisterRequest(BaseModel):
    """
    施設登録リクエスト
    """
    email: EmailStr = Field(..., description="施設管理者メールアドレス")
    password: str = Field(..., min_length=8, description="パスワード（最小8文字）")
    facility_name: str = Field(..., min_length=1, max_length=255, description="施設名")
    subscription_plan: str = Field(default="small", 
                                    description="料金プラン（free/mini/small/standard/premium）")


class FacilityRegisterResponse(BaseModel):
    """
    施設登録レスポンス（メール確認待ち）
    """
    message: str = Field(..., description="登録完了メッセージ")
    email: str = Field(..., description="登録メールアドレス")
    facility_name: str = Field(..., description="施設名")


class VerifyEmailRequest(BaseModel):
    """
    メールアドレス確認リクエスト
    """
    token: str = Field(..., min_length=1, description="確認トークン")


class VerifyEmailResponse(BaseModel):
    """
    メールアドレス確認レスポンス
    """
    message: str = Field(..., description="確認完了メッセージ")
    email: str = Field(..., description="確認済みメールアドレス")


class ResendVerificationRequest(BaseModel):
    """
    確認メール再送信リクエスト
    """
    email: EmailStr = Field(..., description="メールアドレス")


class ResendVerificationResponse(BaseModel):
    """
    確認メール再送信レスポンス
    """
    message: str = Field(..., description="再送信完了メッセージ")
    email: str = Field(..., description="送信先メールアドレス")
```

## 5.7 認証サービス修正

**ファイル**: `backend/app/services/auth_service.py`

主要な変更点：
1. `register_facility()` でメール確認トークン生成・メール送信
2. `verify_email()` でトークン検証・アカウント有効化
3. `resend_verification_email()` で確認メール再送信
4. ログイン時にemail_verifiedチェック追加

```python
"""
認証サービス
認証ビジネスロジック
"""

from __future__ import annotations

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from datetime import datetime, timedelta
from app.models.user import User
from app.models.facility import Facility
from app.core.security import verify_password, hash_password
from app.core.jwt import create_access_token
from app.core.config import settings
from app.schemas.auth import (
    LoginRequest, LoginResponse, UserResponse, 
    FacilityRegisterRequest, FacilityRegisterResponse,
    VerifyEmailRequest, VerifyEmailResponse,
    ResendVerificationRequest, ResendVerificationResponse
)
from app.schemas.faq import FAQRequest
from app.services.faq_service import FAQService
from app.services.email_service import EmailService  # ★追加
from app.data.faq_presets import FAQ_PRESETS
from app.core.plan_limits import filter_faq_presets_by_plan
from fastapi import HTTPException, status, BackgroundTasks, Request
from typing import Optional
import logging
import uuid  # ★追加

logger = logging.getLogger(__name__)


def convert_subscription_plan_to_plan_type(subscription_plan: str) -> str:
    """
    subscription_planをplan_typeに変換
    
    Args:
        subscription_plan: 料金プラン（'free', 'mini', 'small', 'standard', 'premium'）
    
    Returns:
        plan_type: プラン種別（'Free', 'Mini', 'Small', 'Standard', 'Premium'）
    """
    plan_mapping = {
        'free': 'Free',
        'mini': 'Mini',
        'small': 'Small',
        'standard': 'Standard',
        'premium': 'Premium'
    }
    return plan_mapping.get(subscription_plan.lower(), 'Free')


def get_plan_defaults(plan_type: str) -> dict:
    """
    プラン種別に応じたデフォルト値を取得
    
    Args:
        plan_type: プラン種別（'Free', 'Mini', 'Small', 'Standard', 'Premium'）
    
    Returns:
        プラン別デフォルト値（monthly_question_limit, faq_limit, language_limit）
    
    注意: language_limitはplan_limits.pyのPLAN_FAQ_LIMITSのlanguagesリストの長さと一致させる
    """
    defaults = {
        'Free': {
            'monthly_question_limit': 30,
            'faq_limit': 20,
            'language_limit': 1  # ["ja"]
        },
        'Mini': {
            'monthly_question_limit': None,  # 無制限
            'faq_limit': 20,
            'language_limit': 2  # ["ja", "en"]
        },
        'Small': {
            'monthly_question_limit': 200,
            'faq_limit': 20,
            'language_limit': 3  # ["ja", "en", "zh-TW"]
        },
        'Standard': {
            'monthly_question_limit': 500,
            'faq_limit': 20,
            'language_limit': 4  # ["ja", "en", "zh-TW", "fr"]
        },
        'Premium': {
            'monthly_question_limit': 1000,
            'faq_limit': None,  # 無制限
            'language_limit': None  # 無制限
        }
    }
    return defaults.get(plan_type, defaults['Free'])


class AuthService:
    """
    認証サービス
    """
    
    @staticmethod
    async def _generate_unique_slug(db: AsyncSession, base_name: str) -> str:
        """
        URLセーフなユニークslugを生成
        
        Args:
            db: データベースセッション
            base_name: 施設名
        
        Returns:
            str: ユニークなslug
        """
        import uuid
        import re
        
        # 施設名を英数字に変換（日本語は削除）
        slug_base = re.sub(r'[^\w\s-]', '', base_name.lower())
        slug_base = re.sub(r'[-\s]+', '-', slug_base).strip('-')
        
        # 英数字が存在しない場合はデフォルト値を使用
        if not slug_base or len(slug_base) < 1:
            slug_base = "facility"
        
        # 最大20文字に制限
        slug_base = slug_base[:20]
        
        # UUIDの先頭8文字を付与
        unique_id = str(uuid.uuid4())[:8]
        slug = f"{slug_base}-{unique_id}"
        
        # 念のため重複チェック（UUID使用時はほぼ不要だが安全のため）
        result = await db.execute(
            select(Facility).where(Facility.slug == slug)
        )
        if result.scalar_one_or_none() is not None:
            # 万が一重複した場合はUUID全体を使用
            slug = f"{slug_base}-{str(uuid.uuid4())}"
        
        return slug
    
    @staticmethod
    async def authenticate_user(
        db: AsyncSession,
        login_data: LoginRequest
    ) -> Optional[User]:
        """
        ユーザー認証
        
        Args:
            db: データベースセッション
            login_data: ログインリクエストデータ
            
        Returns:
            認証されたユーザー（認証失敗時はNone）
        """
        # ユーザー取得
        result = await db.execute(
            select(User).where(User.email == login_data.email)
        )
        user = result.scalar_one_or_none()
        
        if user is None:
            return None
        
        # パスワード検証
        if not verify_password(login_data.password, user.password_hash):
            return None
        
        # アクティブユーザーか確認
        if not user.is_active:
            return None
        
        # メールアドレス確認済みか確認（★追加）
        if not user.email_verified:
            return None
        
        return user
    
    @staticmethod
    async def login(
        db: AsyncSession,
        login_data: LoginRequest,
        request: Optional["Request"] = None
    ) -> LoginResponse:
        """
        ログイン処理
        
        Args:
            db: データベースセッション
            login_data: ログインリクエストデータ
            request: リクエストオブジェクト（IPアドレス、User-Agent取得用）
            
        Returns:
            ログインレスポンス
            
        Raises:
            HTTPException: 認証失敗時
        """
        # ユーザー認証
        user = await AuthService.authenticate_user(db, login_data)
        
        if user is None:
            # メールアドレス未確認の場合の詳細エラー（★追加）
            result = await db.execute(
                select(User).where(User.email == login_data.email)
            )
            existing_user = result.scalar_one_or_none()
            
            if existing_user and not existing_user.email_verified:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="Email address not verified. Please check your email and verify your account.",
                )
            
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect email or password",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        # 最終ログイン時刻更新
        user.last_login_at = datetime.utcnow()
        await db.commit()
        await db.refresh(user)
        
        # 管理者ログインログ記録（非同期）
        if request:
            from app.models.admin_activity_log import AdminActivityLog
            activity_log = AdminActivityLog(
                user_id=user.id,
                facility_id=user.facility_id,
                action_type="login",
                ip_address=request.client.host if request.client else None,
                user_agent=request.headers.get("user-agent")
            )
            db.add(activity_log)
            await db.commit()
        
        # JWTトークン生成
        access_token = create_access_token(
            data={"sub": str(user.id), "email": user.email}
        )
        
        # レスポンス作成
        return LoginResponse(
            access_token=access_token,
            token_type="bearer",
            expires_in=settings.access_token_expire_minutes * 60,
            user=UserResponse(
                id=user.id,
                email=user.email,
                full_name=user.full_name,
                role=user.role,
                facility_id=user.facility_id,
                is_active=user.is_active,
                email_verified=user.email_verified,  # ★追加
            )
        )
    
    @staticmethod
    async def logout(
        db: AsyncSession,
        user: User
    ) -> dict:
        """
        ログアウト処理（JWTは無効化しない、クライアント側で削除）
        
        Args:
            db: データベースセッション
            user: ユーザー
            
        Returns:
            ログアウトレスポンス
        """
        return {"message": "Logged out successfully"}
    
    @staticmethod
    async def register_facility_sync(
        db: AsyncSession,
        request: FacilityRegisterRequest
    ) -> tuple[User, Facility]:
        """
        施設登録処理（同期部分：施設・ユーザー作成のみ）
        
        Args:
            db: データベースセッション
            request: 施設登録リクエスト
        
        Returns:
            (User, Facility): 作成されたユーザーと施設
        
        Raises:
            HTTPException: 登録失敗時
        """
        # メールアドレス重複チェック
        result = await db.execute(
            select(User).where(User.email == request.email)
        )
        existing_user = result.scalar_one_or_none()
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
        
        # プラン情報を変換・設定
        plan_type = convert_subscription_plan_to_plan_type(request.subscription_plan)
        plan_defaults = get_plan_defaults(plan_type)
        
        # 施設作成
        facility = Facility(
            name=request.facility_name,
            slug=await AuthService._generate_unique_slug(db, request.facility_name),
            email=request.email,
            subscription_plan=request.subscription_plan,
            plan_type=plan_type,
            monthly_question_limit=plan_defaults['monthly_question_limit'],
            faq_limit=plan_defaults['faq_limit'],
            language_limit=plan_defaults['language_limit']
        )
        db.add(facility)
        await db.flush()
        
        # メール確認トークン生成（★追加）
        verification_token = str(uuid.uuid4())
        verification_token_expires = datetime.utcnow() + timedelta(hours=24)
        
        # ユーザー作成（★is_active=False, メール確認トークン設定）
        user = User(
            facility_id=facility.id,
            email=request.email,
            password_hash=hash_password(request.password),
            role="owner",
            full_name=None,
            is_active=False,  # ★メール確認まで無効
            email_verified=False,  # ★メール未確認
            verification_token=verification_token,  # ★トークン設定
            verification_token_expires=verification_token_expires  # ★有効期限設定
        )
        db.add(user)
        await db.flush()
        
        # コミット（施設・ユーザー作成を確定）
        await db.commit()
        
        return user, facility
    
    @staticmethod
    async def register_facility(
        db: AsyncSession,
        request: FacilityRegisterRequest,
        background_tasks: Optional[BackgroundTasks] = None
    ) -> FacilityRegisterResponse:
        """
        施設登録処理（メール確認メール送信）
        
        Args:
            db: データベースセッション
            request: 施設登録リクエスト
            background_tasks: バックグラウンドタスク（オプション）
        
        Returns:
            施設登録レスポンス（メール確認待ち）
        
        Raises:
            HTTPException: 登録失敗時
        """
        # 施設・ユーザー作成（同期処理）
        user, facility = await AuthService.register_facility_sync(db, request)
        
        # メール確認URL生成
        verification_url = (
            f"{settings.frontend_url}/admin/verify-email"
            f"?token={user.verification_token}"
        )
        
        # メール送信
        email_service = EmailService()
        email_sent = await email_service.send_verification_email(
            to_email=user.email,
            to_name=facility.name,
            verification_url=verification_url
        )
        
        if not email_sent:
            logger.error(
                f"Failed to send verification email: user_id={user.id}, "
                f"email={user.email}"
            )
            # メール送信失敗時もユーザー作成は完了しているので、
            # エラーを返さず、再送信を促すメッセージを返す
        
        # FAQ自動投入をバックグラウンドで実行
        if background_tasks:
            background_tasks.add_task(
                AuthService.register_facility_async_faqs,
                facility.id,
                user.id,
                request.subscription_plan
            )
        else:
            logger.warning(
                "BackgroundTasks not available, running FAQ creation synchronously"
            )
            await AuthService.register_facility_async_faqs(
                facility.id,
                user.id,
                request.subscription_plan
            )
        
        return FacilityRegisterResponse(
            message=(
                "Registration successful. Please check your email to verify your account."
            ),
            email=user.email,
            facility_name=facility.name
        )
    
    @staticmethod
    async def verify_email(
        db: AsyncSession,
        request: VerifyEmailRequest
    ) -> VerifyEmailResponse:
        """
        メールアドレス確認処理
        
        Args:
            db: データベースセッション
            request: メールアドレス確認リクエスト
        
        Returns:
            メールアドレス確認レスポンス
        
        Raises:
            HTTPException: 確認失敗時
        """
        # トークンでユーザー取得
        result = await db.execute(
            select(User).where(User.verification_token == request.token)
        )
        user = result.scalar_one_or_none()
        
        if user is None:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid verification token"
            )
        
        # 既に確認済みの場合
        if user.email_verified:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already verified"
            )
        
        # トークン有効期限チェック
        if user.verification_token_expires < datetime.utcnow():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Verification token has expired. Please request a new one."
            )
        
        # メールアドレス確認完了
        user.email_verified = True
        user.is_active = True  # アカウント有効化
        user.verification_token = None  # トークンクリア
        user.verification_token_expires = None  # 有効期限クリア
        
        await db.commit()
        await db.refresh(user)
        
        logger.info(
            f"Email verified successfully: user_id={user.id}, email={user.email}"
        )
        
        return VerifyEmailResponse(
            message="Email verified successfully. You can now log in.",
            email=user.email
        )
    
    @staticmethod
    async def resend_verification_email(
        db: AsyncSession,
        request: ResendVerificationRequest
    ) -> ResendVerificationResponse:
        """
        確認メール再送信処理
        
        Args:
            db: データベースセッション
            request: 確認メール再送信リクエスト
        
        Returns:
            確認メール再送信レスポンス
        
        Raises:
            HTTPException: 再送信失敗時
        """
        # メールアドレスでユーザー取得
        result = await db.execute(
            select(User).where(User.email == request.email)
        )
        user = result.scalar_one_or_none()
        
        if user is None:
            # セキュリティ上、ユーザーが存在しない場合でも同じレスポンスを返す
            return ResendVerificationResponse(
                message="If the email address is registered, a verification email has been sent.",
                email=request.email
            )
        
        # 既に確認済みの場合
        if user.email_verified:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already verified"
            )
        
        # 新しいトークン生成
        user.verification_token = str(uuid.uuid4())
        user.verification_token_expires = datetime.utcnow() + timedelta(hours=24)
        
        await db.commit()
        await db.refresh(user)
        
        # 施設情報取得
        facility_result = await db.execute(
            select(Facility).where(Facility.id == user.facility_id)
        )
        facility = facility_result.scalar_one_or_none()
        
        # メール確認URL生成
        verification_url = (
            f"{settings.frontend_url}/admin/verify-email"
            f"?token={user.verification_token}"
        )
        
        # メール送信
        email_service = EmailService()
        email_sent = await email_service.send_verification_reminder_email(
            to_email=user.email,
            to_name=facility.name if facility else "User",
            verification_url=verification_url
        )
        
        if not email_sent:
            logger.error(
                f"Failed to resend verification email: user_id={user.id}, "
                f"email={user.email}"
            )
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Failed to send verification email. Please try again later."
            )
        
        logger.info(
            f"Verification email resent: user_id={user.id}, email={user.email}"
        )
        
        return ResendVerificationResponse(
            message="Verification email resent successfully. Please check your inbox.",
            email=user.email
        )
    
    @staticmethod
    async def register_facility_async_faqs(
        facility_id: int,
        user_id: int,
        subscription_plan: str
    ):
        """
        FAQ自動投入処理（バックグラウンド実行）
        
        Args:
            facility_id: 施設ID
            user_id: ユーザーID
            subscription_plan: 料金プラン
        """
        from app.database import AsyncSessionLocal
        from app.data.faq_presets import FAQ_PRESETS
        from app.schemas.faq import FAQRequest
        from app.core.cache import delete_cache_pattern
        
        # 新しいデータベースセッションを作成
        async with AsyncSessionLocal() as db:
            try:
                # 料金プランに基づいてFAQプリセットをフィルタ
                filtered_presets = filter_faq_presets_by_plan(
                    FAQ_PRESETS,
                    subscription_plan
                )
                
                # プリセットFAQをFAQRequestに変換
                faq_requests = []
                for preset in filtered_presets:
                    faq_request = FAQRequest(
                        category=preset["category"],
                        intent_key=preset["intent_key"],
                        translations=[
                            {
                                "language": t["language"],
                                "question": t["question"],
                                "answer": t["answer"]
                            } for t in preset["translations"]
                        ],
                        priority=preset["priority"],
                        is_active=True
                    )
                    faq_requests.append(faq_request)
                
                # FAQ一括作成
                await FAQService(db).bulk_create_faqs(facility_id, faq_requests, user_id)
                await db.commit()
                
                # キャッシュを無効化
                try:
                    deleted_count = await delete_cache_pattern(
                        f"faq:list:*facility_id={facility_id}*"
                    )
                    logger.info(
                        f"FAQ cache invalidated: {deleted_count} keys deleted "
                        f"(facility_id={facility_id})"
                    )
                except Exception as e:
                    logger.warning(
                        f"Failed to invalidate FAQ cache: facility_id={facility_id}, "
                        f"error={str(e)}",
                        exc_info=True
                    )
                
                logger.info(
                    f"Background FAQ creation completed: facility_id={facility_id}, "
                    f"plan={subscription_plan}, count={len(faq_requests)}"
                )
                
                # 5秒待ってから再度キャッシュ無効化
                import asyncio
                await asyncio.sleep(5)
                
                try:
                    deleted_count = await delete_cache_pattern(
                        f"faq:list:*facility_id={facility_id}*"
                    )
                    logger.info(
                        f"FAQ cache invalidated (delayed): {deleted_count} keys deleted "
                        f"(facility_id={facility_id})"
                    )
                except Exception as e:
                    logger.warning(
                        f"Failed to invalidate FAQ cache (delayed): facility_id={facility_id}, "
                        f"error={str(e)}",
                        exc_info=True
                    )
            except Exception as e:
                logger.error(
                    f"Background FAQ creation failed: facility_id={facility_id}, "
                    f"plan={subscription_plan}, error={str(e)}",
                    exc_info=True
                )
```

## 5.8 認証APIエンドポイント修正

**ファイル**: `backend/app/api/v1/auth.py`

```python
"""
認証APIエンドポイント
"""

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import IntegrityError
from app.database import get_db
from app.api.deps import get_current_user
from app.schemas.auth import (
    LoginRequest, LoginResponse, LogoutResponse, UserResponse,
    PasswordChangeRequest, PasswordChangeResponse,
    FacilityRegisterRequest, FacilityRegisterResponse,  # ★修正
    VerifyEmailRequest, VerifyEmailResponse,  # ★追加
    ResendVerificationRequest, ResendVerificationResponse  # ★追加
)
from app.services.auth_service import AuthService
from app.models.user import User
from app.core.security import hash_password, verify_password

router = APIRouter(prefix="/auth", tags=["auth"])


@router.post("/login", response_model=LoginResponse)
async def login(
    login_data: LoginRequest,
    request: Request,
    db: AsyncSession = Depends(get_db)
):
    """
    ログイン
    
    - **email**: メールアドレス
    - **password**: パスワード
    
    成功時はJWTアクセストークンを返却
    
    ★注意: メールアドレス確認済みのユーザーのみログイン可能
    """
    return await AuthService.login(db, login_data, request)


@router.post("/register", response_model=FacilityRegisterResponse)  # ★レスポンスモデル変更
async def register_facility(
    request: FacilityRegisterRequest,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db)
):
    """
    施設登録
    
    - **email**: 施設管理者メールアドレス
    - **password**: パスワード（最小8文字）
    - **facility_name**: 施設名
    - **subscription_plan**: 料金プラン（デフォルト: small）
    
    ★変更点:
    - 登録後、メール確認が必要になりました
    - 確認メールを送信し、メール内のリンクをクリックするとアカウントが有効化されます
    - FAQ自動投入はバックグラウンドで実行されます
    """
    try:
        return await AuthService.register_facility(db, request, background_tasks)
    except IntegrityError as e:
        error_str = str(e.orig) if hasattr(e, 'orig') else str(e)
        if "idx_facilities_slug" in error_str:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="施設の登録に失敗しました。同じ施設名が既に登録されている可能性があります。"
            )
        elif "idx_facilities_email" in error_str or "email" in error_str.lower():
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="このメールアドレスは既に登録されています。"
            )
        else:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="施設の登録中にエラーが発生しました。"
            )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"予期しないエラーが発生しました: {str(e)}"
        )


@router.post("/verify-email", response_model=VerifyEmailResponse)  # ★追加
async def verify_email(
    request: VerifyEmailRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    メールアドレス確認
    
    - **token**: 確認トークン（メールに記載されたURL内のトークン）
    
    確認成功時はアカウントが有効化され、ログイン可能になります
    """
    return await AuthService.verify_email(db, request)


@router.post("/resend-verification", response_model=ResendVerificationResponse)  # ★追加
async def resend_verification_email(
    request: ResendVerificationRequest,
    db: AsyncSession = Depends(get_db)
):
    """
    確認メール再送信
    
    - **email**: メールアドレス
    
    確認メールを再送信します（有効期限は新たに24時間）
    """
    return await AuthService.resend_verification_email(db, request)


@router.get("/me", response_model=UserResponse)
async def get_current_user_info(
    current_user: User = Depends(get_current_user)
):
    """
    現在のユーザー情報取得
    
    JWTトークンから現在のユーザー情報を返却
    """
    return UserResponse(
        id=current_user.id,
        email=current_user.email,
        full_name=current_user.full_name,
        role=current_user.role,
        facility_id=current_user.facility_id,
        is_active=current_user.is_active,
        email_verified=current_user.email_verified  # ★追加
    )


@router.post("/logout", response_model=LogoutResponse)
async def logout(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    ログアウト
    
    JWTトークンはクライアント側で削除
    認証が必要だが、403エラーが発生した場合でもログアウト処理は成功として扱う
    """
    try:
        await AuthService.logout(db, current_user)
        return LogoutResponse(message="Logged out successfully")
    except HTTPException as e:
        if e.status_code == status.HTTP_403_FORBIDDEN:
            return LogoutResponse(message="Logged out successfully")
        raise


@router.put("/password", response_model=PasswordChangeResponse, status_code=status.HTTP_200_OK)
async def change_password(
    request: PasswordChangeRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    パスワード変更
    
    JWT認証必須。現在のユーザーのパスワードを変更します。
    
    - **current_password**: 現在のパスワード
    - **new_password**: 新しいパスワード（最小8文字）
    - **confirm_password**: 新しいパスワード（確認）
    """
    try:
        if not verify_password(request.current_password, current_user.password_hash):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Current password is incorrect"
            )
        
        if request.new_password != request.confirm_password:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="New password and confirm password do not match"
            )
        
        if len(request.new_password) < 8:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Password must be at least 8 characters long"
            )
        
        current_user.password_hash = hash_password(request.new_password)
        await db.commit()
        
        return PasswordChangeResponse(message="Password changed successfully")
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error changing password: {str(e)}"
        )
```

================================================================================
6. フロントエンド実装
================================================================================

## 6.1 Register.vue修正

**ファイル**: `frontend/src/views/admin/Register.vue`

主要な変更点：
1. 登録成功時に確認メール送信完了画面へ遷移
2. エラーメッセージ表示の改善

```vue
<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center px-4 py-12">
    <div class="w-full max-w-md">
      <!-- 登録カード -->
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-8">
        <!-- ヘッダー -->
        <div class="text-center mb-8">
          <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-2">
            YadOPERA
          </h1>
          <p class="text-gray-600 dark:text-gray-400">
            新規施設登録 / Facility Registration
          </p>
        </div>

        <!-- 登録フォーム -->
        <form @submit.prevent="handleRegister" class="space-y-6">
          <!-- 施設名 -->
          <div>
            <label for="facility_name" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              施設名 / Facility Name
            </label>
            <input
              id="facility_name"
              v-model="form.facility_name"
              type="text"
              required
              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
              placeholder="例: 東京ゲストハウス"
            />
          </div>

          <!-- メールアドレス -->
          <div>
            <label for="email" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              メールアドレス / Email
            </label>
            <input
              id="email"
              v-model="form.email"
              type="email"
              required
              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
              placeholder="admin@example.com"
            />
          </div>

          <!-- パスワード -->
          <div>
            <label for="password" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              パスワード / Password
            </label>
            <input
              id="password"
              v-model="form.password"
              type="password"
              required
              minlength="8"
              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
              placeholder="8文字以上"
            />
          </div>

          <!-- 料金プラン -->
          <div>
            <label for="subscription_plan" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              料金プラン / Subscription Plan
            </label>
            <select
              id="subscription_plan"
              v-model="form.subscription_plan"
              class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
            >
              <option value="free">Free</option>
              <option value="mini">Mini</option>
              <option value="small">Small (推奨)</option>
              <option value="standard">Standard</option>
              <option value="premium">Premium</option>
            </select>
          </div>

          <!-- エラーメッセージ -->
          <div v-if="errorMessage" class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-3">
            <p class="text-red-600 dark:text-red-400 text-sm">
              {{ errorMessage }}
            </p>
          </div>

          <!-- 登録ボタン -->
          <button
            type="submit"
            :disabled="isLoading"
            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <span v-if="isLoading" class="flex items-center">
              <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              登録中...
            </span>
            <span v-else>
              施設を登録 / Register Facility
            </span>
          </button>
        </form>

        <!-- ログインページへのリンク -->
        <div class="mt-6 text-center">
          <p class="text-sm text-gray-600 dark:text-gray-400">
            既にアカウントをお持ちですか？
            <router-link to="/admin/login" class="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400">
              ログイン / Login
            </router-link>
          </p>
        </div>

        <!-- フッター -->
        <div class="mt-6 text-center">
          <p class="text-xs text-gray-500 dark:text-gray-400">
            © 2026 YadOPERA. All rights reserved.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import axios from 'axios'

const route = useRoute()
const router = useRouter()

const isVerifying = ref(true)
const isSuccess = ref(false)
const verifiedEmail = ref('')
const errorMessage = ref('')

const verifyEmail = async () => {
  const token = route.query.token as string

  if (!token) {
    isVerifying.value = false
    errorMessage.value = '確認トークンが無効です。URLを確認してください。'
    return
  }

  try {
    const response = await axios.post(
      `${import.meta.env.VITE_API_BASE_URL}/api/v1/auth/verify-email`,
      { token }
    )

    isSuccess.value = true
    verifiedEmail.value = response.data.email
  } catch (error: any) {
    if (error.response?.data?.detail) {
      errorMessage.value = error.response.data.detail
    } else {
      errorMessage.value = '確認に失敗しました。URLが正しいか、有効期限が切れていないか確認してください。'
    }
  } finally {
    isVerifying.value = false
  }
}

const goToLogin = () => {
  router.push('/admin/login')
}

const goToRegister = () => {
  router.push('/admin/register')
}

onMounted(() => {
  verifyEmail()
})
</script>

<style scoped>
/* Component styles */
</style>
```

## 6.4 ルーティング設定

**ファイル**: `frontend/src/router/index.ts`

```typescript
import { createRouter, createWebHistory } from 'vue-router'
import type { RouteRecordRaw } from 'vue-router'

const routes: Array<RouteRecordRaw> = [
  // 既存のルート...
  
  // 管理者認証関連（★追加）
  {
    path: '/admin/register',
    name: 'Register',
    component: () => import('@/views/admin/Register.vue'),
    meta: { requiresGuest: true }
  },
  {
    path: '/admin/verify-email-pending',
    name: 'EmailVerificationPending',
    component: () => import('@/views/admin/EmailVerificationPending.vue'),
    meta: { requiresGuest: true }
  },
  {
    path: '/admin/verify-email',
    name: 'EmailVerificationSuccess',
    component: () => import('@/views/admin/EmailVerificationSuccess.vue'),
    meta: { requiresGuest: true }
  },
  {
    path: '/admin/login',
    name: 'Login',
    component: () => import('@/views/admin/Login.vue'),
    meta: { requiresGuest: true }
  },
  
  // その他の既存ルート...
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router
```

## 6.5 Login.vue修正（エラーメッセージ改善）

**ファイル**: `frontend/src/views/admin/Login.vue`

ログイン時にメール未確認エラーを適切に表示するように修正：

```vue
<!-- 既存のコードは維持、handleLogin関数のみ修正 -->

<script setup lang="ts">
// 既存のインポート...

const handleLogin = async () => {
  try {
    isLoading.value = true
    errorMessage.value = ''

    await login({
      email: form.email,
      password: form.password
    })
  } catch (error: any) {
    // ★メール未確認エラーの場合
    if (error.response?.status === 403 && 
        error.response?.data?.detail?.includes('Email address not verified')) {
      errorMessage.value = 'メールアドレスが確認されていません。登録時に送信された確認メールをご確認ください。'
    } else if (error.response?.data?.detail) {
      errorMessage.value = error.response.data.detail
    } else {
      errorMessage.value = 'ログインに失敗しました。メールアドレスとパスワードを確認してください。'
    }
  } finally {
    isLoading.value = false
  }
}
</script>
```

================================================================================
7. Docker環境での動作確認手順
================================================================================

## 7.1 環境変数設定

```bash
# backend/.env を編集
nano backend/.env

# 以下を追加
BREVO_API_KEY=xkeysib-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
BREVO_SENDER_EMAIL=noreply@yadopera.com
BREVO_SENDER_NAME=YadOPERA
FRONTEND_URL=http://localhost:5173
```

## 7.2 マイグレーション実行

```bash
# Docker環境起動
docker-compose up -d

# マイグレーション実行
docker-compose exec backend alembic upgrade head

# 確認
docker-compose exec backend alembic current

# 期待される出力: "013 (head)"
```

## 7.3 依存関係インストール

```bash
# バックエンド（Brevoライブラリ）
docker-compose exec backend pip install sib-api-v3-sdk==7.6.0

# または、コンテナ再ビルド
docker-compose down
docker-compose build backend
docker-compose up -d
```

## 7.4 動作確認テスト

### ステップ1: 新規登録

1. ブラウザで `http://localhost:5173/admin/register` にアクセス

2. 以下の情報を入力：
   - 施設名: テスト施設
   - メールアドレス: test@example.com（自分のメールアドレス推奨）
   - パスワード: testpass123
   - 料金プラン: Small

3. 「施設を登録」ボタンをクリック

4. 「確認メールを送信しました」画面が表示されることを確認

5. データベース確認：
   ```bash
   docker-compose exec postgres psql -U yadopera_user -d yadopera -c "SELECT id, email, is_active, email_verified, verification_token FROM users WHERE email='test@example.com';"
   ```
   
   期待される結果：
   - is_active: false
   - email_verified: false
   - verification_token: UUID形式の文字列

### ステップ2: メール確認

1. 登録したメールアドレスの受信トレイを確認

2. 「【YadOPERA】メールアドレス確認のお願い」というメールを開く

3. 「メールアドレスを確認する」ボタンをクリック

4. 「メールアドレス確認完了！」画面が表示されることを確認

5. データベース確認：
   ```bash
   docker-compose exec postgres psql -U yadopera_user -d yadopera -c "SELECT id, email, is_active, email_verified, verification_token FROM users WHERE email='test@example.com';"
   ```
   
   期待される結果：
   - is_active: true
   - email_verified: true
   - verification_token: NULL

### ステップ3: ログイン

1. 「ログインページへ」ボタンをクリック

2. 以下の情報を入力：
   - メールアドレス: test@example.com
   - パスワード: testpass123

3. 「ログイン」ボタンをクリック

4. ダッシュボードが表示されることを確認

### ステップ4: メール再送信テスト

1. 別のメールアドレスで新規登録

2. 「確認メールを送信しました」画面で「確認メールを再送信」ボタンをクリック

3. 再送信成功メッセージが表示されることを確認

4. 60秒間のクールダウンタイマーが動作することを確認

5. メール受信確認

### ステップ5: エラーケーステスト

**無効なトークン**
1. ブラウザで以下のURLにアクセス：
   `http://localhost:5173/admin/verify-email?token=invalid-token-12345`

2. 「確認に失敗しました」画面が表示されることを確認

**トークン有効期限切れ**
1. データベースで手動でトークン有効期限を過去に設定：
   ```bash
   docker-compose exec postgres psql -U yadopera_user -d yadopera -c "UPDATE users SET verification_token_expires = NOW() - INTERVAL '1 day' WHERE email='test2@example.com';"
   ```

2. 確認URLにアクセス

3. 「Verification token has expired」エラーが表示されることを確認

**メール未確認でログイン試行**
1. メール確認前の状態で `/admin/login` にアクセス

2. メールアドレスとパスワードを入力

3. 「メールアドレスが確認されていません」エラーが表示されることを確認

## 7.5 ログ確認

```bash
# バックエンドログ確認
docker-compose logs -f backend

# 確認ポイント:
# - "Verification email sent successfully" メッセージ
# - "Email verified successfully" メッセージ
# - Brevo API エラーがないこと
```

================================================================================
8. ステージング環境デプロイ手順
================================================================================

## 8.1 環境変数設定（Render.com）

1. Render.comダッシュボードにログイン

2. ステージング環境のバックエンドサービスを選択

3. 「Environment」タブを選択

4. 以下の環境変数を追加：

```
BREVO_API_KEY=xkeysib-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
BREVO_SENDER_EMAIL=noreply@yadopera.com
BREVO_SENDER_NAME=YadOPERA
FRONTEND_URL=https://yadopera-frontend-staging.onrender.com
```

5. 「Save Changes」をクリック

## 8.2 マイグレーション実行

```bash
# Render.com ShellまたはSSHで実行
alembic upgrade head

# 確認
alembic current
```

## 8.3 デプロイ

```bash
# developブランチにコミット・プッシュ
git add .
git commit -m "feat: メールアドレス確認機能実装"
git push origin develop

# Render.comが自動デプロイ開始
# デプロイ状況を確認
```

## 8.4 ステージング環境での動作確認

1. `https://yadopera-frontend-staging.onrender.com/admin/register` にアクセス

2. Docker環境と同様の動作確認テストを実施

3. メール送信確認（実際のメールアドレスを使用）

4. Brevoダッシュボードで送信履歴を確認
   - URL: https://app.brevo.com/
   - 「Transactional」→「Email」→「Statistics」

## 8.5 トラブルシューティング（ステージング環境）

**メールが届かない場合**

1. Brevoダッシュボードで送信ステータス確認

2. Render.comログ確認：
   ```
   Render.com Dashboard → Service → Logs
   ```

3. 送信元メールアドレス（noreply@yadopera.com）が認証済みか確認

4. DNS設定（SPF, DKIM）が正しいか確認：
   ```bash
   dig TXT yadopera.com +short
   dig TXT mail._domainkey.yadopera.com +short
   ```

================================================================================
9. 本番環境デプロイ手順
================================================================================

## 9.1 本番環境準備

### 9.1.1 Brevo本番環境設定

1. Brevoで本番用API Key作成（ステージング用とは別）

2. 送信元メールアドレス確認（既にステージングで設定済み）

### 9.1.2 環境変数設定（本番環境）

**Render.com（本番バックエンド）**

```
BREVO_API_KEY=xkeysib-[本番用API Key]
BREVO_SENDER_EMAIL=noreply@yadopera.com
BREVO_SENDER_NAME=YadOPERA
FRONTEND_URL=https://yadopera.com
ENVIRONMENT=production
DEBUG=False
```

## 9.2 マイグレーション実行

```bash
# 本番環境でマイグレーション実行
# Render.com ShellまたはSSHで実行
alembic upgrade head
```

## 9.3 デプロイ

```bash
# mainブランチにマージ
git checkout main
git merge develop
git push origin main

# Render.comが自動デプロイ開始
```

## 9.4 本番環境での動作確認

1. `https://yadopera.com/admin/register` にアクセス

2. 実際のユーザー情報で登録テスト

3. メール受信確認

4. ログイン確認

5. Brevoダッシュボードで送信履歴確認

## 9.5 モニタリング

### 9.5.1 メール送信状況

- Brevoダッシュボード → 「Transactional」→「Statistics」
- 送信成功率を確認（目標: 95%以上）

### 9.5.2 登録成功率

- データベースクエリで確認：
  ```sql
  SELECT 
    COUNT(*) AS total_users,
    SUM(CASE WHEN email_verified = true THEN 1 ELSE 0 END) AS verified_users,
    ROUND(SUM(CASE WHEN email_verified = true THEN 1 ELSE 0 END)::DECIMAL / COUNT(*) * 100, 2) AS verification_rate
  FROM users
  WHERE created_at >= NOW() - INTERVAL '7 days';
  ```

### 9.5.3 エラーログ監視

- Render.com Logs
- Brevo送信エラー
- トークン有効期限切れ

================================================================================
10. トラブルシューティング
================================================================================

## 10.1 メールが届かない

**症状**: 登録後、確認メールが届かない

**確認手順**:

1. **Brevoダッシュボード確認**
   - https://app.brevo.com/
   - 「Transactional」→「Email」→「Statistics」
   - 送信ステータスを確認（Sent / Failed）

2. **バックエンドログ確認**
   ```bash
   docker-compose logs backend | grep "Verification email"
   ```
   
   期待されるログ:
   ```
   INFO: Verification email sent successfully: to=test@example.com, message_id=xxx
   ```
   
   エラーの場合:
   ```
   ERROR: Brevo API error: to=test@example.com, status=xxx, reason=xxx
   ```

3. **環境変数確認**
   ```bash
   docker-compose exec backend env | grep BREVO
   ```
   
   期待される出力:
   ```
   BREVO_API_KEY=xkeysib-xxx
   BREVO_SENDER_EMAIL=noreply@yadopera.com
   BREVO_SENDER_NAME=YadOPERA
   ```

4. **DNS設定確認**
   ```bash
   dig TXT yadopera.com +short
   # "v=spf1 include:spf.brevo.com ~all" が含まれているか
   
   dig TXT mail._domainkey.yadopera.com +short
   # DKIMレコードが設定されているか
   ```

5. **迷惑メールフォルダ確認**
   - GmailやOutlookの迷惑メールフォルダを確認

**解決方法**:

- Brevo API Keyが正しいか確認
- 送信元メールアドレスがBrevoで認証済みか確認
- DNS設定（SPF, DKIM）が正しいか確認
- Brevo無料プランの月間送信上限（300通）を超えていないか確認

## 10.2 トークンが無効

**症状**: 「Invalid verification token」エラー

**原因**:
- URLが不完全（トークンが欠落）
- トークンが既に使用済み
- データベースのトークンが削除された

**確認手順**:

1. **URLのトークン確認**
   ```
   正しいURL: https://yadopera.com/admin/verify-email?token=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
   ```

2. **データベース確認**
   ```bash
   docker-compose exec postgres psql -U yadopera_user -d yadopera -c "SELECT email, verification_token, email_verified FROM users WHERE verification_token IS NOT NULL;"
   ```

**解決方法**:
- メール再送信機能を使用
- 新しいトークンが生成される

## 10.3 トークン有効期限切れ

**症状**: 「Verification token has expired」エラー

**原因**:
- 24時間以上経過している

**解決方法**:
1. 「確認メールを再送信」ボタンをクリック
2. 新しいトークン（有効期限24時間）が発行される

## 10.4 ログインできない（メール未確認）

**症状**: 「Email address not verified」エラー

**原因**:
- メールアドレス確認が完了していない

**確認手順**:

```bash
docker-compose exec postgres psql -U yadopera_user -d yadopera -c "SELECT email, email_verified, is_active FROM users WHERE email='xxx@example.com';"
```

**解決方法**:
1. 確認メールを再送信
2. メール内のリンクをクリック
3. 再度ログイン

## 10.5 FAQ自動投入が完了しない

**症状**: ログイン後、FAQが0件

**原因**:
- バックグラウンド処理が失敗している

**確認手順**:

```bash
docker-compose logs backend | grep "Background FAQ creation"
```

期待されるログ:
```
INFO: Background FAQ creation completed: facility_id=xxx, plan=small, count=20
```

**解決方法**:
- バックエンドログを確認
- FAQ手動登録で対応

## 10.6 Brevo API制限

**症状**: メール送信時に429エラー

**原因**:
- Brevo無料プランの制限（月300通）を超えた

**確認手順**:
- Brevoダッシュボードで送信数を確認

**解決方法**:
- 有料プラン（Lite: $25/月、20,000通）へアップグレード
- 翌月まで待つ

================================================================================
以上、メールアドレス確認機能実装計画書
================================================================================gray-500 dark:text-gray-400">
            © 2026 YadOPERA. All rights reserved.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, reactive } from 'vue'
import { useRouter } from 'vue-router'
import axios from 'axios'

const router = useRouter()

const form = reactive({
  email: '',
  password: '',
  facility_name: '',
  subscription_plan: 'small'
})

const isLoading = ref(false)
const errorMessage = ref('')

const handleRegister = async () => {
  try {
    isLoading.value = true
    errorMessage.value = ''

    // ★API呼び出し（レスポンス形式変更）
    const response = await axios.post(`${import.meta.env.VITE_API_BASE_URL}/api/v1/auth/register`, {
      email: form.email,
      password: form.password,
      facility_name: form.facility_name,
      subscription_plan: form.subscription_plan
    })

    // ★成功時は確認メール送信完了画面へ遷移（queryパラメータでメールアドレスを渡す）
    router.push({
      name: 'EmailVerificationPending',
      query: {
        email: form.email,
        facility_name: form.facility_name
      }
    })
  } catch (error: any) {
    if (error.response?.data?.detail) {
      errorMessage.value = error.response.data.detail
    } else {
      errorMessage.value = '登録に失敗しました。入力内容を確認してください。'
    }
  } finally {
    isLoading.value = false
  }
}
</script>

<style scoped>
/* Component styles */
</style>
```

## 6.2 メール確認待ち画面作成

**ファイル**: `frontend/src/views/admin/EmailVerificationPending.vue`（新規作成）

```vue
<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center px-4 py-12">
    <div class="w-full max-w-md">
      <!-- 確認待ちカード -->
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-8">
        <!-- アイコン -->
        <div class="flex justify-center mb-6">
          <div class="w-16 h-16 bg-blue-100 dark:bg-blue-900/30 rounded-full flex items-center justify-center">
            <svg class="w-8 h-8 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
            </svg>
          </div>
        </div>

        <!-- ヘッダー -->
        <div class="text-center mb-6">
          <h1 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">
            確認メールを送信しました
          </h1>
          <p class="text-gray-600 dark:text-gray-400 text-sm">
            Email Verification Sent
          </p>
        </div>

        <!-- メッセージ -->
        <div class="space-y-4 mb-6">
          <p class="text-gray-700 dark:text-gray-300">
            {{ facilityName }} 様
          </p>
          <p class="text-gray-700 dark:text-gray-300">
            以下のメールアドレスに確認メールを送信しました：
          </p>
          <p class="text-blue-600 dark:text-blue-400 font-semibold text-center bg-blue-50 dark:bg-blue-900/20 py-2 px-4 rounded-md">
            {{ email }}
          </p>
          <p class="text-gray-700 dark:text-gray-300">
            メール内のリンクをクリックして、アカウントを有効化してください。
          </p>
          <div class="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-md p-3">
            <p class="text-yellow-800 dark:text-yellow-200 text-sm">
              <strong>注意:</strong> 確認リンクは24時間後に無効になります。
            </p>
          </div>
        </div>

        <!-- 再送信ボタン -->
        <div class="space-y-4">
          <button
            @click="resendEmail"
            :disabled="isResending || cooldownRemaining > 0"
            class="w-full flex justify-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <span v-if="isResending" class="flex items-center">
              <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-gray-700 dark:text-gray-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              送信中...
            </span>
            <span v-else-if="cooldownRemaining > 0">
              再送信まで {{ cooldownRemaining }}秒
            </span>
            <span v-else>
              確認メールを再送信
            </span>
          </button>

          <!-- 成功メッセージ -->
          <div v-if="resendSuccess" class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-md p-3">
            <p class="text-green-600 dark:text-green-400 text-sm">
              確認メールを再送信しました。メールをご確認ください。
            </p>
          </div>

          <!-- エラーメッセージ -->
          <div v-if="resendError" class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-3">
            <p class="text-red-600 dark:text-red-400 text-sm">
              {{ resendError }}
            </p>
          </div>
        </div>

        <!-- ログインページへのリンク -->
        <div class="mt-6 text-center">
          <p class="text-sm text-gray-600 dark:text-gray-400">
            既に確認済みですか？
            <router-link to="/admin/login" class="font-medium text-blue-600 hover:text-blue-500 dark:text-blue-400">
              ログイン / Login
            </router-link>
          </p>
        </div>

        <!-- フッター -->
        <div class="mt-6 text-center">
          <p class="text-xs text-gray-500 dark:text-gray-400">
            © 2026 YadOPERA. All rights reserved.
          </p>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue'
import { useRoute } from 'vue-router'
import axios from 'axios'

const route = useRoute()

const email = ref(route.query.email as string || '')
const facilityName = ref(route.query.facility_name as string || '')
const isResending = ref(false)
const resendSuccess = ref(false)
const resendError = ref('')
const cooldownRemaining = ref(0)
let cooldownTimer: number | null = null

const resendEmail = async () => {
  try {
    isResending.value = true
    resendSuccess.value = false
    resendError.value = ''

    await axios.post(`${import.meta.env.VITE_API_BASE_URL}/api/v1/auth/resend-verification`, {
      email: email.value
    })

    resendSuccess.value = true
    
    // クールダウン開始（60秒）
    cooldownRemaining.value = 60
    cooldownTimer = window.setInterval(() => {
      cooldownRemaining.value--
      if (cooldownRemaining.value <= 0 && cooldownTimer) {
        clearInterval(cooldownTimer)
        cooldownTimer = null
      }
    }, 1000)
  } catch (error: any) {
    if (error.response?.data?.detail) {
      resendError.value = error.response.data.detail
    } else {
      resendError.value = '再送信に失敗しました。しばらく経ってから再度お試しください。'
    }
  } finally {
    isResending.value = false
  }
}

onMounted(() => {
  // メールアドレスがない場合は登録ページへリダイレクト
  if (!email.value) {
    window.location.href = '/admin/register'
  }
})

onUnmounted(() => {
  if (cooldownTimer) {
    clearInterval(cooldownTimer)
  }
})
</script>

<style scoped>
/* Component styles */
</style>
```

## 6.3 メール確認完了画面作成

**ファイル**: `frontend/src/views/admin/EmailVerificationSuccess.vue`（新規作成）

```vue
<template>
  <div class="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center px-4 py-12">
    <div class="w-full max-w-md">
      <!-- 確認完了カード -->
      <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 p-8">
        <!-- ローディング状態 -->
        <div v-if="isVerifying" class="text-center">
          <div class="flex justify-center mb-6">
            <svg class="animate-spin h-12 w-12 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          </div>
          <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">
            確認中...
          </h2>
          <p class="text-gray-600 dark:text-gray-400">
            メールアドレスを確認しています
          </p>
        </div>

        <!-- 成功状態 -->
        <div v-else-if="isSuccess" class="text-center">
          <!-- アイコン -->
          <div class="flex justify-center mb-6">
            <div class="w-16 h-16 bg-green-100 dark:bg-green-900/30 rounded-full flex items-center justify-center">
              <svg class="w-8 h-8 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7" />
              </svg>
            </div>
          </div>

          <!-- ヘッダー -->
          <div class="mb-6">
            <h1 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">
              メールアドレス確認完了！
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-sm">
              Email Verification Successful
            </p>
          </div>

          <!-- メッセージ -->
          <div class="space-y-4 mb-6">
            <div class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-md p-4">
              <p class="text-green-800 dark:text-green-200">
                アカウントの有効化が完了しました。<br>
                ログインしてYadOPERAをご利用いただけます。
              </p>
            </div>
            <p class="text-gray-700 dark:text-gray-300">
              確認済みメールアドレス：
            </p>
            <p class="text-blue-600 dark:text-blue-400 font-semibold text-center bg-blue-50 dark:bg-blue-900/20 py-2 px-4 rounded-md">
              {{ verifiedEmail }}
            </p>
          </div>

          <!-- ログインボタン -->
          <button
            @click="goToLogin"
            class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
          >
            ログインページへ / Go to Login
          </button>
        </div>

        <!-- エラー状態 -->
        <div v-else class="text-center">
          <!-- アイコン -->
          <div class="flex justify-center mb-6">
            <div class="w-16 h-16 bg-red-100 dark:bg-red-900/30 rounded-full flex items-center justify-center">
              <svg class="w-8 h-8 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </div>
          </div>

          <!-- ヘッダー -->
          <div class="mb-6">
            <h1 class="text-2xl font-bold text-gray-900 dark:text-white mb-2">
              確認に失敗しました
            </h1>
            <p class="text-gray-600 dark:text-gray-400 text-sm">
              Email Verification Failed
            </p>
          </div>

          <!-- エラーメッセージ -->
          <div class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-md p-4 mb-6">
            <p class="text-red-600 dark:text-red-400">
              {{ errorMessage }}
            </p>
          </div>

          <!-- アクション -->
          <div class="space-y-3">
            <button
              @click="goToRegister"
              class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              新規登録ページへ
            </button>
            <button
              @click="goToLogin"
              class="w-full flex justify-center py-2 px-4 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm text-sm font-medium text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              ログインページへ
            </button>
          </div>
        </div>

        <!-- フッター -->
        <div class="mt-6 text-center">
          <p class="text-xs text-
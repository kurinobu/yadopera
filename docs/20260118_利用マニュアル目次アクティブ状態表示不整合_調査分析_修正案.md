# 利用マニュアル目次アクティブ状態表示不整合 調査分析・修正案

**作成日時**: 2026年01月18日  
**対象課題**: 目次のタイトルをタップした際のアクティブ状態表示の不整合  
**優先度**: 中（UX改善のため重要）  
**所要時間**: 約30分

---

## 1. 問題の詳細

### 1.1 問題の症状

**現在の動作**:
- 目次1をタップ → 目次1全体がブルーになる ✅
- 目次2をタップ → 目次2全体がブルーになり、目次1のブルーは解除される ✅
- 目次3をタップ → 目次2のブルーが解除されず、そのまま保持される ❌

**期待される動作**:
- 目次をタップした際、常に1つのセクションのみがアクティブ（ブルー）になる
- 前のセクションのアクティブ状態は必ず解除される

### 1.2 影響範囲

**影響を受けるファイル**:
- `frontend/src/components/admin/ManualContent.vue`（`IntersectionObserver`のロジック）

**影響を受けないファイル**:
- `frontend/src/views/admin/Manual.vue`（`handleSectionChange`は正常に動作）
- `frontend/src/components/admin/ManualToc.vue`（`activeSection`プロップを正しく受け取っている）

---

## 2. 根本原因の分析

### 2.1 現在の実装

**`ManualContent.vue`の`IntersectionObserver`実装**（112-126行目）:
```typescript
observer = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
        const sectionId = entry.target.id
        // 親セクションIDを取得
        const section = props.sections.find((s) => {
          return s.id === sectionId || s.subsections.some((sub) => sub.id === sectionId)
        })
        if (section) {
          emit('section-change', section.id)
        }
      }
    })
  },
  {
    rootMargin: '-20% 0px -50% 0px',
    threshold: [0, 0.5, 1]
  }
)
```

### 2.2 問題の根本原因

**原因1: 複数のエントリが同時に`isIntersecting`になる**
- `entries.forEach`で複数のエントリを処理している
- スクロール位置によって、複数のセクション/サブセクションが同時に`isIntersecting && intersectionRatio > 0.5`の条件を満たす場合がある
- その場合、`forEach`で最後に処理されたセクションIDが`activeSection`に設定される

**原因2: 前のセクションがまだ`isIntersecting`の状態で残る**
- スクロール位置によっては、前のセクションがまだビューポート内に残っている
- `rootMargin: '-20% 0px -50% 0px'`の設定により、複数のセクションが同時に監視対象になる可能性がある
- その結果、前のセクションの`isIntersecting`状態が解除されず、`section-change`イベントが発火し続ける

**原因3: 最も上に表示されているセクションを選択していない**
- 現在の実装では、`forEach`で最後に処理されたセクションIDが選択される
- しかし、実際には最も上に表示されているセクション（`entry.boundingClientRect.top`が最小）を選択すべき

### 2.3 問題の再現条件

1. 目次1をクリック → 目次1にスクロール → 目次1がアクティブになる ✅
2. 目次2をクリック → 目次2にスクロール → 目次2がアクティブになり、目次1が非アクティブになる ✅
3. 目次3をクリック → 目次3にスクロール → 目次2がまだビューポート内に残っている場合、目次2の`isIntersecting`状態が解除されず、`section-change`イベントが発火し続ける ❌

---

## 3. 修正方針

### 3.1 修正アプローチ

**推奨方式: 最も上に表示されているセクションを選択**

1. **`IntersectionObserver`のコールバックを修正**:
   - 複数のエントリが`isIntersecting`の条件を満たす場合、最も上に表示されているセクション（`entry.boundingClientRect.top`が最小）を選択
   - または、`intersectionRatio`が最大のものを選択

2. **セクション選択ロジックの改善**:
   - `entries.forEach`の代わりに、条件を満たすエントリをフィルタリング
   - その中から、最も上に表示されているセクションを選択
   - 選択されたセクションのみ`section-change`イベントを発火

### 3.2 修正後のロジック

```typescript
observer = new IntersectionObserver(
  (entries) => {
    // 条件を満たすエントリをフィルタリング
    const intersectingEntries = entries.filter(
      (entry) => entry.isIntersecting && entry.intersectionRatio > 0.5
    )

    if (intersectingEntries.length === 0) {
      return
    }

    // 最も上に表示されているセクションを選択（boundingClientRect.topが最小）
    const topEntry = intersectingEntries.reduce((prev, current) => {
      const prevTop = prev.boundingClientRect.top
      const currentTop = current.boundingClientRect.top
      return currentTop < prevTop ? current : prev
    })

    const sectionId = topEntry.target.id
    // 親セクションIDを取得
    const section = props.sections.find((s) => {
      return s.id === sectionId || s.subsections.some((sub) => sub.id === sectionId)
    })

    if (section) {
      emit('section-change', section.id)
    }
  },
  {
    rootMargin: '-20% 0px -50% 0px',
    threshold: [0, 0.5, 1]
  }
)
```

---

## 4. 修正ステップ計画

### ステップ1: バックアップ作成（5分）

```bash
cp frontend/src/components/admin/ManualContent.vue frontend/src/components/admin/ManualContent.vue.bak_$(date +%Y%m%d_%H%M%S)
```

### ステップ2: `IntersectionObserver`のコールバックを修正（15分）

**修正内容**:
- `entries.forEach`の代わりに、条件を満たすエントリをフィルタリング
- 最も上に表示されているセクション（`boundingClientRect.top`が最小）を選択
- 選択されたセクションのみ`section-change`イベントを発火

### ステップ3: 構文チェック（5分）

```bash
cd frontend
npm run type-check  # または vue-tsc --noEmit
npm run lint
```

### ステップ4: ブラウザテスト（15分）

**テスト項目**:
1. **アクティブ状態の切り替え確認**:
   - 目次1をクリック → 目次1がアクティブになることを確認
   - 目次2をクリック → 目次2がアクティブになり、目次1が非アクティブになることを確認
   - 目次3をクリック → 目次3がアクティブになり、目次2が非アクティブになることを確認

2. **スクロール時の動作確認**:
   - 手動でスクロールした際も、最も上に表示されているセクションがアクティブになることを確認

3. **複数セクションが同時に表示される場合の確認**:
   - セクションの境界付近でスクロールした際、正しいセクションがアクティブになることを確認

**所要時間**: 約40分（0.5時間）

---

## 5. 他の機能やUIへの影響調査

### 5.1 影響を受ける可能性のある機能

**調査結果**: **影響なし**

**理由**:
1. **`Manual.vue`への影響**: なし
   - `handleSectionChange`関数は変更不要
   - `activeSection`の更新ロジックは変更不要

2. **`ManualToc.vue`への影響**: なし
   - `activeSection`プロップを正しく受け取っている
   - 表示ロジックは変更不要

3. **他のコンポーネントへの影響**: なし
   - `ManualContent.vue`の`IntersectionObserver`ロジックのみを修正
   - 他のコンポーネントから直接参照されていない

### 5.2 競合・干渉の可能性

**調査結果**: **競合・干渉なし**

**理由**:
1. **イベント発火の改善**:
   - `section-change`イベントの発火タイミングを改善するだけ
   - イベントの内容や形式は変更しない

2. **状態管理の独立性**:
   - `activeSection`の更新ロジックは変更不要
   - `Manual.vue`の`handleSectionChange`関数は変更不要

---

## 6. 大原則の遵守確認

### 6.1 大原則との整合性

1. **根本解決 > 暫定解決**: ✅
   - 問題の根本原因（複数のエントリが同時に`isIntersecting`になる）を解決
   - 一時的な回避策ではなく、根本的な修正を実施

2. **シンプル構造 > 複雑構造**: ✅
   - `reduce`を使用して最も上に表示されているセクションを選択
   - 過度に複雑な実装を避けている

3. **統一・同一化 > 特殊独自**: ✅
   - 既存の`IntersectionObserver`パターンを活用
   - 標準的な実装方法を使用

4. **具体的 > 一般**: ✅
   - 具体的な実装方法を明確に記載
   - コード例を提供している

5. **拙速 < 安全確実**: ✅
   - テストを省略せず、十分な検証を行う
   - ブラウザテスト、スクロール動作テストを実施

6. **Docker環境必須**: ✅
   - すべての修正・テストはDocker環境で実行する

---

## 7. 修正案の詳細

### 7.1 修正前のコード

```typescript
observer = new IntersectionObserver(
  (entries) => {
    entries.forEach((entry) => {
      if (entry.isIntersecting && entry.intersectionRatio > 0.5) {
        const sectionId = entry.target.id
        // 親セクションIDを取得
        const section = props.sections.find((s) => {
          return s.id === sectionId || s.subsections.some((sub) => sub.id === sectionId)
        })
        if (section) {
          emit('section-change', section.id)
        }
      }
    })
  },
  {
    rootMargin: '-20% 0px -50% 0px',
    threshold: [0, 0.5, 1]
  }
)
```

### 7.2 修正後のコード

```typescript
observer = new IntersectionObserver(
  (entries) => {
    // 条件を満たすエントリをフィルタリング
    const intersectingEntries = entries.filter(
      (entry) => entry.isIntersecting && entry.intersectionRatio > 0.5
    )

    if (intersectingEntries.length === 0) {
      return
    }

    // 最も上に表示されているセクションを選択（boundingClientRect.topが最小）
    const topEntry = intersectingEntries.reduce((prev, current) => {
      const prevTop = prev.boundingClientRect.top
      const currentTop = current.boundingClientRect.top
      return currentTop < prevTop ? current : prev
    })

    const sectionId = topEntry.target.id
    // 親セクションIDを取得
    const section = props.sections.find((s) => {
      return s.id === sectionId || s.subsections.some((sub) => sub.id === sectionId)
    })

    if (section) {
      emit('section-change', section.id)
    }
  },
  {
    rootMargin: '-20% 0px -50% 0px',
    threshold: [0, 0.5, 1]
  }
)
```

### 7.3 修正のポイント

1. **フィルタリング**: 条件を満たすエントリを先にフィルタリング
2. **選択ロジック**: `reduce`を使用して、最も上に表示されているセクション（`boundingClientRect.top`が最小）を選択
3. **イベント発火**: 選択されたセクションのみ`section-change`イベントを発火

---

## 8. 期待される効果

### 8.1 UX改善

1. **統一感のある表示**:
   - 常に1つのセクションのみがアクティブ（ブルー）になる
   - 前のセクションのアクティブ状態が必ず解除される

2. **操作性の向上**:
   - 目次をクリックした際、期待通りのセクションがアクティブになる
   - スクロール時も、最も上に表示されているセクションが正しくアクティブになる

3. **視覚的フィードバックの改善**:
   - 現在表示中のセクションが明確に分かる
   - アクティブ状態の切り替えがスムーズになる

---

## 9. まとめ

### 9.1 修正内容の要約

**修正方針**:
- `IntersectionObserver`のコールバックを修正
- 複数のエントリが`isIntersecting`の条件を満たす場合、最も上に表示されているセクションを選択

**修正ファイル**:
- `frontend/src/components/admin/ManualContent.vue`

**所要時間**: 約40分（0.5時間）

### 9.2 修正の優先度

**優先度**: 中（UX改善のため重要）

**理由**:
- 目次の操作性が向上する
- ユーザー体験が改善される
- 視覚的な統一感が保たれる

---

**Document Version**: v1.0  
**Author**: Auto (AI Assistant)  
**Last Updated**: 2026年01月18日  
**Status**: ✅ **調査分析完了・修正案提示完了（修正は指示があるまで実施しない）**


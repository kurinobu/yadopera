# Phase 1・Phase 2: セッション有効期限延長問題 防止策1実装 完全調査分析・修正案

**作成日時**: 2025年12月22日  
**実施者**: AI Assistant  
**対象**: セッション有効期限延長問題の防止策1（`started_at`ベースの固定有効期限）の実装  
**状態**: ✅ **完全調査分析完了、修正案提示完了**

---

## 1. 問題の概要

### 1.1 問題の詳細

**問題**: ゲストが24時間以内に再アクセスすると、`last_activity_at`が更新され、実質的にセッション有効期限が延長される可能性がある

**シナリオ**:
1. ゲストがQRコードを読み取り、セッション開始（`started_at`: 2025-12-21 10:00:00）
2. 23時間後に再アクセス（`last_activity_at`: 2025-12-22 09:00:00に更新）
3. 設計書の`is_session_valid()`が実装されていた場合、セッションが延長される
4. チェックアウト後もアクセス可能になる

**期待される動作**:
- セッション開始時刻（`started_at`）から24時間の固定有効期限
- 再アクセスによる延長を防止
- 24時間経過後はセッションを無効化

---

## 2. 完全調査分析

### 2.1 現在の実装構造

#### 2.1.1 `Conversation`モデル

**ファイル**: `backend/app/models/conversation.py`

**現在の実装**:
```python:12:36:backend/app/models/conversation.py
class Conversation(Base):
    """
    会話セッションモデル
    """
    __tablename__ = "conversations"

    id = Column(Integer, primary_key=True, index=True)
    facility_id = Column(Integer, ForeignKey("facilities.id", ondelete="CASCADE"), nullable=False, index=True)
    session_id = Column(String(100), unique=True, nullable=False, index=True)  # Cookie保存用（UUID文字列）
    guest_language = Column(String(10), default="en")
    location = Column(String(50))  # 'entrance', 'room', 'kitchen', 'lounge'
    user_agent = Column(Text)
    ip_address = Column(INET)
    started_at = Column(DateTime(timezone=True), server_default=func.now())
    last_activity_at = Column(DateTime(timezone=True), server_default=func.now(), index=True)  # 24時間判定用
    ended_at = Column(DateTime(timezone=True))
    is_escalated = Column(Boolean, default=False, index=True)
    total_messages = Column(Integer, default=0)
    auto_resolved = Column(Boolean, default=False)
```

**重要な確認事項**:
- ✅ `started_at`フィールドが存在する
- ✅ `last_activity_at`フィールドが存在する
- ✅ `ended_at`フィールドが存在する（セッション終了時に使用可能）
- ❌ `is_active`フィールドが存在しない（設計書には記載されているが、実際のモデルには存在しない）

#### 2.1.2 `ChatService`の実装

**ファイル**: `backend/app/services/chat_service.py`

**現在の実装**:
```python:212:272:backend/app/services/chat_service.py
async def _get_or_create_conversation(
    self,
    facility_id: int,
    session_id: Optional[str],
    language: str,
    location: Optional[str] = None,
    user_agent: Optional[str] = None,
    ip_address: Optional[str] = None
) -> Conversation:
    """
    会話の取得または新規作成
    """
    # セッションIDが指定されていない場合は新規生成
    if not session_id:
        session_id = str(uuid.uuid4())
    
    # 既存の会話を検索
    result = await self.db.execute(
        select(Conversation).where(
            Conversation.facility_id == facility_id,
            Conversation.session_id == session_id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if conversation:
        # 既存の会話を更新
        conversation.last_activity_at = datetime.utcnow()  # ← 問題: ここで更新される
        if location:
            conversation.location = location
        logger.debug(f"Existing conversation found: {conversation.id}")
    else:
        # 新規会話を作成
        conversation = Conversation(
            facility_id=facility_id,
            session_id=session_id,
            guest_language=language,
            location=location,
            user_agent=user_agent,
            ip_address=ip_address,
            started_at=datetime.utcnow(),
            last_activity_at=datetime.utcnow()
        )
        self.db.add(conversation)
        await self.db.flush()
        logger.info(f"New conversation created: {conversation.id}, session_id={session_id}")
    
    await self.db.commit()
    await self.db.refresh(conversation)
    return conversation
```

**問題点**:
- 既存会話を取得する際に、`is_session_valid()`を呼び出していない
- `last_activity_at`を無条件に更新している（250行目）
- セッション有効期限の判定が行われていない

#### 2.1.3 `is_session_valid()`関数の実装状況

**設計書の記載**: `docs/Architecture/やどぺら_v0.3_アーキテクチャ設計書.md`（4426-4480行目）

**実際のコードベース**: ❌ **実装されていない**

**設計書の実装**:
```python
async def is_session_valid(
    session_id: str, 
    db: AsyncSession
) -> bool:
    """
    セッションが有効かチェック（v0.2）
    - Redisキャッシュ確認（高速化）
    - データベース確認
    - 24時間以内のアクティビティ確認
    """
    # 1. Redisキャッシュ確認（v0.2追加）
    cache_key = f"session:{session_id}"
    cached = await redis_client.get(cache_key)
    if cached:
        return True
    
    # 2. データベース確認
    conversation = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id,
            Conversation.is_active == True  # ← 問題: is_activeフィールドが存在しない
        )
    )
    conversation = conversation.scalar_one_or_none()
    
    if conversation is None:
        return False
    
    # 3. 24時間以内のアクティビティ確認
    now = datetime.utcnow()
    if conversation.last_activity_at < now - timedelta(hours=24):  # ← 問題: last_activity_atベース
        # セッション無効化
        conversation.is_active = False  # ← 問題: is_activeフィールドが存在しない
        await db.commit()
        return False
    
    # 4. Redisにキャッシュ（v0.2追加）
    remaining_seconds = int(
        (conversation.last_activity_at + timedelta(hours=24) - now).total_seconds()
    )
    if remaining_seconds > 0:
        await redis_client.setex(
            cache_key,
            remaining_seconds,
            "1"
        )
    
    return True
```

**問題点**:
1. `is_active`フィールドが存在しない（設計書と実装の不一致）
2. `last_activity_at`ベースの判定（延長問題の原因）
3. 実際のコードベースには実装されていない

#### 2.1.4 Redisクライアントの実装

**ファイル**: `backend/app/redis_client.py`

**現在の実装**:
```python:1:45:backend/app/redis_client.py
"""
Redis接続設定
Redisへの非同期接続を管理
"""

from redis.asyncio import ConnectionPool, Redis
from app.core.config import settings
import logging

logger = logging.getLogger(__name__)

# Redis接続プール作成
pool = ConnectionPool.from_url(
    settings.redis_url,
    max_connections=10,  # 最大接続数
    decode_responses=True,  # レスポンスを自動デコード
)

# Redisクライアント作成
redis_client = Redis(connection_pool=pool)
```

**確認事項**:
- ✅ Redisクライアントが実装されている
- ✅ `redis_client.get()`、`redis_client.setex()`が使用可能

---

## 3. 修正案（大原則準拠）

### 3.1 大原則への準拠評価

#### 3.1.1 根本解決 > 暫定解決

**評価**: ✅ **完全準拠**

**理由**:
- `started_at`ベースの固定有効期限を実装することで、根本的に問題を解決
- 再アクセスによる延長を防止
- 一時的な回避策ではなく、設計レベルでの解決

#### 3.1.2 シンプル構造 > 複雑構造

**評価**: ✅ **完全準拠**

**理由**:
- `started_at`ベースの判定のみ（シンプル）
- `is_active`フィールドを追加しない（既存の`ended_at`を使用）
- 過度に複雑な実装を避けている

#### 3.1.3 統一・同一化 > 特殊独自

**評価**: ✅ **完全準拠**

**理由**:
- 既存の`started_at`フィールドを使用
- 既存の`ended_at`フィールドを使用（セッション終了時）
- 既存のパターンに従う

#### 3.1.4 具体的 > 一般

**評価**: ✅ **完全準拠**

**理由**:
- 具体的な実装方法を提示
- 具体的なファイル名と行番号を指定

#### 3.1.5 拙速 < 安全確実

**評価**: ✅ **完全準拠**

**理由**:
- バックアップ作成を必須とする
- ロールバック対策を提示
- テストを省略せず、十分な検証を行う

#### 3.1.6 Docker環境必須 > ローカル直接実行

**評価**: ✅ **完全準拠**

**理由**:
- Docker環境での動作確認を必須とする
- ローカル環境での直接実行を禁止

### 3.2 修正内容

#### 3.2.1 修正方針

**修正方針**: `started_at`ベースの固定有効期限を実装

**実装内容**:
1. `backend/app/utils/session.py`に`is_session_valid()`関数を実装
2. `chat_service.py`の`_get_or_create_conversation()`メソッドで、既存会話を取得する際に`is_session_valid()`を呼び出す
3. セッションが無効な場合は、新規セッションを作成する（既存の会話は無視）

**セッション無効化の方法**:
- `is_active`フィールドが存在しないため、`ended_at`を設定してセッションを終了させる
- または、既存の会話を無視して新規セッションを作成する

**推奨方法**: 既存の会話を無視して新規セッションを作成する（シンプル）

#### 3.2.2 修正内容の詳細

**ステップ1: `backend/app/utils/session.py`の作成**

**ファイル**: `backend/app/utils/session.py`（新規作成）

**実装内容**:
```python
"""
セッション管理ユーティリティ
セッション有効期限の判定を行う
"""

from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.conversation import Conversation
from app.redis_client import redis_client
import logging

logger = logging.getLogger(__name__)


async def is_session_valid(
    session_id: str,
    db: AsyncSession
) -> bool:
    """
    セッションが有効かチェック（防止策1: started_atベースの固定有効期限）
    
    Args:
        session_id: セッションID
        db: データベースセッション
    
    Returns:
        bool: セッションが有効な場合True、無効な場合False
    """
    # 1. Redisキャッシュ確認（高速化）
    cache_key = f"session:{session_id}"
    try:
        cached = await redis_client.get(cache_key)
        if cached:
            return True
    except Exception as e:
        logger.warning(f"Redis cache check failed: {e}")
        # Redisエラー時はデータベースで確認を続行
    
    # 2. データベース確認
    result = await db.execute(
        select(Conversation).where(
            Conversation.session_id == session_id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if conversation is None:
        return False
    
    # 3. started_atから24時間以内かチェック（固定有効期限）
    now = datetime.utcnow()
    session_expires_at = conversation.started_at + timedelta(hours=24)
    
    if now > session_expires_at:
        # セッション無効化（ended_atを設定）
        conversation.ended_at = now
        await db.commit()
        logger.info(f"Session expired: session_id={session_id}, started_at={conversation.started_at}, expires_at={session_expires_at}")
        return False
    
    # 4. Redisにキャッシュ（残り有効期限をTTLとして設定）
    remaining_seconds = int((session_expires_at - now).total_seconds())
    if remaining_seconds > 0:
        try:
            await redis_client.setex(
                cache_key,
                remaining_seconds,
                "1"
            )
        except Exception as e:
            logger.warning(f"Redis cache set failed: {e}")
            # Redisエラー時は続行（データベースで判定可能）
    
    return True
```

**ステップ2: `chat_service.py`の修正**

**ファイル**: `backend/app/services/chat_service.py`

**修正箇所**: `_get_or_create_conversation()`メソッド（248-253行目）

**修正前**:
```python:248:253:backend/app/services/chat_service.py
if conversation:
    # 既存の会話を更新
    conversation.last_activity_at = datetime.utcnow()
    if location:
        conversation.location = location
    logger.debug(f"Existing conversation found: {conversation.id}")
```

**修正後**:
```python:248:260:backend/app/services/chat_service.py
if conversation:
    # セッション有効期限をチェック
    from app.utils.session import is_session_valid
    is_valid = await is_session_valid(session_id, self.db)
    
    if not is_valid:
        # セッションが無効な場合は、既存の会話を無視して新規セッションを作成
        logger.info(f"Session expired, creating new session: old_session_id={session_id}")
        conversation = None  # 既存の会話を無視
    else:
        # 既存の会話を更新
        conversation.last_activity_at = datetime.utcnow()
        if location:
            conversation.location = location
        logger.debug(f"Existing conversation found: {conversation.id}")
```

**修正後の完全な実装**:
```python:212:280:backend/app/services/chat_service.py
async def _get_or_create_conversation(
    self,
    facility_id: int,
    session_id: Optional[str],
    language: str,
    location: Optional[str] = None,
    user_agent: Optional[str] = None,
    ip_address: Optional[str] = None
) -> Conversation:
    """
    会話の取得または新規作成
    
    Args:
        facility_id: 施設ID
        session_id: セッションID（Noneの場合は新規生成）
        language: 言語コード
        location: QRコード設置場所（オプション）
        user_agent: ユーザーエージェント（オプション）
        ip_address: IPアドレス（オプション）
    
    Returns:
        Conversation: 会話オブジェクト
    """
    # セッションIDが指定されていない場合は新規生成
    if not session_id:
        session_id = str(uuid.uuid4())
    
    # 既存の会話を検索
    result = await self.db.execute(
        select(Conversation).where(
            Conversation.facility_id == facility_id,
            Conversation.session_id == session_id
        )
    )
    conversation = result.scalar_one_or_none()
    
    if conversation:
        # セッション有効期限をチェック（防止策1: started_atベースの固定有効期限）
        from app.utils.session import is_session_valid
        is_valid = await is_session_valid(session_id, self.db)
        
        if not is_valid:
            # セッションが無効な場合は、既存の会話を無視して新規セッションを作成
            logger.info(f"Session expired, creating new session: old_session_id={session_id}, facility_id={facility_id}")
            conversation = None  # 既存の会話を無視
        else:
            # 既存の会話を更新
            conversation.last_activity_at = datetime.utcnow()
            if location:
                conversation.location = location
            logger.debug(f"Existing conversation found: conversation_id={conversation.id}, session_id={session_id}")
    
    if not conversation:
        # 新規会話を作成（既存の会話が存在しない、またはセッションが無効な場合）
        # セッションが無効な場合は、新しいセッションIDを生成
        if conversation is None and session_id:
            # 既存のセッションIDが無効な場合は、新しいセッションIDを生成
            session_id = str(uuid.uuid4())
            logger.info(f"Generating new session_id for expired session: new_session_id={session_id}")
        
        conversation = Conversation(
            facility_id=facility_id,
            session_id=session_id,
            guest_language=language,
            location=location,
            user_agent=user_agent,
            ip_address=ip_address,
            started_at=datetime.utcnow(),
            last_activity_at=datetime.utcnow()
        )
        self.db.add(conversation)
        await self.db.flush()
        logger.info(f"New conversation created: conversation_id={conversation.id}, session_id={session_id}")
    
    await self.db.commit()
    await self.db.refresh(conversation)
    return conversation
```

**注意事項**:
- セッションが無効な場合、既存の会話を無視して新規セッションを作成する
- 新しいセッションIDを生成する（既存のセッションIDが無効な場合）
- `last_activity_at`は、セッションが有効な場合のみ更新する

#### 3.2.3 会話履歴取得APIの修正

**ファイル**: `backend/app/services/chat_service.py`

**修正箇所**: `get_conversation_history()`メソッド（274-330行目）

**修正前**:
```python:274:330:backend/app/services/chat_service.py
async def get_conversation_history(
    self,
    session_id: str,
    facility_id: Optional[int] = None
) -> Optional[ChatHistoryResponse]:
    """
    会話履歴取得（v0.3新規）
    """
    # 会話を検索
    query = select(Conversation).where(Conversation.session_id == session_id)
    if facility_id:
        query = query.where(Conversation.facility_id == facility_id)
    
    result = await self.db.execute(query)
    conversation = result.scalar_one_or_none()
    
    if not conversation:
        logger.warning(f"Conversation not found: session_id={session_id}")
        return None
```

**修正後**:
```python:274:330:backend/app/services/chat_service.py
async def get_conversation_history(
    self,
    session_id: str,
    facility_id: Optional[int] = None
) -> Optional[ChatHistoryResponse]:
    """
    会話履歴取得（v0.3新規）
    """
    # セッション有効期限をチェック（防止策1: started_atベースの固定有効期限）
    from app.utils.session import is_session_valid
    is_valid = await is_session_valid(session_id, self.db)
    
    if not is_valid:
        logger.warning(f"Session expired: session_id={session_id}")
        return None
    
    # 会話を検索
    query = select(Conversation).where(Conversation.session_id == session_id)
    if facility_id:
        query = query.where(Conversation.facility_id == facility_id)
    
    result = await self.db.execute(query)
    conversation = result.scalar_one_or_none()
    
    if not conversation:
        logger.warning(f"Conversation not found: session_id={session_id}")
        return None
```

#### 3.2.4 エスカレーションAPIの修正

**ファイル**: `backend/app/api/v1/chat.py`

**修正箇所**: `escalate_to_staff()`エンドポイント（145-206行目）

**修正前**:
```python:160:173:backend/app/api/v1/chat.py
# セッションIDから会話を取得
result = await db.execute(
    select(Conversation).where(
        Conversation.facility_id == request.facility_id,
        Conversation.session_id == request.session_id
    )
)
conversation = result.scalar_one_or_none()

if not conversation:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Conversation not found: session_id={request.session_id}, facility_id={request.facility_id}"
    )
```

**修正後**:
```python:160:178:backend/app/api/v1/chat.py
# セッション有効期限をチェック（防止策1: started_atベースの固定有効期限）
from app.utils.session import is_session_valid
is_valid = await is_session_valid(request.session_id, db)

if not is_valid:
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail=f"Session expired: session_id={request.session_id}"
    )

# セッションIDから会話を取得
result = await db.execute(
    select(Conversation).where(
        Conversation.facility_id == request.facility_id,
        Conversation.session_id == request.session_id
    )
)
conversation = result.scalar_one_or_none()

if not conversation:
    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Conversation not found: session_id={request.session_id}, facility_id={request.facility_id}"
    )
```

---

## 4. ロールバック対策

### 4.1 バックアップ作成

**必須手順**:
1. **修正前のバックアップ作成**:
   ```bash
   # 新規作成ファイルの場合はバックアップ不要
   # 修正ファイルのバックアップ
   cp backend/app/services/chat_service.py \
      backend/app/services/chat_service.py.bak_$(date +%Y%m%d_%H%M%S)
   cp backend/app/api/v1/chat.py \
      backend/app/api/v1/chat.py.bak_$(date +%Y%m%d_%H%M%S)
   ```

2. **Gitコミット**:
   ```bash
   git add backend/app/utils/session.py backend/app/services/chat_service.py backend/app/api/v1/chat.py
   git commit -m "backup: before session expiration fix (prevention strategy 1)"
   ```

### 4.2 ロールバック手順

#### 4.2.1 方法1: バックアップファイルから復元

**手順**:
1. バックアップファイルを確認:
   ```bash
   ls -lt backend/app/services/chat_service.py.bak_* | head -1
   ls -lt backend/app/api/v1/chat.py.bak_* | head -1
   ```

2. バックアップファイルから復元:
   ```bash
   cp backend/app/services/chat_service.py.bak_YYYYMMDD_HHMMSS \
      backend/app/services/chat_service.py
   cp backend/app/api/v1/chat.py.bak_YYYYMMDD_HHMMSS \
      backend/app/api/v1/chat.py
   ```

3. 新規作成ファイルを削除:
   ```bash
   rm backend/app/utils/session.py
   ```

4. Docker環境で動作確認:
   ```bash
   docker-compose restart backend
   docker-compose logs backend
   ```

#### 4.2.2 方法2: Gitでロールバック

**手順**:
1. 修正前のコミットを確認:
   ```bash
   git log --oneline backend/app/services/chat_service.py backend/app/api/v1/chat.py | head -5
   ```

2. 修正前のコミットに戻す:
   ```bash
   git checkout <commit-hash> -- backend/app/services/chat_service.py backend/app/api/v1/chat.py
   ```

3. 新規作成ファイルを削除:
   ```bash
   rm backend/app/utils/session.py
   ```

4. Docker環境で動作確認:
   ```bash
   docker-compose restart backend
   docker-compose logs backend
   ```

#### 4.2.3 方法3: 手動で修正を元に戻す

**手順**:
1. `backend/app/utils/session.py`を削除
2. `backend/app/services/chat_service.py`の修正を元に戻す
3. `backend/app/api/v1/chat.py`の修正を元に戻す
4. Docker環境で動作確認

### 4.3 ロールバック確認チェックリスト

**ロールバック後の確認項目**:
- [ ] セッション有効期限の判定が行われていない（元の動作に戻る）
- [ ] チャットメッセージ送信が正常に動作する
- [ ] 会話履歴取得が正常に動作する
- [ ] エスカレーションが正常に動作する
- [ ] エラーが発生しない
- [ ] Docker環境で正常に動作する

---

## 5. 実施手順

### 5.1 修正前の準備

1. **バックアップ作成**:
   ```bash
   cp backend/app/services/chat_service.py \
      backend/app/services/chat_service.py.bak_$(date +%Y%m%d_%H%M%S)
   cp backend/app/api/v1/chat.py \
      backend/app/api/v1/chat.py.bak_$(date +%Y%m%d_%H%M%S)
   ```

2. **Gitコミット**:
   ```bash
   git add backend/app/services/chat_service.py backend/app/api/v1/chat.py
   git commit -m "backup: before session expiration fix (prevention strategy 1)"
   ```

### 5.2 修正実施

1. **`backend/app/utils/session.py`を新規作成**
2. **`backend/app/services/chat_service.py`を修正**
3. **`backend/app/api/v1/chat.py`を修正**

### 5.3 修正後の確認

1. **Docker環境で動作確認**:
   ```bash
   docker-compose restart backend
   docker-compose logs backend
   ```

2. **構文チェック**:
   ```bash
   docker-compose exec backend python -m py_compile app/utils/session.py
   docker-compose exec backend python -m py_compile app/services/chat_service.py
   docker-compose exec backend python -m py_compile app/api/v1/chat.py
   ```

3. **インポートチェック**:
   ```bash
   docker-compose exec backend python -c "from app.utils.session import is_session_valid; print('OK')"
   ```

4. **ブラウザで確認**:
   - ゲスト画面でチャットメッセージを送信
   - 24時間経過後に再アクセスしてセッションが無効になることを確認

### 5.4 コミット・プッシュ

1. **Gitコミット**:
   ```bash
   git add backend/app/utils/session.py backend/app/services/chat_service.py backend/app/api/v1/chat.py
   git commit -m "fix: セッション有効期限延長問題の防止策1実装（started_atベースの固定有効期限）"
   ```

2. **プッシュ**:
   ```bash
   git push origin develop
   ```

---

## 6. 確認事項チェックリスト

### 6.1 修正前

- [ ] バックアップ作成完了
- [ ] Gitコミット完了
- [ ] 修正内容の確認完了

### 6.2 修正中

- [ ] `backend/app/utils/session.py`を新規作成
- [ ] `backend/app/services/chat_service.py`を修正
- [ ] `backend/app/api/v1/chat.py`を修正

### 6.3 修正後

- [ ] Docker環境で動作確認完了
- [ ] 構文チェック完了
- [ ] インポートチェック完了
- [ ] ブラウザで動作確認完了
- [ ] セッション有効期限の判定が正しく動作することを確認完了
- [ ] Gitコミット・プッシュ完了

---

## 7. リスクと対策

### 7.1 リスク1: 既存セッションの無効化

**リスク**: 既存の有効なセッションが無効化される可能性

**対策**:
- `started_at`ベースの判定により、24時間以内のセッションは有効
- 既存のセッションは影響を受けない

### 7.2 リスク2: Redis接続エラー

**リスク**: Redis接続エラー時にセッション判定が失敗する

**対策**:
- Redisエラー時はデータベースで判定を続行
- エラーハンドリングを実装

### 7.3 リスク3: セッションIDの変更

**リスク**: セッションが無効な場合、新しいセッションIDが生成されるため、フロントエンドでセッションIDを更新する必要がある

**対策**:
- `ChatResponse`に`session_id`を含める（既に実装済み）
- フロントエンドで`session_id`を更新する（既に実装済み）

### 7.4 リスク4: 会話履歴の消失

**リスク**: セッションが無効な場合、既存の会話履歴が表示されなくなる

**対策**:
- これは期待される動作（24時間経過後はセッションを無効化）
- 既存の会話履歴はデータベースに保存されている（削除されない）

---

## 8. テストケース

### 8.1 正常系テスト

1. **新規セッション作成**
   - セッションIDが指定されていない場合、新規セッションが作成される
   - `started_at`が現在時刻に設定される

2. **有効なセッションでのアクセス**
   - 24時間以内のセッションでアクセスした場合、既存の会話が取得される
   - `last_activity_at`が更新される

3. **無効なセッションでのアクセス**
   - 24時間経過後のセッションでアクセスした場合、新規セッションが作成される
   - 既存の会話は無視される

### 8.2 異常系テスト

1. **Redis接続エラー**
   - Redis接続エラー時、データベースで判定を続行
   - エラーが発生しても処理が継続される

2. **セッションIDが存在しない**
   - セッションIDが存在しない場合、新規セッションが作成される

---

## 9. まとめ

### 9.1 修正内容サマリー

**修正対象ファイル**:
1. `backend/app/utils/session.py`（新規作成）
2. `backend/app/services/chat_service.py`（修正）
3. `backend/app/api/v1/chat.py`（修正）

**修正内容**: `started_at`ベースの固定有効期限を実装

**期待される結果**:
- ✅ セッション開始時刻から24時間の固定有効期限
- ✅ 再アクセスによる延長を防止
- ✅ 24時間経過後はセッションを無効化

### 9.2 大原則への準拠

- ✅ **根本解決 > 暫定解決**: `started_at`ベースの固定有効期限を実装（根本解決）
- ✅ **シンプル構造 > 複雑構造**: `started_at`ベースの判定のみ（シンプル）
- ✅ **統一・同一化 > 特殊独自**: 既存の`started_at`フィールドを使用
- ✅ **具体的 > 一般**: 具体的な実装方法を提示
- ✅ **拙速 < 安全確実**: バックアップ作成、ロールバック対策、テスト実施
- ✅ **Docker環境必須**: Docker環境での動作確認を必須とする

### 9.3 ロールバック対策

- ✅ バックアップファイル作成
- ✅ Gitコミット
- ✅ 複数のロールバック方法を提示
- ✅ ロールバック確認チェックリスト

---

**Document Version**: v1.0  
**Author**: AI Assistant  
**Last Updated**: 2025年12月22日  
**Status**: ✅ **完全調査分析完了、修正案提示完了**

**重要**: この修正案は、ユーザーの指示があるまで実施しません。修正を実施する場合は、必ずバックアップを作成し、ロールバック対策を確認してから実施してください。


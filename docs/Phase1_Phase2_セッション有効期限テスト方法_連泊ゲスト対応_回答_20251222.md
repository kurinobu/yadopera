# Phase 1・Phase 2: セッション有効期限テスト方法・連泊ゲスト対応 回答

**作成日時**: 2025年12月22日  
**実施者**: AI Assistant  
**対象**: セッション有効期限の簡易テスト方法と連泊ゲスト対応の確認  
**状態**: ✅ **回答完了**

---

## 1. 24時間経過後のテストを簡易的に実行する方法

### 1.1 方法1: 環境変数で有効期限を設定（推奨）

**概要**: 環境変数でセッション有効期限を設定できるようにする

**実装方法**:

1. **`backend/app/core/config.py`に環境変数を追加**:
```python
class Settings(BaseSettings):
    # ... 既存の設定 ...
    
    # セッション有効期限（時間単位、デフォルト: 24時間）
    session_expires_hours: int = 24
```

2. **`backend/app/utils/session.py`を修正**:
```python
from app.core.config import settings

async def is_session_valid(
    session_id: str,
    db: AsyncSession
) -> bool:
    # ... 既存のコード ...
    
    # 3. started_atから設定された時間以内かチェック（固定有効期限）
    now = datetime.utcnow()
    session_expires_at = conversation.started_at + timedelta(hours=settings.session_expires_hours)
    
    # ... 既存のコード ...
```

3. **テスト時の環境変数設定**:
```bash
# .envファイルに追加（テスト用）
SESSION_EXPIRES_HOURS=0.01  # 36秒（0.01時間）
# または
SESSION_EXPIRES_HOURS=0.1   # 6分（0.1時間）
```

**メリット**:
- ✅ コードを変更せずにテスト可能
- ✅ 本番環境では24時間、テスト環境では短い時間に設定可能
- ✅ 環境変数で簡単に切り替え可能

**デメリット**:
- ⚠️ 環境変数の追加が必要

---

### 1.2 方法2: テスト用の関数を作成

**概要**: テスト用に`started_at`を過去の時刻に設定したテストデータを作成

**実装方法**:

1. **テストスクリプトを作成** (`backend/test_session_expiration.py`):
```python
"""
セッション有効期限のテスト用スクリプト
"""
import asyncio
from datetime import datetime, timedelta
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.models.conversation import Conversation
from app.utils.session import is_session_valid

async def test_session_expiration():
    """
    セッション有効期限のテスト
    """
    async for db in get_db():
        # テスト用の会話を作成（25時間前に開始）
        test_conversation = Conversation(
            facility_id=1,
            session_id="test-session-expired",
            guest_language="en",
            started_at=datetime.utcnow() - timedelta(hours=25),  # 25時間前
            last_activity_at=datetime.utcnow() - timedelta(hours=25)
        )
        db.add(test_conversation)
        await db.commit()
        
        # セッション有効期限をチェック
        is_valid = await is_session_valid("test-session-expired", db)
        
        print(f"Session expired test: is_valid={is_valid} (expected: False)")
        assert is_valid == False, "セッションは無効であるべき"
        
        # テスト用の会話を作成（23時間前に開始）
        test_conversation2 = Conversation(
            facility_id=1,
            session_id="test-session-valid",
            guest_language="en",
            started_at=datetime.utcnow() - timedelta(hours=23),  # 23時間前
            last_activity_at=datetime.utcnow() - timedelta(hours=23)
        )
        db.add(test_conversation2)
        await db.commit()
        
        # セッション有効期限をチェック
        is_valid2 = await is_session_valid("test-session-valid", db)
        
        print(f"Session valid test: is_valid={is_valid2} (expected: True)")
        assert is_valid2 == True, "セッションは有効であるべき"
        
        # クリーンアップ
        await db.delete(test_conversation)
        await db.delete(test_conversation2)
        await db.commit()
        
        break

if __name__ == "__main__":
    asyncio.run(test_session_expiration())
```

2. **テスト実行**:
```bash
docker-compose exec backend python test_session_expiration.py
```

**メリット**:
- ✅ 実際のデータベースでテスト可能
- ✅ 自動テストとして実行可能

**デメリット**:
- ⚠️ テストスクリプトの作成が必要

---

### 1.3 方法3: データベースで直接`started_at`を更新

**概要**: 既存の会話の`started_at`を過去の時刻に更新してテスト

**実装方法**:

1. **データベースに接続**:
```bash
docker-compose exec postgres psql -U yadopera_user -d yadopera
```

2. **既存の会話の`started_at`を25時間前に更新**:
```sql
-- 会話IDを確認
SELECT id, session_id, started_at, last_activity_at 
FROM conversations 
WHERE facility_id = 1 
ORDER BY id DESC 
LIMIT 5;

-- 特定のセッションIDのstarted_atを25時間前に更新
UPDATE conversations 
SET started_at = NOW() - INTERVAL '25 hours',
    last_activity_at = NOW() - INTERVAL '25 hours'
WHERE session_id = 'your-session-id-here';
```

3. **ブラウザでテスト**:
   - 該当のセッションIDでチャットメッセージを送信
   - セッションが無効になり、新しいセッションが作成されることを確認

**メリット**:
- ✅ 簡単にテスト可能
- ✅ 実際のブラウザで動作確認可能

**デメリット**:
- ⚠️ データベースを直接操作する必要がある
- ⚠️ テスト後にデータを戻す必要がある

---

### 1.4 推奨方法

**推奨**: **方法1（環境変数で有効期限を設定）**

**理由**:
1. コードを変更せずにテスト可能
2. 本番環境とテスト環境で簡単に切り替え可能
3. 他のテスト方法と組み合わせて使用可能

**実装手順**:
1. `backend/app/core/config.py`に`session_expires_hours`を追加
2. `backend/app/utils/session.py`で環境変数を使用
3. テスト時は`.env`ファイルで`SESSION_EXPIRES_HOURS=0.01`（36秒）に設定
4. 36秒待ってから再アクセスしてテスト

---

## 2. 連泊のゲストが再度QRコードを読み込めるかどうか

### 2.1 現在の実装の確認

**実装内容**:

1. **セッションが無効な場合の処理** (`backend/app/services/chat_service.py`):
```python:253:259:backend/app/services/chat_service.py
if not is_valid:
    # セッションが無効な場合は、既存の会話を無視して新規セッションを作成
    logger.info(f"Session expired, creating new session: old_session_id={session_id}, facility_id={facility_id}")
    conversation = None  # 既存の会話を無視
    # 既存のセッションIDが無効な場合は、新しいセッションIDを生成
    session_id = str(uuid.uuid4())
    logger.info(f"Generating new session_id for expired session: new_session_id={session_id}")
```

2. **新規セッションの作成**:
```python:267:281:backend/app/services/chat_service.py
if not conversation:
    # 新規会話を作成（既存の会話が存在しない、またはセッションが無効な場合）
    conversation = Conversation(
        facility_id=facility_id,
        session_id=session_id,
        guest_language=language,
        location=location,
        user_agent=user_agent,
        ip_address=ip_address,
        started_at=datetime.utcnow(),
        last_activity_at=datetime.utcnow()
    )
    self.db.add(conversation)
    await self.db.flush()
    logger.info(f"New conversation created: conversation_id={conversation.id}, session_id={session_id}")
```

3. **フロントエンドでのセッションID更新** (`frontend/src/composables/useChat.ts`):
```typescript:48:55:frontend/src/composables/useChat.ts
// セッションIDを更新
if (response.session_id) {
  console.log('[useChat] sendMessage: セッションID更新', {
    oldSessionId: chatStore.currentSessionId,
    newSessionId: response.session_id
  })
  chatStore.setSessionId(response.session_id)
}
```

### 2.2 連泊ゲストの動作フロー

**シナリオ**: 連泊のゲストが2日目に再度QRコードを読み込む場合

1. **1日目（初回QRコード読み込み）**:
   - QRコードを読み込む
   - セッションID: `session-001`が生成される
   - `started_at`: 2025-12-21 10:00:00
   - チャットメッセージを送信

2. **2日目（24時間経過後、再度QRコード読み込み）**:
   - QRコードを読み込む
   - 既存のセッションID: `session-001`がCookieに保存されている
   - バックエンドで`is_session_valid()`を呼び出す
   - `started_at`から24時間経過しているため、セッションは無効
   - 新しいセッションID: `session-002`が生成される
   - 新しい会話が作成される（`started_at`: 2025-12-22 10:00:00）
   - `ChatResponse`に新しい`session_id`が含まれる
   - フロントエンドでセッションIDが更新される（`session-002`）

3. **結果**:
   - ✅ 新しいセッションが作成される
   - ✅ 新しい会話が開始される
   - ✅ フロントエンドでセッションIDが更新される
   - ✅ チャットメッセージを送信可能

### 2.3 確認事項

**問題点の可能性**:

1. **Cookieの有効期限**:
   - フロントエンドの`SESSION_ID_EXPIRES_DAYS = 1`（24時間）
   - Cookieが24時間経過すると削除される可能性がある
   - しかし、QRコードを読み込むと新しいセッションIDが生成されるため、問題なし

2. **セッションIDの更新**:
   - `ChatResponse`に`session_id`が含まれている
   - フロントエンドで`chatStore.setSessionId()`が呼び出される
   - Cookieも更新される（`useSession.ts`の`linkSession()`関数内）

3. **会話履歴の継続**:
   - 新しいセッションが作成されるため、1日目の会話履歴は表示されない
   - これは期待される動作（24時間経過後は新しいセッションとして扱う）

### 2.4 結論

**✅ 連泊のゲストは再度QRコードを読み込めばアクセスできます**

**動作確認**:
1. 24時間経過後、QRコードを再度読み込む
2. 新しいセッションIDが生成される
3. 新しい会話が作成される
4. チャットメッセージを送信可能

**注意事項**:
- 1日目の会話履歴は表示されない（新しいセッションとして扱われる）
- セッション統合トークンを使用すれば、1日目の会話履歴を統合できる可能性がある（要確認）

---

## 3. 推奨される改善案

### 3.1 セッション有効期限のテスト用設定

**実装**: 環境変数で有効期限を設定できるようにする（方法1）

**メリット**:
- テストが簡単になる
- 本番環境とテスト環境で切り替え可能

### 3.2 連泊ゲストの会話履歴統合

**改善案**: セッション統合トークンを使用して、1日目の会話履歴を統合できるようにする

**実装方法**:
1. 1日目にセッション統合トークンを生成
2. 2日目にQRコードを読み込む際、同じトークンを入力
3. 1日目の会話履歴を統合

**注意事項**:
- セッション統合トークンの有効期限を確認する必要がある
- 現在の実装では、セッション統合トークンは24時間有効（`timedelta(hours=24)`）

---

## 4. まとめ

### 4.1 24時間経過後のテスト方法

**推奨方法**: 環境変数で有効期限を設定（`SESSION_EXPIRES_HOURS=0.01`で36秒）

**実装手順**:
1. `backend/app/core/config.py`に`session_expires_hours`を追加
2. `backend/app/utils/session.py`で環境変数を使用
3. テスト時は`.env`ファイルで短い時間に設定

### 4.2 連泊ゲストの対応

**✅ 問題なし**: 連泊のゲストは再度QRコードを読み込めばアクセスできます

**動作**:
- 24時間経過後、QRコードを再度読み込む
- 新しいセッションIDが生成される
- 新しい会話が作成される
- チャットメッセージを送信可能

**注意事項**:
- 1日目の会話履歴は表示されない（新しいセッションとして扱われる）
- セッション統合トークンを使用すれば、会話履歴を統合できる可能性がある

---

**Document Version**: v1.0  
**Author**: AI Assistant  
**Last Updated**: 2025年12月22日  
**Status**: ✅ **回答完了**


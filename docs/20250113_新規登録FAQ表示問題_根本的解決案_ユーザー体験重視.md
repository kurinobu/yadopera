# 新規登録FAQ表示問題 - 根本的解決案（ユーザー体験重視）

## 1. 問題の重要性

### 1.1 ユーザー体験への影響

**新規登録時の最初の印象が信用に直結する**という重要な指摘を受けました。

- 宿泊施設管理者が最初に登録し、このアプリと関係を結び使い始める
- 最初から表示にウソがあったり期待しないものであると、最初から信用失墜
- **最初の自動登録はFreeプランは20件、その他は30件**を確実に表示する必要がある

### 1.2 現在の問題

- **現象**: Standardプランで新規登録後、FAQ一覧を確認すると5件のみ表示
- **リロード後**: 17件表示
- **期待値**: 30件表示
- **データベース**: 30件のFAQが正しく登録されている

### 1.3 ステージング環境の考慮

- ステージング環境ではさらにデータベースへの接続が時間がかかる可能性がある
- バックグラウンド処理の実行時間がさらに延びる可能性がある

## 2. 根本原因の再確認

### 2.1 バックグラウンド処理の実行時間

**測定結果**:
- 10件目: 約10.42秒後
- 20件目: 約17.56秒後
- 30件目: 約25.09秒後
- **合計実行時間**: 約25秒

### 2.2 問題の発生フロー

1. **新規登録API完了**（約2-3秒）
   - 施設・ユーザー作成完了
   - JWTトークン返却
   - バックグラウンド処理開始

2. **フロントエンドがFAQ一覧を取得**（約3-5秒後）
   - バックグラウンド処理は進行中（5-10件作成済み）
   - FAQ一覧取得APIが呼び出される
   - **途中の状態（5件、17件など）が表示される**

3. **バックグラウンド処理完了**（約25秒後）
   - 30件のFAQがすべて作成される
   - しかし、フロントエンドは既に途中の状態を表示している

### 2.3 フロントエンドのタイムアウト制約

- **現在のタイムアウト**: 10秒
- **バックグラウンド処理完了まで**: 約25秒
- **問題**: バックグラウンド処理が完了するまで待機すると、タイムアウトエラーが発生する

## 3. 大原則に準拠した修正案

### 3.1 修正方針

**大原則**:
1. **根本的な解決**: タイミング問題を根本的に解決する
2. **ユーザー体験の重視**: 最初の印象を損なわない
3. **誠意ある対応**: できない場合は、できる限度で表示するか、アナウンスを表示する

### 3.2 推奨修正案: 段階的コミット + フロントエンドポーリング

**概要**:
1. **バックグラウンド処理を段階的にコミット**
   - 20件作成したら一度コミット（Freeプランは20件、その他は30件のうち20件）
   - その後、残りの10件を作成してコミット
   - これにより、早期に確実なデータを表示できる

2. **フロントエンドでポーリング**
   - FAQ一覧取得APIで、期待値と一致しない場合は、進行中の状態を返す
   - フロントエンドで定期的にFAQ一覧を取得し、期待値と一致するまでリトライ
   - 進行中の場合は、アナウンスを表示（「デフォルトのFAQを新規登録中です。しばらくお待ち下さい」）

**メリット**:
- ✅ **根本的な解決**: タイミング問題を根本的に解決
- ✅ **ユーザー体験の向上**: 早期に確実なデータを表示できる
- ✅ **誠意ある対応**: 進行中の場合は、アナウンスを表示
- ✅ **タイムアウト問題の回避**: フロントエンドのタイムアウト（10秒）を超えない
- ✅ **ステージング環境への対応**: データベース接続が遅い環境でも対応可能

**デメリット**:
- 実装がやや複雑になる
- フロントエンドの実装が必要

### 3.3 代替案1: バックグラウンド処理完了フラグ + フロントエンドポーリング

**概要**:
1. 施設テーブルに`faq_initialization_completed`フラグを追加
2. FAQ一覧取得APIで、フラグが`False`の場合は、進行中の状態を返す
3. フロントエンドで定期的にFAQ一覧を取得し、完了するまでリトライ

**メリット**:
- 実装が比較的簡単
- 確実に完了を検知できる

**デメリット**:
- データベーススキーマの変更が必要
- 完了するまで待機する必要がある

### 3.4 代替案2: 段階的コミットのみ（フロントエンドポーリングなし）

**概要**:
1. バックグラウンド処理を段階的にコミット（20件 → 10件）
2. フロントエンドは通常通りFAQ一覧を取得
3. 進行中の場合は、現在のFAQ数を表示

**メリット**:
- 実装が簡単
- フロントエンドの変更が不要

**デメリット**:
- 途中の状態（20件）が表示される可能性がある
- ユーザー体験がやや劣る

## 4. 推奨修正案の詳細実装

### 4.1 修正1: バックグラウンド処理の段階的コミット

**実装**:
```python
@staticmethod
async def register_facility_async_faqs(
    facility_id: int,
    user_id: int,
    subscription_plan: str
):
    from app.database import AsyncSessionLocal
    from app.data.faq_presets import FAQ_PRESETS
    from app.schemas.faq import FAQRequest
    from app.core.cache import delete_cache_pattern
    from app.core.plan_limits import get_initial_faq_count
    
    async with AsyncSessionLocal() as db:
        try:
            # 料金プランに基づいてFAQプリセットをフィルタ
            filtered_presets = filter_faq_presets_by_plan(
                FAQ_PRESETS,
                subscription_plan
            )
            
            # プリセットFAQをFAQRequestに変換
            faq_requests = []
            for preset in filtered_presets:
                faq_request = FAQRequest(...)
                faq_requests.append(faq_request)
            
            # 初期自動登録件数を取得
            initial_count = get_initial_faq_count(subscription_plan)
            
            # 段階的コミット: 20件作成したら一度コミット
            faq_service = FAQService(db)
            created_faqs = []
            
            # 第1段階: 20件作成してコミット
            first_batch = faq_requests[:20]
            for request in first_batch:
                try:
                    faq_response = await faq_service.create_faq(
                        facility_id=facility_id,
                        request=request,
                        user_id=user_id
                    )
                    created_faqs.append(faq_response)
                except Exception as e:
                    logger.warning(f"Bulk FAQ creation: skipped: {str(e)}")
                    continue
            
            # 第1段階をコミット
            await db.commit()
            
            # キャッシュを無効化
            try:
                await delete_cache_pattern(f"faq:list:*facility_id={facility_id}*")
                logger.info(f"FAQ cache invalidated after first batch: facility_id={facility_id}")
            except Exception as e:
                logger.warning(f"Failed to invalidate FAQ cache: {str(e)}")
            
            # 第2段階: 残りの件数を作成してコミット（30件の場合のみ）
            if initial_count > 20:
                remaining_requests = faq_requests[20:initial_count]
                for request in remaining_requests:
                    try:
                        faq_response = await faq_service.create_faq(
                            facility_id=facility_id,
                            request=request,
                            user_id=user_id
                        )
                        created_faqs.append(faq_response)
                    except Exception as e:
                        logger.warning(f"Bulk FAQ creation: skipped: {str(e)}")
                        continue
                
                # 第2段階をコミット
                await db.commit()
                
                # キャッシュを無効化
                try:
                    await delete_cache_pattern(f"faq:list:*facility_id={facility_id}*")
                    logger.info(f"FAQ cache invalidated after second batch: facility_id={facility_id}")
                except Exception as e:
                    logger.warning(f"Failed to invalidate FAQ cache: {str(e)}")
            
            logger.info(
                f"Background FAQ creation completed: facility_id={facility_id}, "
                f"plan={subscription_plan}, count={len(created_faqs)}"
            )
            
        except Exception as e:
            logger.error(
                f"Background FAQ creation failed: facility_id={facility_id}, "
                f"plan={subscription_plan}, error={str(e)}",
                exc_info=True
            )
```

### 4.2 修正2: FAQ一覧取得APIの進行状況検知

**実装**:
```python
async def get_faqs(
    self,
    facility_id: int,
    category: Optional[str] = None,
    is_active: Optional[bool] = None
) -> List[FAQResponse]:
    # ... (既存のキャッシュチェック)
    
    # バックグラウンド処理が完了しているか確認
    from app.models.facility import Facility
    from app.core.plan_limits import get_initial_faq_count
    from datetime import datetime, timezone, timedelta
    
    facility = await self.db.get(Facility, facility_id)
    if facility:
        time_since_creation = datetime.now(timezone.utc) - facility.created_at
        
        # 施設作成から60秒以内の場合、バックグラウンド処理が完了しているか確認
        if time_since_creation < timedelta(seconds=60):
            expected_count = get_initial_faq_count(facility.subscription_plan)
            
            # 実際のFAQ数を取得
            query = select(FAQ).where(FAQ.facility_id == facility_id)
            if category:
                query = query.where(FAQ.category == category)
            if is_active is not None:
                query = query.where(FAQ.is_active == is_active)
            result = await self.db.execute(query)
            actual_count = len(result.scalars().all())
            
            # 期待値と一致しない場合、進行中の状態を示す
            if actual_count < expected_count:
                # 進行中の場合は、現在のFAQ数を返す（フロントエンドでポーリング）
                # ただし、20件以上ある場合は、20件を返す（Freeプランは20件、その他は30件のうち20件）
                if actual_count >= 20:
                    # 20件を返す（第1段階が完了している）
                    query = query.limit(20)
                    result = await self.db.execute(query)
                    faqs = result.scalars().all()
                    # ... (FAQResponse作成)
                    return faq_responses
                else:
                    # 20件未満の場合は、現在のFAQ数を返す
                    # フロントエンドでポーリングする
                    pass
    
    # ... (既存のFAQ取得処理)
```

### 4.3 修正3: フロントエンドのポーリング実装

**実装**:
```typescript
// frontend/src/views/admin/FaqManagement.vue
const fetchFaqs = async () => {
  try {
    loading.value = true
    error.value = null
    
    const expectedCount = getExpectedFaqCount(currentUser.value?.subscription_plan)
    let retryCount = 0
    const maxRetries = 30 // 最大30回（約30秒）
    const pollInterval = 1000 // 1秒ごとにポーリング
    
    while (retryCount < maxRetries) {
      const data = await faqApi.getFaqs()
      
      if (data.length >= expectedCount) {
        // 期待値と一致する場合、FAQ一覧を表示
        faqs.value = data
        loading.value = false
        return
      }
      
      // 期待値と一致しない場合、進行中の状態を表示
      if (data.length >= 20) {
        // 20件以上ある場合は、20件を表示
        faqs.value = data.slice(0, 20)
        // アナウンスを表示
        showInitializationMessage.value = true
      } else {
        // 20件未満の場合は、アナウンスのみを表示
        faqs.value = []
        showInitializationMessage.value = true
      }
      
      // 1秒待機してから再試行
      await new Promise(resolve => setTimeout(resolve, pollInterval))
      retryCount++
    }
    
    // 最大リトライ回数に達した場合、現在のFAQ数を表示
    const data = await faqApi.getFaqs()
    faqs.value = data
    if (data.length < expectedCount) {
      // 期待値と一致しない場合、警告を表示
      error.value = `デフォルトのFAQの登録が完了していません。現在${data.length}件のFAQが表示されています。`
    }
  } catch (err: any) {
    console.error('Failed to fetch FAQs:', err)
    error.value = err.response?.data?.detail || 'FAQ一覧の取得に失敗しました'
  } finally {
    loading.value = false
  }
}
```

### 4.4 修正4: アナウンスメッセージの表示

**実装**:
```vue
<!-- frontend/src/views/admin/FaqManagement.vue -->
<template>
  <div>
    <!-- アナウンスメッセージ -->
    <div v-if="showInitializationMessage" class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-md">
      <p class="text-blue-800">
        <span class="font-semibold">デフォルトのFAQを新規登録中です。しばらくお待ち下さい。</span>
        <br>
        <span class="text-sm">自動的に更新されます。</span>
      </p>
    </div>
    
    <!-- FAQ一覧 -->
    <FaqList :faqs="faqs" />
  </div>
</template>
```

## 5. 実装手順

1. **修正1: バックグラウンド処理の段階的コミット**
   - `register_facility_async_faqs`を修正
   - 20件作成したら一度コミット
   - 残りの10件を作成してコミット

2. **修正2: FAQ一覧取得APIの進行状況検知**
   - `get_faqs`を修正
   - 進行中の場合は、現在のFAQ数を返す

3. **修正3: フロントエンドのポーリング実装**
   - `FaqManagement.vue`を修正
   - 期待値と一致するまでリトライ
   - 進行中の場合は、アナウンスを表示

4. **修正4: アナウンスメッセージの表示**
   - `FaqManagement.vue`にアナウンスメッセージを追加

5. **テスト**
   - Freeプランで新規登録 → 20件表示されることを確認
   - Standardプランで新規登録 → 30件表示されることを確認
   - 進行中の場合は、アナウンスが表示されることを確認

## 6. 期待される効果

1. **早期に確実なデータを表示**: 20件作成したら一度コミットするため、早期に確実なデータを表示できる
2. **ユーザー体験の向上**: 進行中の場合は、アナウンスを表示することで、誠意ある対応を示す
3. **タイムアウト問題の回避**: フロントエンドのタイムアウト（10秒）を超えない
4. **ステージング環境への対応**: データベース接続が遅い環境でも対応可能

## 7. 注意事項

1. **ポーリング間隔**: 1秒ごとにポーリングするため、サーバー負荷が増加する可能性がある
2. **最大リトライ回数**: 30回（約30秒）に設定しているが、ステージング環境ではさらに延びる可能性がある
3. **アナウンスメッセージ**: ユーザーに進行状況を伝えることが重要

## 8. 代替案（より簡単な実装）

フロントエンドのポーリング実装が複雑な場合は、以下の代替案も検討できます：

1. **段階的コミットのみ**: バックグラウンド処理を段階的にコミット（20件 → 10件）
2. **フロントエンドは通常通り**: FAQ一覧を取得し、期待値と一致しない場合は、アナウンスを表示
3. **手動リロード**: ユーザーに手動でリロードを促す

ただし、この代替案はユーザー体験がやや劣るため、推奨修正案の実装を優先することを推奨します。

